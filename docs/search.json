[{"path":[]},{"path":"/TODO.html","id":"prediction-function-without-data-update","dir":"","previous_headings":"","what":"Prediction function without data update","title":"add_parameters","text":"moment diff eqs simulation (stochastic!)","code":""},{"path":[]},{"path":"/TODO.html","id":null,"dir":"","previous_headings":"","what":"add_parameters","title":"add_parameters","text":"doesnt remove fixed parameter recalling add_parameters without NA’s. need update ","code":""},{"path":[]},{"path":"/articles/constructNegLogLike.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"Extracting likelihood function, gradient and using custom optimizers","text":"use common Ornstein-Uhlenbeck process showcase use constructNegLogLike. \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/constructNegLogLike.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Extracting likelihood function, gradient and using custom optimizers","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/constructNegLogLike.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"Extracting likelihood function, gradient and using custom optimizers","text":"principle ready call estimate method run optimization scheme using built-optimization uses stats::nlminb .e. Inside package optimise objective function respect fixed parameters using construction function handlers TMB::MakeADFun parsing stats::nlminb .e.","code":"fit = obj$estimate(.data) ## Building model... ## Compiling model... ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.054 seconds. ## Minimizing the negative log-likelihood... ##   0:     921.77031:  1.60944  0.00000 -2.30259 -2.30259 ##   1:     86.857795:  1.06416 0.614170 -1.83281 -1.97888 ##   2:     31.849960:  1.43157 0.566368 -1.48426 -1.11793 ##   3:     29.255774:  1.22062  1.42236 -1.18700 -1.48456 ##   4:     2.6332703:  1.21162  1.06391 -0.839196 -1.50616 ##   5:    -28.360004:  1.69842 0.789400 0.678990 -2.68208 ##   6:    -31.783751:  1.72217 0.792252 0.505927 -2.70162 ##   7:    -32.935798:  1.82814 0.794076 0.369331 -2.66980 ##   8:    -34.998129:  2.13584 0.801094 0.363805 -2.49993 ##   9:    -38.060272:  2.43616  1.03138 0.233817 -2.31788 ##  10:    -38.611349:  2.53386  1.03053 0.151828 -2.34627 ##  11:    -38.948305:  2.62609  1.06853 0.198821 -2.27616 ##  12:    -39.203049:  2.73311  1.05589 0.129693 -2.30229 ##  13:    -39.275690:  2.73805  1.08259 0.162430 -2.29016 ##  14:    -39.308929:  2.76701  1.06735 0.191922 -2.29410 ##  15:    -39.341994:  2.80593  1.07554 0.193617 -2.31337 ##  16:    -39.346463:  2.79920  1.07739 0.200505 -2.32628 ##  17:    -39.346636:  2.80270  1.07746 0.202366 -2.32687 ##  18:    -39.346636:  2.80285  1.07748 0.202480 -2.32692 ##  19:    -39.346636:  2.80285  1.07748 0.202482 -2.32692 ##   Optimization finished!: ##             Elapsed time: 0.029 seconds. ##             The objective value is: -3.934664e+01 ##             The maximum gradient component is: 1.3e-04 ##             The convergence message is: relative convergence (4) ##             Iterations: 19 ##             Evaluations: Fun: 27 Grad: 20 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished! nll = TMB::MakeADFun(...) opt = stats::nlminb(start=nll$par, objective=nll$fn, grad=nll$gr, hessian=nll$he)"},{"path":"/articles/constructNegLogLike.html","id":"extract-function-handlers","dir":"Articles","previous_headings":"","what":"Extract function handlers","title":"Extracting likelihood function, gradient and using custom optimizers","text":"constructNegLogLike method allows retrieve nll object holds negative log-likelihood, derivatives. method takes arguments similar estimate. initial parameters (supplied user) stored objective function can evaluted gradient can evaluted hessian can evaluted can now use optimize function using e.g. stats::optim instead.","code":"nll = obj$constructNegLogLike(.data) ## Building model... ## Compiling model... ## Checking data... ## Constructing objective function... ## ...took: 0.039 seconds. ## Succesfully returned function handlers nll$par ##   logtheta         mu logsigma_x logsigma_y  ##   1.609438   0.000000  -2.302585  -2.302585 nll$fn(nll$par) ## [1] 921.7703 nll$gr(nll$par) ##          [,1]      [,2]      [,3]      [,4] ## [1,] 1382.854 -1557.574 -1191.374 -820.9253 nll$he(nll$par) ##           [,1]       [,2]       [,3]       [,4] ## [1,]  2226.705 -2859.2069 -1636.0560 -1136.3013 ## [2,] -2859.207  1663.1457  2251.5926   865.5807 ## [3,] -1636.056  2251.5926   905.1284  1486.3607 ## [4,] -1136.301   865.5807  1486.3607   346.7711"},{"path":"/articles/constructNegLogLike.html","id":"extract-parameter-lowerupper-bounds","dir":"Articles","previous_headings":"","what":"Extract parameter lower/upper bounds","title":"Extracting likelihood function, gradient and using custom optimizers","text":"can extract parameter bounds specified calling setParameter() method using getParameters method (note nll$par pars$initial identical).","code":"pars = obj$getParameters() print(pars) ##            type   estimate   initial     lower     upper ## logtheta   free  2.8028461  1.609438      -Inf  2.995732 ## mu         free  1.0774793  0.000000 -10.00000 10.000000 ## logsigma_x free  0.2024819 -2.302585 -11.51293  1.609438 ## logsigma_y free -2.3269231 -2.302585 -11.51293  1.609438"},{"path":"/articles/constructNegLogLike.html","id":"optimize-manually-using-statsoptim","dir":"Articles","previous_headings":"","what":"Optimize manually using stats::optim","title":"Extracting likelihood function, gradient and using custom optimizers","text":"supply initial parameter values, objective function handler gradient handler, parameter bounds optim.","code":"opt = stats::optim(par=nll$par,                     fn=nll$fn,                     gr=nll$gr,                     method=\"L-BFGS-B\",                     lower=pars$lower,                     upper=pars$upper)"},{"path":"/articles/constructNegLogLike.html","id":"compare-results-between-the-two-optimizers","dir":"Articles","previous_headings":"","what":"Compare results between the two optimizers","title":"Extracting likelihood function, gradient and using custom optimizers","text":"Lets compare results using stats::optim extracted function handler versus internal optimisation uses stats::nlminb stored fit:","code":"# Estimated parameters data.frame(external=opt$par, internal=fit$par.fixed) ##              external   internal ## logtheta    2.8028428  2.8028461 ## mu          1.0774788  1.0774793 ## logsigma_x  0.2024796  0.2024819 ## logsigma_y -2.3269222 -2.3269231 # Neg. Log-Likelihood data.frame(external=opt$value, internal=fit$nll) ##    external  internal ## 1 -39.34664 -39.34664 # Gradient components data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed))) ##        external      internal ## 1 -5.284383e-05 -2.269770e-06 ## 2 -1.491876e-04 -1.337658e-04 ## 3 -4.592109e-05  2.628658e-05 ## 4 -2.656532e-05 -2.239568e-06"},{"path":"/articles/construct_nll.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"Extracting likelihood function, gradient and using custom optimizers","text":"use common Ornstein-Uhlenbeck process showcase use constructNegLogLike. \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/construct_nll.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Extracting likelihood function, gradient and using custom optimizers","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/construct_nll.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"Extracting likelihood function, gradient and using custom optimizers","text":"principle ready call estimate method run optimization scheme using built-optimization uses stats::nlminb .e. Inside package optimise objective function respect fixed parameters using construction function handlers TMB::MakeADFun parsing stats::nlminb .e.","code":"fit = obj$estimate(.data) ## Building model... ## Compiling model... ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.042 seconds. ## Minimizing the negative log-likelihood... ##   0:     921.77031:  1.60944  0.00000 -2.30259 -2.30259 ##   1:     86.857795:  1.06416 0.614170 -1.83281 -1.97888 ##   2:     31.849960:  1.43157 0.566368 -1.48426 -1.11793 ##   3:     29.255774:  1.22062  1.42236 -1.18700 -1.48456 ##   4:     2.6332703:  1.21162  1.06391 -0.839196 -1.50616 ##   5:    -28.360004:  1.69842 0.789400 0.678990 -2.68208 ##   6:    -31.783751:  1.72217 0.792252 0.505927 -2.70162 ##   7:    -32.935798:  1.82814 0.794076 0.369331 -2.66980 ##   8:    -34.998129:  2.13584 0.801094 0.363805 -2.49993 ##   9:    -38.060272:  2.43616  1.03138 0.233817 -2.31788 ##  10:    -38.611349:  2.53386  1.03053 0.151828 -2.34627 ##  11:    -38.948305:  2.62609  1.06853 0.198821 -2.27616 ##  12:    -39.203049:  2.73311  1.05589 0.129693 -2.30229 ##  13:    -39.275690:  2.73805  1.08259 0.162430 -2.29016 ##  14:    -39.308929:  2.76701  1.06735 0.191922 -2.29410 ##  15:    -39.341994:  2.80593  1.07554 0.193617 -2.31337 ##  16:    -39.346463:  2.79920  1.07739 0.200505 -2.32628 ##  17:    -39.346636:  2.80270  1.07746 0.202366 -2.32687 ##  18:    -39.346636:  2.80285  1.07748 0.202480 -2.32692 ##  19:    -39.346636:  2.80285  1.07748 0.202482 -2.32692 ##   Optimization finished!: ##             Elapsed time: 0.028 seconds. ##             The objective value is: -3.934664e+01 ##             The maximum gradient component is: 1.3e-04 ##             The convergence message is: relative convergence (4) ##             Iterations: 19 ##             Evaluations: Fun: 27 Grad: 20 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished! nll = TMB::MakeADFun(...) opt = stats::nlminb(start=nll$par, objective=nll$fn, grad=nll$gr, hessian=nll$he)"},{"path":"/articles/construct_nll.html","id":"extract-function-handlers","dir":"Articles","previous_headings":"","what":"Extract function handlers","title":"Extracting likelihood function, gradient and using custom optimizers","text":"constructNegLogLike method allows retrieve nll object holds negative log-likelihood, derivatives. method takes arguments similar estimate. initial parameters (supplied user) stored objective function can evaluted gradient can evaluted hessian can evaluted can now use optimize function using e.g. stats::optim instead.","code":"nll = obj$constructNegLogLike(.data) ## Building model... ## Compiling model... ## Checking data... ## Constructing objective function... ## ...took: 0.04 seconds. ## Succesfully returned function handlers nll$par ##   logtheta         mu logsigma_x logsigma_y  ##   1.609438   0.000000  -2.302585  -2.302585 nll$fn(nll$par) ## [1] 921.7703 nll$gr(nll$par) ##          [,1]      [,2]      [,3]      [,4] ## [1,] 1382.854 -1557.574 -1191.374 -820.9253 nll$he(nll$par) ##           [,1]       [,2]       [,3]       [,4] ## [1,]  2226.705 -2859.2069 -1636.0560 -1136.3013 ## [2,] -2859.207  1663.1457  2251.5926   865.5807 ## [3,] -1636.056  2251.5926   905.1284  1486.3607 ## [4,] -1136.301   865.5807  1486.3607   346.7711"},{"path":"/articles/construct_nll.html","id":"extract-parameter-lowerupper-bounds","dir":"Articles","previous_headings":"","what":"Extract parameter lower/upper bounds","title":"Extracting likelihood function, gradient and using custom optimizers","text":"can extract parameter bounds specified calling setParameter() method using getParameters method (note nll$par pars$initial identical).","code":"pars = obj$getParameters() print(pars) ##            type   estimate   initial     lower     upper ## logtheta   free  2.8028461  1.609438      -Inf  2.995732 ## mu         free  1.0774793  0.000000 -10.00000 10.000000 ## logsigma_x free  0.2024819 -2.302585 -11.51293  1.609438 ## logsigma_y free -2.3269231 -2.302585 -11.51293  1.609438"},{"path":"/articles/construct_nll.html","id":"optimize-manually-using-statsoptim","dir":"Articles","previous_headings":"","what":"Optimize manually using stats::optim","title":"Extracting likelihood function, gradient and using custom optimizers","text":"supply initial parameter values, objective function handler gradient handler, parameter bounds optim.","code":"opt = stats::optim(par=nll$par,                     fn=nll$fn,                     gr=nll$gr,                     method=\"L-BFGS-B\",                     lower=pars$lower,                     upper=pars$upper)"},{"path":"/articles/construct_nll.html","id":"compare-results-between-the-two-optimizers","dir":"Articles","previous_headings":"","what":"Compare results between the two optimizers","title":"Extracting likelihood function, gradient and using custom optimizers","text":"Lets compare results using stats::optim extracted function handler versus internal optimisation uses stats::nlminb stored fit:","code":"# Estimated parameters data.frame(external=opt$par, internal=fit$par.fixed) ##              external   internal ## logtheta    2.8028428  2.8028461 ## mu          1.0774788  1.0774793 ## logsigma_x  0.2024796  0.2024819 ## logsigma_y -2.3269222 -2.3269231 # Neg. Log-Likelihood data.frame(external=opt$value, internal=fit$nll) ##    external  internal ## 1 -39.34664 -39.34664 # Gradient components data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed))) ##        external      internal ## 1 -5.284383e-05 -2.269770e-06 ## 2 -1.491876e-04 -1.337658e-04 ## 3 -4.592109e-05  2.628658e-05 ## 4 -2.656532e-05 -2.239568e-06"},{"path":"/articles/ctsmTMB.html","id":"initialising","dir":"Articles","previous_headings":"","what":"Initialising","title":"Getting started","text":"initialise ctsmTMB model object using can print object see kind model contains see model called sde_model (default), states, diffusions, observations, inputs parameters currently registered. name used name C++ file created locally, later recognize compiled model object.","code":"library(ctsmTMB) obj = ctsmTMB$new() print(obj) ## Stochastic State Space Model:                           ## Name         ctsmTMB_model ## States                   0 ## Diffusions               0 ## Observations             0 ## Inputs                   0 ## Parameters               0"},{"path":"/articles/ctsmTMB.html","id":"add-system-equations","dir":"Articles","previous_headings":"","what":"Add system equations","title":"Getting started","text":"can begin adding desired stochastic differential equation object. note drift term ends *dt diffusions specified dw dw# # can sequence numbers.","code":"obj$addSystem(dX ~ theta * (mu - X) * dt + sigma_x * dw)"},{"path":"/articles/ctsmTMB.html","id":"add-observation-equations","dir":"Articles","previous_headings":"","what":"Add observation equations","title":"Getting started","text":"must also add observation equation. observations associated Y data also named Y.","code":"obj$addObs(Y ~ X)"},{"path":"/articles/ctsmTMB.html","id":"add-observation-variances","dir":"Articles","previous_headings":"","what":"Add observation variances","title":"Getting started","text":"every observation variable must also specify variance normally distributed residuals observation equation variable name left-hand side formula must match name previously defined via add_observations, variance associated observation equation. Let’s inspect model object now specified one state \\(X\\) observation \\(Y\\). diffusions count number \\(\\mathrm{d}\\omega_{}\\) terms. single equation can multiple diffusion terms .e. sigma_1 * dw1 + sigma_2*dw2). also note inputs parameter specified yet.","code":"obj$setVariance(Y ~ sigma_y^2*U) print(obj) ## Stochastic State Space Model:                           ## Name         ctsmTMB_model ## States                   1 ## Diffusions               1 ## Observations             1 ## Inputs                   0 ## Parameters               0 ##  ## System Equations: ##  ##   dX ~ theta * (mu - X) * dt + sigma_x * dw  ##  ## Observation Equations: ##  ##   Y:  Y ~ X + e   e ~ N(0, sigma_y^2 * U)"},{"path":"/articles/ctsmTMB.html","id":"add-inputs","dir":"Articles","previous_headings":"","what":"Add inputs","title":"Getting started","text":"tell model variable names inputs via input values provided data, name, similar observations.","code":"obj$addInput(U)"},{"path":"/articles/ctsmTMB.html","id":"add-parameters","dir":"Articles","previous_headings":"","what":"Add parameters","title":"Getting started","text":"must also specify (fixed effects) parameters, together initial value lower/upper bound, optimization. can fix parameter value (parameter becomes constant) supplying just single value. usually difficult identify noise parameters \\(\\left(\\sigma_{X},\\sigma_{Y}\\right)\\) practice, lets assume want fix \\(\\sigma_{Y}\\). done via Let’s inspect model object , see inputs parameters (non-fixed fixed) registered.","code":"obj$setParameter(   theta   = c(initial = 5,    lower = 0,    upper = 20),   mu      = c(initial = 0,    lower = -10,  upper = 10),   sigma_x = c(initial = 1e-1, lower = 1e-5, upper = 5),   sigma_y = c(initial = 1e-1, lower = 1e-5, upper = 5) ) obj$setParameter(   sigma_y  = 1e-1 ) print(obj) ## Stochastic State Space Model:                           ## Name         ctsmTMB_model ## States                   1 ## Diffusions               1 ## Observations             1 ## Inputs                   1 ## Parameters               4 ##  ## System Equations: ##  ##   dX ~ theta * (mu - X) * dt + sigma_x * dw  ##  ## Observation Equations: ##  ##   Y:  Y ~ X + e   e ~ N(0, sigma_y^2 * U)  ##  ##  ## Fixed Parameters: ##   sigma_y"},{"path":"/articles/ctsmTMB.html","id":"set-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set initial state and covariance","title":"Getting started","text":"last thing can perform estimation set initial value state(s) associated (co)variance. two inputs adequate since assume normally distributed state. choice value reflect ones belief initial state, often ballpark figure. Note use diag construct 1x1 matrix covariance, required method.","code":"obj$setInitialState(list(mean=3, cov=1e-1*diag(1)))"},{"path":"/articles/ctsmTMB.html","id":"fit-model-parameters-to-data","dir":"Articles","previous_headings":"","what":"Fit model parameters to data","title":"Getting started","text":"now ready perform state filtration parameter estimation. first construct fake data simulating paths Ornstein-Uhlenbeck process using Euler-Maruyama scheme. data must contain time column named t columns specified inputs observations. pass data estimate method. method build compile generated C++ function negative log-likelihood, check supplied data contains necessary variables, construct objective function (computational tree must build automatic differentiation) start optimization. output generated optimization objective (negativ log-likelihood) value parameter values current step. optimizer used package stats::nlminb. optimizer great robustness ability use objective function hessian unlike e.g. ‘stats::optim’","code":"# Choosing parameters set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1   # Creating simulation path dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations from simulation and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data.frame data = data.frame(   t = t.obs,   Y = y,   U = c(rep(c(1,2),times=round(length(y)/2)),1) ) fit = obj$estimate(data) ## Building model... ## Compiling model... ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.048 seconds. ## Minimizing the negative log-likelihood... ##   0:     823.96514:  5.00000  0.00000 0.100000 ##   1:    -23.631306:  4.97573 0.143302  1.08938 ##   2:    -27.304674:  4.92116 0.635388  1.01957 ##   3:    -28.159625:  5.39399 0.797586  1.00873 ##   4:    -28.595330:  7.35194  1.20550  1.00142 ##   5:    -30.261929:  7.00584 0.966687  1.02771 ##   6:    -31.541810:  8.06439 0.949977  1.05900 ##   7:    -34.410489:  12.1976  1.03521  1.15875 ##   8:    -34.983141:  14.7762  1.09189  1.22006 ##   9:    -35.073719:  15.9169  1.05173  1.25649 ##  10:    -35.106105:  15.9356  1.07264  1.25375 ##  11:    -35.106680:  15.9721  1.07247  1.25451 ##  12:    -35.109686:  16.1150  1.07195  1.25645 ##  13:    -35.114592:  16.2646  1.07149  1.25647 ##  14:    -35.126076:  16.4874  1.07103  1.25146 ##  15:    -35.141346:  16.6208  1.07113  1.23793 ##  16:    -35.153357:  16.5245  1.07182  1.21997 ##  17:    -35.156849:  16.3305  1.07228  1.21163 ##  18:    -35.157137:  16.2622  1.07243  1.21149 ##  19:    -35.157143:  16.2571  1.07244  1.21183 ##  20:    -35.157143:  16.2572  1.07244  1.21186 ##  21:    -35.157143:  16.2572  1.07244  1.21186 ##   Optimization finished!: ##             Elapsed time: 0.028 seconds. ##             The objective value is: -3.515714e+01 ##             The maximum gradient component is: 2.9e-06 ##             The convergence message is: relative convergence (4) ##             Iterations: 21 ##             Evaluations: Fun: 23 Grad: 22 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished!"},{"path":"/articles/ctsmTMB.html","id":"important-note-for-model-changes","dir":"Articles","previous_headings":"","what":"Important Note for Model Changes","title":"Getting started","text":"change model later stage retain model name, need recompile C++ objective function. can like : receive error messages calling estimate regarding variables specified model, likely forgot recompile.","code":"obj$estimate(data, compile=TRUE)"},{"path":"/articles/ctsmTMB.html","id":"parameter-estimates","dir":"Articles","previous_headings":"","what":"Parameter estimates","title":"Getting started","text":"Let’s inspect results estimation. can print fit object see standard coefficient matrix parameter estimates. can see parameter estimate associated standard error together t-test statistic P-value associated standard null-hypothesis \\[ H_{0}: p = 0 \\\\ H_{1}: p \\neq 0 \\] Note true parameter values set simulation step \\(\\theta = 10\\), \\(\\mu=1\\) \\(\\sigma_{X} = 1\\). parameter values, standard deviations covariance matrix can extracted via: estimated (fixed) parameters: standard deviations (fixed) parameters: covariance (fixed) parameters:","code":"print(fit) ## Coefficent Matrix  ##          Estimate Std. Error t value  Pr(>|t|)     ## theta   16.257194   3.481811  4.6692 9.329e-06 *** ## mu       1.072440   0.079191 13.5425 < 2.2e-16 *** ## sigma_x  1.211858   0.158279  7.6565 1.178e-11 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 fit$par.fixed ##     theta        mu   sigma_x  ## 16.257194  1.072440  1.211858 fit$sd.fixed ##      theta         mu    sigma_x  ## 3.48181119 0.07919093 0.15827877 fit$cov.fixed ##               theta          mu     sigma_x ## theta   12.12300915 0.078844171 0.176665520 ## mu       0.07884417 0.006271203 0.001125772 ## sigma_x  0.17666552 0.001125772 0.025052169"},{"path":"/articles/ctsmTMB.html","id":"state-estimates","dir":"Articles","previous_headings":"","what":"State estimates","title":"Getting started","text":"can also plot prior posterior state estimates prior state estimate resulting estimate purely integrating mean covariance SDE system forward time, posterior state estimation obtained updating prior estimate information contained observation (using Bayes’ rule).","code":"library(ggplot2) library(patchwork) # ggplot2 theme mytheme =   theme_minimal() +    theme(     text             = element_text(\"Avenir Next Condensed\",size=15),     legend.text      = element_text(size=15),     axis.text        = element_text(size=15),     strip.text       = element_text(face=\"bold\",size=15),     panel.grid.major = element_blank(),     panel.grid.minor = element_blank(),     legend.box       = \"vertical\",     legend.position  = \"top\",     plot.title       = element_text(hjust=0.5)   ) t         = fit$states$mean$posterior$t xprior    = fit$states$mean$prior$X xpost     = fit$states$mean$posterior$X xpost_sd  = fit$states$sd$posterior$X  ggplot() +   geom_line(aes(x=t,y=xpost,color=\"State Estimates (Posterior)\"),lwd=1) +   geom_line(aes(x=t,y=xprior,color=\"State Estimates (Prior)\"),lwd=1) +   geom_ribbon(aes(x=t,ymin=xpost-2*xpost_sd,ymax=xpost+2*xpost_sd),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$Y,color=\"Observations\")) +   guides(color=guide_legend(override.aes=list(shape=c(16,NA,NA),size=c(2,NA,NA),linetype=c(NA,1,1),lwd=c(NA,1,1)))) +   labs(x = \"Time\", y = \"\", color=\"\") +   mytheme"},{"path":"/articles/ctsmTMB.html","id":"residual-analysis","dir":"Articles","previous_headings":"","what":"Residual analysis","title":"Getting started","text":"can display standard residual analysis observations calling plot fit object, invokes S3 plot.ctsmTMB.fit method plot. includes quantile-quantile plot, histogram, auto-correlations cumulative periodogram. residuals (standard normalized) can extracted well, together standard deviation covariance matrix via fit$residuals","code":"plot(fit)"},{"path":"/articles/ctsmTMB.html","id":"extra-adding-algebraic-equations","dir":"Articles","previous_headings":"","what":"Extra: Adding algebraic equations","title":"Getting started","text":"sake clarity can sometimes easier specify simple variables equations place (perhaps larger) expression. can redefine variable name providing algebraic relation. Let’s say wish consider positive values parameter \\(\\theta\\), appropriate estimate log-domain (since domain logarithm positive real axis). use \\(\\theta = \\exp\\left(\\log\\theta\\right)\\) introduce parameter logtheta replace theta. obviously just names, might well written exp(theta) directly specifying system equations, calling parameter logtheta reminds one really interested exponential parameter. specify algebraic relation like : parameter settings theta automatically transformed logtheta, must redefined:","code":"obj$setAlgebraics(theta ~ exp(logtheta)) obj$setParameter(logtheta = log(c(initial=5, lower=0, upper=20)))"},{"path":"/articles/estimate.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"estimate: Estimating model parameters and states","text":"now construct ctsmTMB model object per usual","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/estimate.html","id":"using-estimate---default-settings","dir":"Articles","previous_headings":"","what":"Using estimate - default settings","title":"estimate: Estimating model parameters and states","text":"can run estimate directly default settings using default settings Let’s walk various arguments effect:","code":"obj$estimate(.data) obj$estimate(data = .data,               method = \"ekf\",              ode.solver = \"rk4\",              ode.timestep = diff(data$t),              loss = \"quadratic\",              loss_c = 3,              unscented_hyperpars = list(alpha=1, beta=0, kappa=3-private$number.of.states),              control = list(trace=1,iter.max=1e5,eval.max=1e5),              use.hessian = FALSE,              laplace.residuals = FALSE,              unconstrained.optim = FALSE,              compile = FALSE,              silent = FALSE)"},{"path":"/articles/estimate.html","id":"argument-method","dir":"Articles","previous_headings":"","what":"Argument: method","title":"estimate: Estimating model parameters and states","text":"method argument determines underlying estimation techniques used. current implementation supports following method='ekf': Extended Kalman Filter. method='ukf': Unscented Kalman Filter - currently disabled. method='laplace': Laplace Approximation former two quite similar based Kalman Filter theory. assumptions normality state transition observation equation fundamental, although implemented filters standard non-linear filters, sense try overcome assumptions small non-linearities. Unscented Kalman Filter generally considered perform better cases. latter laplace method employs Laplace Approximation method integration random effects. formulation consider states random effects, parameters fixed. underlying assumption one normality, implementation allows flexibility choosing arbitrary distributions (yet implemented.) methods can used estimate parameter states. case laplace states smoothed (conditioned past future observations).","code":""},{"path":"/articles/estimate.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"","what":"Argument: ode.solver","title":"estimate: Estimating model parameters and states","text":"argument used Kalman Filter methods .e. ekf ukf. argument determines algorithm used integrate forward moment (mean variance) differential equations. current implementation supports ode.solver='euler': forward Euler scheme ode.solver='rk4': 4th order Runge-Kutta scheme","code":""},{"path":"/articles/estimate.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"","what":"Argument: ode.timestep","title":"estimate: Estimating model parameters and states","text":"argument determines time-step used ODE solvers","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/articles/negative_log_likelihood.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"Extracting likelihood function, gradient and using custom optimizers","text":"use common Ornstein-Uhlenbeck process showcase use constructNegLogLike. \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/negative_log_likelihood.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Extracting likelihood function, gradient and using custom optimizers","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/negative_log_likelihood.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"Extracting likelihood function, gradient and using custom optimizers","text":"principle ready call estimate method run optimization scheme using built-optimization uses stats::nlminb .e. Inside package optimise objective function respect fixed parameters using construction function handlers TMB::MakeADFun parsing stats::nlminb .e.","code":"fit = obj$estimate(.data) ## Building model... ## Compiling model... ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.049 seconds. ## Minimizing the negative log-likelihood... ##   0:     921.77031:  1.60944  0.00000 -2.30259 -2.30259 ##   1:     86.857795:  1.06416 0.614170 -1.83281 -1.97888 ##   2:     31.849960:  1.43157 0.566368 -1.48426 -1.11793 ##   3:     29.255774:  1.22062  1.42236 -1.18700 -1.48456 ##   4:     2.6332703:  1.21162  1.06391 -0.839196 -1.50616 ##   5:    -28.360004:  1.69842 0.789400 0.678990 -2.68208 ##   6:    -31.783751:  1.72217 0.792252 0.505927 -2.70162 ##   7:    -32.935798:  1.82814 0.794076 0.369331 -2.66980 ##   8:    -34.998129:  2.13584 0.801094 0.363805 -2.49993 ##   9:    -38.060272:  2.43616  1.03138 0.233817 -2.31788 ##  10:    -38.611349:  2.53386  1.03053 0.151828 -2.34627 ##  11:    -38.948305:  2.62609  1.06853 0.198821 -2.27616 ##  12:    -39.203049:  2.73311  1.05589 0.129693 -2.30229 ##  13:    -39.275690:  2.73805  1.08259 0.162430 -2.29016 ##  14:    -39.308929:  2.76701  1.06735 0.191922 -2.29410 ##  15:    -39.341994:  2.80593  1.07554 0.193617 -2.31337 ##  16:    -39.346463:  2.79920  1.07739 0.200505 -2.32628 ##  17:    -39.346636:  2.80270  1.07746 0.202366 -2.32687 ##  18:    -39.346636:  2.80285  1.07748 0.202480 -2.32692 ##  19:    -39.346636:  2.80285  1.07748 0.202482 -2.32692 ##   Optimization finished!: ##             Elapsed time: 0.028 seconds. ##             The objective value is: -3.934664e+01 ##             The maximum gradient component is: 1.3e-04 ##             The convergence message is: relative convergence (4) ##             Iterations: 19 ##             Evaluations: Fun: 27 Grad: 20 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished! nll = TMB::MakeADFun(...) opt = stats::nlminb(start=nll$par, objective=nll$fn, grad=nll$gr, hessian=nll$he)"},{"path":"/articles/negative_log_likelihood.html","id":"extract-function-handlers","dir":"Articles","previous_headings":"","what":"Extract function handlers","title":"Extracting likelihood function, gradient and using custom optimizers","text":"constructNegLogLike method allows retrieve nll object holds negative log-likelihood, derivatives. method takes arguments similar estimate. initial parameters (supplied user) stored objective function can evaluted gradient can evaluted hessian can evaluted can now use optimize function using e.g. stats::optim instead.","code":"nll = obj$constructNegLogLike(.data) ## Building model... ## Compiling model... ## Checking data... ## Constructing objective function... ## ...took: 0.039 seconds. ## Succesfully returned function handlers nll$par ##   logtheta         mu logsigma_x logsigma_y  ##   1.609438   0.000000  -2.302585  -2.302585 nll$fn(nll$par) ## [1] 921.7703 nll$gr(nll$par) ##          [,1]      [,2]      [,3]      [,4] ## [1,] 1382.854 -1557.574 -1191.374 -820.9253 nll$he(nll$par) ##           [,1]       [,2]       [,3]       [,4] ## [1,]  2226.705 -2859.2069 -1636.0560 -1136.3013 ## [2,] -2859.207  1663.1457  2251.5926   865.5807 ## [3,] -1636.056  2251.5926   905.1284  1486.3607 ## [4,] -1136.301   865.5807  1486.3607   346.7711"},{"path":"/articles/negative_log_likelihood.html","id":"extract-parameter-lowerupper-bounds","dir":"Articles","previous_headings":"","what":"Extract parameter lower/upper bounds","title":"Extracting likelihood function, gradient and using custom optimizers","text":"can extract parameter bounds specified calling setParameter() method using getParameters method (note nll$par pars$initial identical).","code":"pars = obj$getParameters() print(pars) ##            type   estimate   initial     lower     upper ## logtheta   free  2.8028461  1.609438      -Inf  2.995732 ## mu         free  1.0774793  0.000000 -10.00000 10.000000 ## logsigma_x free  0.2024819 -2.302585 -11.51293  1.609438 ## logsigma_y free -2.3269231 -2.302585 -11.51293  1.609438"},{"path":"/articles/negative_log_likelihood.html","id":"optimize-manually-using-statsoptim","dir":"Articles","previous_headings":"","what":"Optimize manually using stats::optim","title":"Extracting likelihood function, gradient and using custom optimizers","text":"supply initial parameter values, objective function handler gradient handler, parameter bounds optim.","code":"opt = stats::optim(par=nll$par,                     fn=nll$fn,                     gr=nll$gr,                     method=\"L-BFGS-B\",                     lower=pars$lower,                     upper=pars$upper)"},{"path":"/articles/negative_log_likelihood.html","id":"compare-results-between-the-two-optimizers","dir":"Articles","previous_headings":"","what":"Compare results between the two optimizers","title":"Extracting likelihood function, gradient and using custom optimizers","text":"Lets compare results using stats::optim extracted function handler versus internal optimisation uses stats::nlminb stored fit:","code":"# Estimated parameters data.frame(external=opt$par, internal=fit$par.fixed) ##              external   internal ## logtheta    2.8028428  2.8028461 ## mu          1.0774788  1.0774793 ## logsigma_x  0.2024796  0.2024819 ## logsigma_y -2.3269222 -2.3269231 # Neg. Log-Likelihood data.frame(external=opt$value, internal=fit$nll) ##    external  internal ## 1 -39.34664 -39.34664 # Gradient components data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed))) ##        external      internal ## 1 -5.284383e-05 -2.269770e-06 ## 2 -1.491876e-04 -1.337658e-04 ## 3 -4.592109e-05  2.628658e-05 ## 4 -2.656532e-05 -2.239568e-06"},{"path":"/articles/observation_equations.html","id":"adding-observation-equations","dir":"Articles","previous_headings":"","what":"Adding observation equations","title":"observations: Using functions on the left-hand side","text":"Let’s assume observations \\(y_{t}\\) log-normally distributed conditioned \\(x_{t}\\) .e. \\[ \\log y_{t_{}} \\sim \\mathcal{N}(x_{t_{}},\\sigma_{y}^{2}) \\] sufficient user provide data column y provided data.frame e.g. estimate predict adding following observation equation Note kind observation equations, left-hand side function one () observed variables must explicitly named using obsnames argument.","code":"obj$addObs(   log(y) ~ x, obsnames = \"log_y\" )"},{"path":"/articles/observation_equations.html","id":"adding-observation-variances","dir":"Articles","previous_headings":"","what":"Adding observation variances","title":"observations: Using functions on the left-hand side","text":"names given obsnames important needed specify observation variance. example code work, observation named log_y correct way add observation variance :","code":"obj$setVariance(   y ~ sigma_y^2 ) ## Error in check_observation_variance_eqs(form, self, private): Please add an observation equation for y before specifying its variance obj$setVariance(   log_y ~ sigma_y^2 )"},{"path":"/articles/observation_equations.html","id":"multiple-observation-equations","dir":"Articles","previous_headings":"","what":"Multiple observation equations","title":"observations: Using functions on the left-hand side","text":"must supply multiple obsnames supplying multiple observatin equations, although name used left-hand side just single variable .e.","code":"obj$addObs(   log(y) ~ x,   y ~ x,   y^2+z^3 ~ x,   obsnames = c(\"log_y\", NA, \"y2_plus_z3\") )"},{"path":"/articles/predict.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"predict: Forecasting the model states and observations.","text":"use Ornstein-Uhlenbeck process . \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/predict.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"predict: Forecasting the model states and observations.","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/predict.html","id":"predict","dir":"Articles","previous_headings":"","what":"Predict","title":"predict: Forecasting the model states and observations.","text":"can use predict function without called estimate first, case initial value parameters provided add_parameters used. output predict list two data.frames, one states one observations. two data.frames share five initial columns contain indices j, associated time-points t.t.j, k.ahead contain indices, time-points associated k-step ahead , state/observation values associated standard deviations, observations provided data, predicted observation values based predicted state values. indices . j. table refer expectation variance state vector \\[ \\mathrm{E}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\\\ \\mathrm{V}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\] moments given indices \\(\\) (time \\(t_{}\\)) conditioned information available indices \\(j\\) (time \\(t_{j}\\)). sense state/covariance predictions \\(=j\\) posterior estimates, others prior estimates. default standard deviations states returned. entire covariance matrix elements can returned via","code":"pred = obj$predict(.data) head(pred$states) ##   i. j.  t.i  t.j k.ahead        x       var.x ## 1  0  0 0.00 0.00       0 3.000000 0.100000000 ## 2  0  1 0.00 0.01       1 2.853688 0.090578913 ## 3  1  1 0.01 0.01       0 2.704116 0.009005756 ## 4  1  2 0.01 0.02       1 2.572235 0.008243908 ## 5  2  2 0.02 0.02       0 2.600410 0.004518718 ## 6  2  3 0.02 0.03       1 2.473587 0.004183868 head(pred$observations) ##     i. j.  t.i  t.j k.ahead        y   y.data ## 1    0  0 0.00 0.00       0 3.000000 3.105001 ## 2    0  1 0.00 0.01       1 2.853688 2.687603 ## 2.1  1  1 0.01 0.01       0 2.704116 2.687603 ## 3    1  2 0.01 0.02       1 2.572235 2.634588 ## 3.1  2  2 0.02 0.02       0 2.600410 2.634588 ## 4    2  3 0.02 0.03       1 2.473587 2.267096 obj$predict(.data, return.covariance = TRUE)"},{"path":"/articles/predict.html","id":"set-number-of-prediction-steps","dir":"Articles","previous_headings":"","what":"Set number of prediction steps","title":"predict: Forecasting the model states and observations.","text":"number time steps ahead predictions desired can changed k.ahead argument. default behaviour save prediction steps 1 k.ahead selected desired, return.k.ahead argument can used indicate kept output.","code":"pred1 = obj$predict(.data, k.ahead=2) pred2 = obj$predict(.data, k.ahead=10, return.k.ahead=c(2,5,8)) head(pred1$states) ##   i. j.  t.i  t.j k.ahead        x       var.x ## 1  0  0 0.00 0.00       0 3.000000 0.100000000 ## 2  0  1 0.00 0.01       1 2.853688 0.090578913 ## 3  0  2 0.00 0.02       2 2.714512 0.082054359 ## 4  1  1 0.01 0.01       0 2.704116 0.009005756 ## 5  1  2 0.01 0.02       1 2.572235 0.008243908 ## 6  1  3 0.01 0.03       2 2.446786 0.007554560 head(pred2$states) ##    i. j.  t.i  t.j k.ahead        x       var.x ## 3   0  2 0.00 0.02       2 2.714512 0.082054359 ## 6   0  5 0.00 0.05       5 2.336402 0.061046563 ## 9   0  8 0.00 0.08       8 2.010960 0.045483600 ## 14  1  3 0.01 0.03       2 2.446786 0.007554560 ## 17  1  6 0.01 0.06       5 2.105968 0.005855739 ## 20  1  9 0.01 0.09       8 1.812623 0.004597221"},{"path":"/articles/predict.html","id":"set-the-model-parameters-used","dir":"Articles","previous_headings":"","what":"Set the model parameters used","title":"predict: Forecasting the model states and observations.","text":"default predict use initial parameters supplied setParameter, unless estimate function succesfully run, predict use parameter values found minimizer. can provide parameters using pars argument method .e.","code":"some.other.random.pars = rnorm(length(fit$par.fixed)) pred = obj$predict(.data, pars=some.other.random.pars)"},{"path":"/articles/predict.html","id":"set-the-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set the initial state and covariance","title":"predict: Forecasting the model states and observations.","text":"default behaviour predict use initial state covariance suppled calling set_initial_state method. can important change one wishes correctly predict first observations provided prediction data series. can supply x0 p0 arguments updated state covariance estimates","code":"new.initial.x0 = rnorm(1) new.initial.p0 = rnorm(1)*diag(1) pred = obj$predict(data=.data,                    initial.state = list(                      new.state.value,                      new.covariance.value                    ) )"},{"path":"/articles/predict.html","id":"the-solver-options","dir":"Articles","previous_headings":"","what":"The solver options","title":"predict: Forecasting the model states and observations.","text":"can choose solver options use via arguments ode.solver ode.timestep. ode.solver decides ode solver algorithm used solving mean variance ODEs SDE. ode.timestep determines time step-size using solving ODEs, default value minimum observed time difference provided data time vector (min(diff(.data$t))). time step-size can’t smaller . chosen time step-size \\(\\Delta_{step}\\) “almost” divide observation time differences data \\(\\Delta_{obs}\\) .e. \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} - \\bigg\\lfloor \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rfloor \\geq 0.02 \\] time step-size reduced divide evenly setting \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} = \\bigg\\lceil \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rceil \\] words: takes \\(3.561\\) time-steps get \\(t_{}\\) \\(t_{+1}\\) take \\(4\\) time-steps instead, calculate reduced time-step true. \\(3.01\\) time-steps retain original time-step, ignoring small temporal discrepancy. provide arguments via","code":"obj$predict(.data,             ode.timestep = min(diff(.data$t)) )"},{"path":"/articles/predict.html","id":"use-case","dir":"Articles","previous_headings":"","what":"Use-case","title":"predict: Forecasting the model states and observations.","text":"use model predictions observation compute model performance score e.g. RMSE (root-mean square error). first estimate model parameters, automatically used calling predict. predict 10-steps ahead, return values. Let’s plot 10-step predictions observations. notice 10-step predictions state uncertainty (95%) much larger filtered posterior state estimates fit .e. can calculate RMSE prediction score prediction step follows:","code":"fit = obj$estimate(.data) pred = obj$predict(.data, k.ahead=10) pred.states = pred$states pred.obs = pred$observations # ggplot2 theme library(ggplot2) mytheme =   theme_minimal() +    theme(     text             = element_text(\"Avenir Next Condensed\",size=15),     legend.text      = element_text(size=15),     axis.text        = element_text(size=15),     strip.text       = element_text(face=\"bold\",size=15),     legend.box       = \"vertical\",     legend.position  = \"top\",     plot.title       = element_text(hjust=0.5)   ) pred10 = pred.states[pred.states$k.ahead==10,] data = .data ggplot() +   geom_line(aes(x=pred10$t.j,y=pred10$x,color=\"10-Step Predictions\")) +     geom_ribbon(aes(x=pred10$t.j,ymin=pred10$x-2*sqrt(pred10$var.x),ymax=pred10$x+2*sqrt(pred10$var.x)),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(color=\"\",x=\"Time\",y=\"\") +   # coord_cartesian(xlim=c(0,0.1)) +   mytheme t         = fit$states$mean$posterior$t xpost     = fit$states$mean$posterior$x xpost_sd  = fit$states$sd$posterior$x  ggplot() +   geom_line(aes(x=t,y=xpost,color=\"0-Step Predictions (Posterior State Estimates)\"),lwd=1) +   geom_ribbon(aes(x=t,ymin=xpost-2*xpost_sd,ymax=xpost+2*xpost_sd),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(x = \"Time\", y = \"\", color=\"\") +   mytheme rmse = c() k.ahead = 1:10 for(i in k.ahead){   xy = data.frame(     x = pred.states[pred.states$k.ahead==i,\"x\"],     y = pred.obs[pred.obs$k.ahead==i,\"y.data\"]   )   rmse[i] = sqrt(mean((xy[[\"x\"]] - xy[[\"y\"]])^2)) }  ggplot() +   geom_line(aes(k.ahead, rmse), color=\"steelblue\") +    geom_point(aes(k.ahead, rmse), color=\"red\") +   labs(     title = \"Root-Mean Square Errors for Different Prediction Horizons\",     x = \"Prediction Steps\",     y = \"Root-Mean-Square Errors\"     ) +   mytheme"},{"path":"/articles/simulate.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"predict: Forecasting the model states and observations.","text":"use Ornstein-Uhlenbeck process . \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/simulate.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"predict: Forecasting the model states and observations.","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/simulate.html","id":"predict","dir":"Articles","previous_headings":"","what":"Predict","title":"predict: Forecasting the model states and observations.","text":"can use predict function without called estimate first, case initial value parameters provided add_parameters used. output predict list two data.frames, one states one observations. two data.frames share five initial columns contain indices j, associated time-points t.t.j, k.ahead contain indices, time-points associated k-step ahead , state/observation values associated standard deviations, observations provided data, predicted observation values based predicted state values. indices . j. table refer expectation variance state vector \\[ \\mathrm{E}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\\\ \\mathrm{V}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\] moments given indices \\(\\) (time \\(t_{}\\)) conditioned information available indices \\(j\\) (time \\(t_{j}\\)). sense state/covariance predictions \\(=j\\) posterior estimates, others prior estimates. default standard deviations states returned. entire covariance matrix elements can returned via","code":"pred = obj$predict(.data) head(pred$states) ##   i. j.  t.i  t.j k.ahead        x       var.x ## 1  0  0 0.00 0.00       0 3.000000 0.100000000 ## 2  0  1 0.00 0.01       1 2.853688 0.090578913 ## 3  1  1 0.01 0.01       0 2.704116 0.009005756 ## 4  1  2 0.01 0.02       1 2.572235 0.008243908 ## 5  2  2 0.02 0.02       0 2.600410 0.004518718 ## 6  2  3 0.02 0.03       1 2.473587 0.004183868 head(pred$observations) ##     i. j.  t.i  t.j k.ahead        y   y.data ## 1    0  0 0.00 0.00       0 3.000000 3.105001 ## 2    0  1 0.00 0.01       1 2.853688 2.687603 ## 2.1  1  1 0.01 0.01       0 2.704116 2.687603 ## 3    1  2 0.01 0.02       1 2.572235 2.634588 ## 3.1  2  2 0.02 0.02       0 2.600410 2.634588 ## 4    2  3 0.02 0.03       1 2.473587 2.267096 obj$predict(.data, return.covariance = TRUE)"},{"path":"/articles/simulate.html","id":"set-number-of-prediction-steps","dir":"Articles","previous_headings":"","what":"Set number of prediction steps","title":"predict: Forecasting the model states and observations.","text":"number time steps ahead predictions desired can changed k.ahead argument. default behaviour save prediction steps 1 k.ahead selected desired, return.k.ahead argument can used indicate kept output.","code":"pred1 = obj$predict(.data, k.ahead=2) pred2 = obj$predict(.data, k.ahead=10, return.k.ahead=c(2,5,8)) head(pred1$states) ##   i. j.  t.i  t.j k.ahead        x       var.x ## 1  0  0 0.00 0.00       0 3.000000 0.100000000 ## 2  0  1 0.00 0.01       1 2.853688 0.090578913 ## 3  0  2 0.00 0.02       2 2.714512 0.082054359 ## 4  1  1 0.01 0.01       0 2.704116 0.009005756 ## 5  1  2 0.01 0.02       1 2.572235 0.008243908 ## 6  1  3 0.01 0.03       2 2.446786 0.007554560 head(pred2$states) ##    i. j.  t.i  t.j k.ahead        x       var.x ## 3   0  2 0.00 0.02       2 2.714512 0.082054359 ## 6   0  5 0.00 0.05       5 2.336402 0.061046563 ## 9   0  8 0.00 0.08       8 2.010960 0.045483600 ## 14  1  3 0.01 0.03       2 2.446786 0.007554560 ## 17  1  6 0.01 0.06       5 2.105968 0.005855739 ## 20  1  9 0.01 0.09       8 1.812623 0.004597221"},{"path":"/articles/simulate.html","id":"set-the-model-parameters-used","dir":"Articles","previous_headings":"","what":"Set the model parameters used","title":"predict: Forecasting the model states and observations.","text":"default predict use initial parameters supplied setParameter, unless estimate function succesfully run, predict use parameter values found minimizer. can provide parameters using pars argument method .e.","code":"some.other.random.pars = rnorm(length(fit$par.fixed)) pred = obj$predict(.data, pars=some.other.random.pars)"},{"path":"/articles/simulate.html","id":"set-the-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set the initial state and covariance","title":"predict: Forecasting the model states and observations.","text":"default behaviour predict use initial state covariance suppled calling set_initial_state method. can important change one wishes correctly predict first observations provided prediction data series. can supply x0 p0 arguments updated state covariance estimates","code":"new.initial.x0 = rnorm(1) new.initial.p0 = rnorm(1)*diag(1) pred = obj$predict(data=.data,                    initial.state = list(                      new.state.value,                      new.covariance.value                    ) )"},{"path":"/articles/simulate.html","id":"the-solver-options","dir":"Articles","previous_headings":"","what":"The solver options","title":"predict: Forecasting the model states and observations.","text":"can choose solver options use via arguments ode.solver ode.timestep. ode.solver decides ode solver algorithm used solving mean variance ODEs SDE. ode.timestep determines time step-size using solving ODEs, default value minimum observed time difference provided data time vector (min(diff(.data$t))). time step-size can’t smaller . chosen time step-size \\(\\Delta_{step}\\) “almost” divide observation time differences data \\(\\Delta_{obs}\\) .e. \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} - \\bigg\\lfloor \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rfloor \\geq 0.02 \\] time step-size reduced divide evenly setting \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} = \\bigg\\lceil \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rceil \\] words: takes \\(3.561\\) time-steps get \\(t_{}\\) \\(t_{+1}\\) take \\(4\\) time-steps instead, calculate reduced time-step true. \\(3.01\\) time-steps retain original time-step, ignoring small temporal discrepancy. provide arguments via","code":"obj$predict(.data,             ode.timestep = min(diff(.data$t)) )"},{"path":"/articles/simulate.html","id":"use-case","dir":"Articles","previous_headings":"","what":"Use-case","title":"predict: Forecasting the model states and observations.","text":"use model predictions observation compute model performance score e.g. RMSE (root-mean square error). first estimate model parameters, automatically used calling predict. predict 10-steps ahead, return values. Let’s plot 10-step predictions observations. notice 10-step predictions state uncertainty (95%) much larger filtered posterior state estimates fit .e. can calculate RMSE prediction score prediction step follows:","code":"fit = obj$estimate(.data) pred = obj$predict(.data, k.ahead=10) pred.states = pred$states pred.obs = pred$observations # ggplot2 theme library(ggplot2) mytheme =   theme_minimal() +    theme(     text             = element_text(\"Avenir Next Condensed\",size=15),     legend.text      = element_text(size=15),     axis.text        = element_text(size=15),     strip.text       = element_text(face=\"bold\",size=15),     legend.box       = \"vertical\",     legend.position  = \"top\",     plot.title       = element_text(hjust=0.5)   ) pred10 = pred.states[pred.states$k.ahead==10,] data = .data ggplot() +   geom_line(aes(x=pred10$t.j,y=pred10$x,color=\"10-Step Predictions\")) +     geom_ribbon(aes(x=pred10$t.j,ymin=pred10$x-2*sqrt(pred10$var.x),ymax=pred10$x+2*sqrt(pred10$var.x)),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(color=\"\",x=\"Time\",y=\"\") +   # coord_cartesian(xlim=c(0,0.1)) +   mytheme t         = fit$states$mean$posterior$t xpost     = fit$states$mean$posterior$x xpost_sd  = fit$states$sd$posterior$x  ggplot() +   geom_line(aes(x=t,y=xpost,color=\"0-Step Predictions (Posterior State Estimates)\"),lwd=1) +   geom_ribbon(aes(x=t,ymin=xpost-2*xpost_sd,ymax=xpost+2*xpost_sd),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(x = \"Time\", y = \"\", color=\"\") +   mytheme rmse = c() k.ahead = 1:10 for(i in k.ahead){   xy = data.frame(     x = pred.states[pred.states$k.ahead==i,\"x\"],     y = pred.obs[pred.obs$k.ahead==i,\"y.data\"]   )   rmse[i] = sqrt(mean((xy[[\"x\"]] - xy[[\"y\"]])^2)) }  ggplot() +   geom_line(aes(k.ahead, rmse), color=\"steelblue\") +    geom_point(aes(k.ahead, rmse), color=\"red\") +   labs(     title = \"Root-Mean Square Errors for Different Prediction Horizons\",     x = \"Prediction Steps\",     y = \"Root-Mean-Square Errors\"     ) +   mytheme"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Phillip Vetter. Author, maintainer. Jan Møller. Contributor. Uffe Thygesen. Contributor. Peder Bacher. Contributor. Henrik Madsen. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vetter PB, Møller JK, Thygesen U, Bacher P, Madsen H (2024). ctsmTMB: Continuous Time Stochastic Modelling using Template Model Builder. R Package Version 1.0, https://github.com/phillipbvetter/ctsmTMB.","code":"@Manual{,   title = {ctsmTMB: Continuous Time Stochastic Modelling using Template Model Builder},   author = {Phillip Brinck Vetter and Jan K. Møller and Uffe Thygesen and Peder Bacher and Henrik Madsen},   year = {2024},   note = {R Package Version 1.0},   url = {https://github.com/phillipbvetter/ctsmTMB}, }"},{"path":"/index.html","id":"continuous-time-stochastic-modelling-using-template-model-builder-ctsmtmb","dir":"","previous_headings":"","what":"Continuous Time Stochastic Modelling using Template Model Builder","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"ctsmTMB R package parameter estimation, state filtration forecasting stochastic state space models, intended successor , heavily inspired , Continuous Time Stochastic Modelling. package essentially wrapper Template Model Builder automatically constructs necessary (negative log) likelihood function behind scenes, based user-specified stochastic state space model model. model specified using implemented ctsmTMB class (based R6 package) associated methods e.g. addSystem, addObs, setVariance. model states parameters may estimated estimate method employs nlminb quasi-Newton optimizer due D. Gay stats package. package alsp provides predict simulate methods integrating moment equations forward time, stochastic euler-maruyama simulations, respectively. implementation methods based Rcpp package universe, particular importance computational speed use RcppXPtrUtils package. facilities creating sending C++ pointers model-specific functions (drift, diffusion, observation associated jacobians) speed-sending R functions.","code":""},{"path":"/index.html","id":"estimation-methods","dir":"","previous_headings":"","what":"Estimation Methods","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"following state reconstruction algorithms currently available: (Continous-Discrete) Extended Kalman Filter, ekf (based ). (Continous-Discrete) Unscented Kalman Filter, ukf (based S. Särkkä, 2007) (Continuous-Discrete) Laplace Approximation laplace.","code":""},{"path":"/index.html","id":"laplace-filter","dir":"","previous_headings":"Estimation Methods","what":"Laplace Filter","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"state-reconstructions based laplace method smoothed estimates, meaning state values optimizes simultaneously, given available observations (past, present future). (see e.g. example) laplace method employs Laplace Approximation natively built-completely handled TMB, noteworthy features method : C++ compilation needed. addition AD-compile time (call TMB::MakeADFun) identical similar compiled C++ code. possibility non-Gaussian (modal) observation densities accommodate need e.g. heavier distribution tails. method produces smoothed state estimates, states integrated simultaneously, conditioned past future information / observation.","code":""},{"path":"/index.html","id":"kalman-filters","dir":"","previous_headings":"Estimation Methods","what":"Kalman Filters","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"ekf ukf Kalman Filters … main advantage Kalman Filter implementations large increase computation speed, access fixed effects hessian improved convergence optimization. cases TMB just provides automatic differentiation. package currently mostly tailored towards Kalman Filter, available methods predict simulate k-step-ahead predictions simulations. also S3 method implementation plot called ctsmTMB.fit class object returned estimate method, plots basic residuals analysis using ggplot2 package.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can install package copying command R. note ctsmTMB depends following packages: 1. TMB 2. Rcpp 3. RcppEigen 4. RcppXPtrUtils 5. RcppZiggurat 6. R6 7. Deriv 8. stringr user must therefore working C++ compiler. particular windows users install Rtools, Mac users install Command Line Tools get working C++ compilers. must make sure added PATH vislble R. information see TMB GitHub associated installation instructions Linux users need make sure GSL installed RcppZiggurat necessary simulate method. can try following command, google .","code":"remotes::install_github(repo=\"phillipbvetter/ctsmTMB\", dependencies=TRUE) sudo apt-get install libgsl-dev"},{"path":"/index.html","id":"how-to-get-started","dir":"","previous_headings":"","what":"How to get started","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can visit package webpage browse vignettes example uses, particular see Getting Started.","code":""},{"path":"/index.html","id":"help","dir":"","previous_headings":"","what":"Help","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can access documentation available methods individually (subset methods) using .e. ?ctsmTMB::addSystem. methods documentation also available homepage.","code":"?ctsmTMB"},{"path":"/index.html","id":"example-usage","dir":"","previous_headings":"","what":"Example Usage","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"","code":"library(ggplot2) library(patchwork) library(dplyr) library(reshape2) library(ctsmTMB)  ############################################################ # Data simulation ############################################################  # Simulate data using Euler Maruyama set.seed(20) pars = c(theta=10, mu=1, sigma_x=1, sigma_y=0.1) #  dt.sim = 1e-3 t.sim = seq(0,5,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) u.sim = cumsum(rnorm(length(t.sim),sd=0.05)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + pars[1]*(pars[2]-x[i]+u.sim[i])*dt.sim + pars[3]*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 ids = seq(1,length(t.sim),by=round(dt.obs / dt.sim)) t.obs = t.sim[ids] y = x[ids] + pars[4] * rnorm(length(t.obs)) # forcing input u = u.sim[ids]  # Create data .data = data.frame(   t = t.obs,   y = y,   u = u )  ############################################################ # Model creation and estimation ############################################################  # Create model object model = ctsmTMB$new()  # Set name of model (and the created .cpp file) model$setModelname(\"ornstein_uhlenbeck\")  # Add system equations model$addSystem(   dx ~ theta * (mu-x+u) * dt + sigma_x*dw )  # Add observation equations model$addObs(   y ~ x )  # Set observation equation variances model$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations model$setAlgebraics(   theta   ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Add vector input model$addInput(u)  # Specify parameter initial values and lower/upper bounds in estimation model$setParameter(   logtheta    = log(c(initial = 1, lower=1e-5, upper=50)),   mu          = c(initial=1.5, lower=0, upper=5),   logsigma_x  = log(c(initial=1, lower=1e-10, upper=30)),   logsigma_y  = log(c(initial=1e-1, lower=1e-10, upper=30)) )  # Set initial state mean and covariance model$setInitialState(list(x[1], 1e-1*diag(1)))  # Carry out estimation with default settings (extended kalman filter) fit <- model$estimate(data=.data, method=\"ekf\")  # Check parameter estimates against truth p0 = fit$par.fixed cbind(c(exp(p0[1]),p0[2],exp(p0[3]),exp(p0[4])), pars)  # Create plot of one-step predictions, simulated states and observations t.est = fit$states$mean$prior$t x.mean = fit$states$mean$prior$x x.sd = fit$states$sd$prior$x plot1 = ggplot() +   geom_ribbon(aes(x=t.est, ymin=x.mean-2*x.sd, ymax=x.mean+2*x.sd),fill=\"grey\", alpha=0.9) +   geom_line(aes(x=t.est, x.mean),col=\"steelblue\",lwd=1) +   geom_line(aes(x=t.sim,y=x)) +    geom_point(aes(x=t.obs,y=y),col=\"tomato\",size=1) +   labs(title=\"1-Step State Estimates vs Observations\", x=\"Time\", y=\"\") +   theme_minimal()  # Predict to obtain k-step-ahead predictions to see model forecasting ability pred.list = model$predict(data=.data,                          k.ahead=10,                          method=\"ekf\", )  # Create plot all 10-step predictions against data pred = pred.list$states pred10step = pred %>% dplyr::filter(k.ahead==10) plot2 = ggplot() +   geom_ribbon(aes(x=pred10step$t.j,                    ymin=pred10step$x-2*sqrt(pred10step$var.x),                   ymax=pred10step$x+2*sqrt(pred10step$var.x)),fill=\"grey\", alpha=0.9) +   geom_line(aes(x=pred10step$t.j,pred10step$x),color=\"steelblue\",lwd=1) +   geom_point(aes(x=t.obs,y=y),color=\"tomato\",size=1) +   labs(title=\"10 Step Predictions vs Observations\", x=\"Time\", y=\"\") +   theme_minimal()  # Perform full prediction without data update pred.list = model$predict(data=.data,                          k.ahead=1e6,                          method=\"ekf\", )  # Perform full simulation without data update sim.list = model$simulate(data=.data,                          k.ahead=1e6,                          method=\"ekf\" )  # Collapse simulation data for easy use with ggplot  sim.df = sim.list$states$x$i0 %>%   select(!c(\"i\",\"j\",\"t.i\",\"k.ahead\")) %>%   reshape2::melt(., id.var=\"t.j\")  # Plot all full simulations and the full prediction against observations # (full means no data-update at all) plot3 = ggplot() +   geom_line(data=sim.df, aes(x=t.j, y=value, group=variable),color=\"grey\") +   geom_line(aes(x=pred.list$states$t.j,y=pred.list$states$x),color=\"steelblue\") +   geom_point(aes(x=t.obs,y=y),color=\"tomato\",size=1) +   labs(title=\"No Update Prediction and Simulations vs Observations\", x=\"Time\", y=\"\") +   theme_minimal() + theme(legend.position = \"none\")  # Draw both plots patchwork::wrap_plots(plot1, plot2, plot3, ncol=1)  # Plot one-step-ahead residual analysis using the command below # plot(fit)"},{"path":"/reference/addInput.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify input variables in the model object. — addInput","title":"Specify input variables in the model object. — addInput","text":"Declare whether variable contained system, observation observation variance equations input variable.","code":""},{"path":"/reference/addInput.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify input variables in the model object. — addInput","text":"","code":"addInput(...)"},{"path":"/reference/addInput.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify input variables in the model object. — addInput","text":"... series variable names (unquouted) match variable names defined system treated input variables.","code":""},{"path":"/reference/addInput.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify input variables in the model object. — addInput","text":"","code":"# Example 1 addInput(u) #> Error in addInput(u): could not find function \"addInput\"  # Example 2 addInput(u1, u2, u3) #> Error in addInput(u1, u2, u3): could not find function \"addInput\""},{"path":"/reference/addObs.html","id":null,"dir":"Reference","previous_headings":"","what":"Add observation equations to model object — addObs","title":"Add observation equations to model object — addObs","text":"Add observation equation ctsmTMB model-object links states observed variable.","code":""},{"path":"/reference/addObs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add observation equations to model object — addObs","text":"","code":"addObs(form,                  ...,                  obsnames=NULL)"},{"path":"/reference/addObs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add observation equations to model object — addObs","text":"form formula specifying observation equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list. obsnames character vector specifying observation names used observation left-hand side function call. See details.","code":""},{"path":[]},{"path":"/reference/addObs.html","id":"obsnames","dir":"Reference","previous_headings":"","what":"obsnames","title":"Add observation equations to model object — addObs","text":"obsnames argument used left-hand side form function variable .e. log(y) (class 'call' instead 'name'), Example 3. user provide data y, log-transformation handled internally. supported functions discussed addSystem.","code":""},{"path":[]},{"path":"/reference/addSystem.html","id":null,"dir":"Reference","previous_headings":"","what":"Add state equations to model object — addSystem","title":"Add state equations to model object — addSystem","text":"Add stochastic differential equation ctsmTMB model-object governs differential evolution states specified model.","code":""},{"path":"/reference/addSystem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add state equations to model object — addSystem","text":"","code":"addSystem(form,             ...)"},{"path":"/reference/addSystem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add state equations to model object — addSystem","text":"form formula specifying stochastic differential equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":[]},{"path":"/reference/addSystem.html","id":"usable-functions","dir":"Reference","previous_headings":"","what":"Usable functions","title":"Add state equations to model object — addSystem","text":"formulas can contain elementary functions log, exp, logit invlogit. general supported functions 1) defined derivative table Deriv package, 2) undestood TMB C++ side.","code":""},{"path":"/reference/addSystem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add state equations to model object — addSystem","text":"","code":"# Example 1 - Linear System addSystem(dx ~ theta * (mu - x + u) * dt + sigma * dw) #> Error in addSystem(dx ~ theta * (mu - x + u) * dt + sigma * dw): could not find function \"addSystem\"  # Example 2 - Non-Linear System addSystem(dx ~ theta * (mu - exp(x)^2 + u) * dt + sigma * x * (1-x) * dw) #> Error in addSystem(dx ~ theta * (mu - exp(x)^2 + u) * dt + sigma * x *     (1 - x) * dw): could not find function \"addSystem\""},{"path":"/reference/add_algebraics.html","id":null,"dir":"Reference","previous_headings":"","what":"Add algebraic relationships to the model object. — add_algebraics","title":"Add algebraic relationships to the model object. — add_algebraics","text":"Algebraic relations convenient way transform parameters equations, reduce clutter specying various equations, instance ensure positivity (log-transform).","code":""},{"path":"/reference/add_algebraics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add algebraic relationships to the model object. — add_algebraics","text":"","code":"add_algebraics(form,                ...)"},{"path":"/reference/add_algebraics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add algebraic relationships to the model object. — add_algebraics","text":"form formula specifying algebraic relation. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":"/reference/add_algebraics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add algebraic relationships to the model object. — add_algebraics","text":"left-hand side provided formula specifies parameter overwritten expression right-hand side. also means left-hand side parameter vanish model formulation link{add_parameters} therefore specify values new parameters.","code":""},{"path":"/reference/add_algebraics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add algebraic relationships to the model object. — add_algebraics","text":"","code":"# Example 1 add_algebraics( sigma ~ exp(logsigma), theta ~ invlogit(alpha + beta) ) #> Error in add_algebraics(sigma ~ exp(logsigma), theta ~ invlogit(alpha +     beta)): could not find function \"add_algebraics\""},{"path":"/reference/add_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify input variables in the model object. — add_inputs","title":"Specify input variables in the model object. — add_inputs","text":"Declare whether variable contained system, observation observation variance equations input variable.","code":""},{"path":"/reference/add_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify input variables in the model object. — add_inputs","text":"","code":"add_inputs(...)"},{"path":"/reference/add_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify input variables in the model object. — add_inputs","text":"... series variable names (unquouted) match variable names defined system treated input variables.","code":""},{"path":"/reference/add_inputs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify input variables in the model object. — add_inputs","text":"","code":"# Example 1 add_inputs(u) #> Error in add_inputs(u): could not find function \"add_inputs\"  # Example 2 add_inputs(u1, u2, u3) #> Error in add_inputs(u1, u2, u3): could not find function \"add_inputs\""},{"path":"/reference/add_observation_variances.html","id":null,"dir":"Reference","previous_headings":"","what":"Add observation variances to the model object. — add_observation_variances","title":"Add observation variances to the model object. — add_observation_variances","text":"Specify observation variance existing observation equation.","code":""},{"path":"/reference/add_observation_variances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add observation variances to the model object. — add_observation_variances","text":"","code":"add_observation_variances(form,                           ...)"},{"path":"/reference/add_observation_variances.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add observation variances to the model object. — add_observation_variances","text":"form formula class specifying obsevation equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":[]},{"path":"/reference/add_observations.html","id":null,"dir":"Reference","previous_headings":"","what":"Add observation equations to model object — add_observations","title":"Add observation equations to model object — add_observations","text":"Add observation equation ctsmTMB model-object links states observed variable.","code":""},{"path":"/reference/add_observations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add observation equations to model object — add_observations","text":"","code":"add_observations(form,                  ...,                  obsnames=NULL)"},{"path":"/reference/add_observations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add observation equations to model object — add_observations","text":"form formula specifying observation equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list. obsnames character vector specifying observation names used observation left-hand side function call. See details.","code":""},{"path":[]},{"path":"/reference/add_observations.html","id":"obsnames","dir":"Reference","previous_headings":"","what":"obsnames","title":"Add observation equations to model object — add_observations","text":"obsnames argument used left-hand side form function variable .e. log(y) (class 'call' instead 'name'), Example 3. user provide data y, log-transformation handled internally. supported functions discussed add_systems.","code":""},{"path":[]},{"path":"/reference/add_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify parameters in the model object — add_parameters","title":"Specify parameters in the model object — add_parameters","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer values, well lower / upper bounds. Parameters can declared either vectors matrices. first entry initial value, second entry lower bound third entry upper bound. Providing first entry fixes particular parameter value.","code":""},{"path":"/reference/add_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify parameters in the model object — add_parameters","text":"","code":"add_parameters(...)"},{"path":"/reference/add_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify parameters in the model object — add_parameters","text":"... comma-seperated series vectors/matrix entries","code":""},{"path":[]},{"path":"/reference/add_systems.html","id":null,"dir":"Reference","previous_headings":"","what":"Add state equations to model object — add_systems","title":"Add state equations to model object — add_systems","text":"Add stochastic differential equation ctsmTMB model-object governs differential evolution states specified model.","code":""},{"path":"/reference/add_systems.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add state equations to model object — add_systems","text":"","code":"add_systems(form,             ...)"},{"path":"/reference/add_systems.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add state equations to model object — add_systems","text":"form formula specifying stochastic differential equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":[]},{"path":"/reference/add_systems.html","id":"usable-functions","dir":"Reference","previous_headings":"","what":"Usable functions","title":"Add state equations to model object — add_systems","text":"formulas can contain elementary functions log, exp, logit invlogit. general supported functions 1) defined derivative table Deriv package, 2) undestood TMB C++ side.","code":""},{"path":"/reference/add_systems.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add state equations to model object — add_systems","text":"","code":"# Example 1 - Linear System add_systems(dx ~ theta * (mu - x + u) * dt + sigma * dw) #> Error in add_systems(dx ~ theta * (mu - x + u) * dt + sigma * dw): could not find function \"add_systems\"  # Example 2 - Non-Linear System add_systems(dx ~ theta * (mu - exp(x)^2 + u) * dt + sigma * x * (1-x) * dw) #> Error in add_systems(dx ~ theta * (mu - exp(x)^2 + u) * dt + sigma * x *     (1 - x) * dw): could not find function \"add_systems\""},{"path":"/reference/create_return_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_prediction","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_prediction","text":"Generates user-friendly data.frame prediction results private$prediction","code":""},{"path":"/reference/create_return_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_prediction","text":"","code":"create_return_prediction(return.covariance, return.k.ahead, self, private)"},{"path":"/reference/create_return_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_prediction","text":"self model object private model object private fields","code":""},{"path":"/reference/create_return_simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_simulation","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_simulation","text":"Generates user-friendly data.frame prediction results private$prediction","code":""},{"path":"/reference/create_return_simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_simulation","text":"","code":"create_return_simulation(return.k.ahead, n.sims, self, private)"},{"path":"/reference/create_return_simulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_simulation","text":"self model object private model object private fields","code":""},{"path":"/reference/ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"following public methods used construct stochastic state space model system, consisting set stochastic differential equations (SDEs), one algebraic observation equations (AOEs). AOEs used infer information value (latent) states governed SDEs, thus must functions least one state.","code":""},{"path":"/reference/ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"function returns object class R6 ctsmTMB, can used define stochastic state space system.","code":""},{"path":[]},{"path":"/reference/ctsmTMB.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"ctsmTMB$new() ctsmTMB$addSystem() ctsmTMB$addObs() ctsmTMB$setVariance() ctsmTMB$addInput() ctsmTMB$setParameter() ctsmTMB$setAlgebraics() ctsmTMB$setInitialState() ctsmTMB$setInitialVarianceScaling() ctsmTMB$setLamperti() ctsmTMB$setModelname() ctsmTMB$set_cppfile_directory() ctsmTMB$setMAP() ctsmTMB$getSystems() ctsmTMB$getObservations() ctsmTMB$getVariances() ctsmTMB$getAlgebraics() ctsmTMB$getInitialState() ctsmTMB$getParameters() ctsmTMB$getEstimate() ctsmTMB$getNegLogLike() ctsmTMB$getPrediction() ctsmTMB$getSimulation() ctsmTMB$estimate() ctsmTMB$constructNegLogLike() ctsmTMB$predict() ctsmTMB$simulate() ctsmTMB$print() ctsmTMB$summary() ctsmTMB$plot() ctsmTMB$clone()","code":""},{"path":"/reference/ctsmTMB.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Initialize private fields","code":""},{"path":"/reference/ctsmTMB.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$new()"},{"path":"/reference/ctsmTMB.html","id":"method-addsystem-","dir":"Reference","previous_headings":"","what":"Method addSystem()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Define add multiple stochastic differential equation governing process individual state variables form d<state> ~ f(t,<states>,<inputs>) * dt + g1(t,<states>,<inputs>) * dw1  + g2(t,<states>,<inputs>) * dw2 + ... + gN(t,<states>,<inputs>) * dwN f drift, g1, g2, ..., gN diffusions, differential brownian motions dw1, dw2, ..., dwN.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addSystem(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula specifying stochastic differential equation added system. ... additional formulas similar form specifying multiple equations .","code":""},{"path":"/reference/ctsmTMB.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"# Specify Ornstein-Uhlenbeck Process addSystem(dx ~ theta * (mu - x + u) * dt + sigma * dw)"},{"path":"/reference/ctsmTMB.html","id":"method-addobs-","dir":"Reference","previous_headings":"","what":"Method addObs()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Define add relationship observed variable system states. observation equation takes form <observation> ~ h(t,<states>,<inputs>) + e) h observation function, e normally distributed noise zero mean variance specified. observation variable present data provided calling estimate(.data) parameter estimation.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addObs(form, ..., obsnames = NULL)"},{"path":"/reference/ctsmTMB.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula class specifying obsevation equation added system. ... additional formulas identical form specify multiple observation equations time. obsnames character vector specifying name observation. observation left-hand side consists just single variable name (class 'call' instead 'name') given name form obs__# # number, unless obsnames provided.","code":""},{"path":"/reference/ctsmTMB.html","id":"examples-1","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"#Specify observation directly as a latent state addObs(y ~ x)  Specify observation as the sum of exponentials of two latent states addObs(y ~ exp(x1) + exp(x2))"},{"path":"/reference/ctsmTMB.html","id":"method-setvariance-","dir":"Reference","previous_headings":"","what":"Method setVariance()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Specify variance observation equation. defined observation variable y e.g. addObs(y ~  h(t,<states>,<inputs>) pertubed Gaussian noise zero mean variance -specified using setVariance(y ~ p(t,<states>,<inputs>). can instance declare setVariance(y ~ sigma_x^2 sigma_x fixed effect parameter declared setParameter.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setVariance(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula class specifying obsevation equation added system. ... additional formulas identical form specify multiple observation equations time.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-addinput-","dir":"Reference","previous_headings":"","what":"Method addInput()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare variables data inputs Declare whether variable contained system, observation observation variance equations input variable. e.g. system equation contains input variable u declared using addInput(u). input u must contained data.frame .data provided calling estimate predict methods.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addInput(...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"... variable names specifies name input variables defined system.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setparameter-","dir":"Reference","previous_headings":"","what":"Method setParameter()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer value, well lower / upper bounds optimization. two ways declare parameters: can declare parameters using formulas .e. setParameter(  theta = c(1,0,10), mu = c(0,-10,10) ). first value initial value optimizer, second value lower optimization bound third value upper optimization bound. can provide 3-column matrix rows corresponds different parameters, parameter names provided rownames matrix. columns values corresponds description vector format .","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setParameter(...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"... named vector matrix described .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setalgebraics-","dir":"Reference","previous_headings":"","what":"Method setAlgebraics()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Add algebraic relations. Algebraic relations convenient way transform parameters equations. Ornstein-Uhlenbeck process rate parameter theta always positive, estimation log-domain good idea. Instead writing exp(theta) directly system equation one can transform log domain using algebraic relation setAlgebraics(theta ~ exp(logtheta)). instances theta replaced exp(logtheta) compiling C++ function. Note must provide values logtheta now instead theta declaring parameters setParameter","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setAlgebraics(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula specifying stochastic differential equation(s) added system. ... additional formulas similar form specifying multiple equations .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setinitialstate-","dir":"Reference","previous_headings":"","what":"Method setInitialState()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setInitialState(initial.state, estimate = FALSE)"},{"path":"/reference/ctsmTMB.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate boolean value indicates whether initial conditions shall estimated fixed effects parameters. provided mean covariance used initial guesses","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setinitialvariancescaling-","dir":"Reference","previous_headings":"","what":"Method setInitialVarianceScaling()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"scalar value multiplied onto estimated intiial state covariance matrix. scaling applied initial state/cov estimated, set user.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setInitialVarianceScaling(scaling)"},{"path":"/reference/ctsmTMB.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"scaling numeric scalar value.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setlamperti-","dir":"Reference","previous_headings":"","what":"Method setLamperti()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set Lamperti Transformation provided system equations state dependent diffusion available ways advantageous perform transformation remove state dependence. comes cost complicated drift function. following types state-dependence currently supported 'identity' - diffusion state-independent (default) 'log' - diffusion proportional x * dw 'logit' - diffusion proportional x * (1-x) * dw 'sqrt-logit' - diffusion proportional sqrt(x * (1-x)) * dw","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setLamperti(transforms, states = NULL)"},{"path":"/reference/ctsmTMB.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"transforms character vector - one either \"identity, \"log\", \"logit\", \"sqrt-logit\" states vector state names specified transformations applied .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setmodelname-","dir":"Reference","previous_headings":"","what":"Method setModelname()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set modelname used create C++ file TMB calling TMB::MakeADFun (negative log) likelihood function created directory specified set_cppfile_directory method name <modelname>.cpp","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setModelname(name)"},{"path":"/reference/ctsmTMB.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"name string defining model name.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-set-cppfile-directory-","dir":"Reference","previous_headings":"","what":"Method set_cppfile_directory()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set path directory constructed C++ file created. specify entire path, unless want construct subfolder current working directory - can call e.g. set_cppfile_directory(\"folder_in_current_wd\").","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$set_cppfile_directory(directory)"},{"path":"/reference/ctsmTMB.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"directory string specifying local directory","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setmap-","dir":"Reference","previous_headings":"","what":"Method setMAP()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Enable maximum posterior (MAP) estimation. Adds maximum posterior contribution (negative log) likelihood function evaluating fixed effects parameters multivariate Gaussian mean covariance provided.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setMAP(mean, cov)"},{"path":"/reference/ctsmTMB.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"mean mean vector Gaussian prior parameter distribution cov covariance matrix Gaussian prior parameter distribution","code":""},{"path":"/reference/ctsmTMB.html","id":"method-getsystems-","dir":"Reference","previous_headings":"","what":"Method getSystems()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve system equations.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getSystems()"},{"path":"/reference/ctsmTMB.html","id":"method-getobservations-","dir":"Reference","previous_headings":"","what":"Method getObservations()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve observation equations.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getObservations()"},{"path":"/reference/ctsmTMB.html","id":"method-getvariances-","dir":"Reference","previous_headings":"","what":"Method getVariances()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve observation variances","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getVariances()"},{"path":"/reference/ctsmTMB.html","id":"method-getalgebraics-","dir":"Reference","previous_headings":"","what":"Method getAlgebraics()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve algebraic relations","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getAlgebraics()"},{"path":"/reference/ctsmTMB.html","id":"method-getinitialstate-","dir":"Reference","previous_headings":"","what":"Method getInitialState()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getInitialState()"},{"path":"/reference/ctsmTMB.html","id":"method-getparameters-","dir":"Reference","previous_headings":"","what":"Method getParameters()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Get initial (estimated) parameters.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getParameters(type = \"all\", value = \"all\")"},{"path":"/reference/ctsmTMB.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"type one \"\", free\" \"fixed\" parameters. value one \"\", initial\", \"estimate\", \"lower\" \"upper\"","code":""},{"path":"/reference/ctsmTMB.html","id":"method-getestimate-","dir":"Reference","previous_headings":"","what":"Method getEstimate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getEstimate()"},{"path":"/reference/ctsmTMB.html","id":"method-getnegloglike-","dir":"Reference","previous_headings":"","what":"Method getNegLogLike()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getNegLogLike()"},{"path":"/reference/ctsmTMB.html","id":"method-getprediction-","dir":"Reference","previous_headings":"","what":"Method getPrediction()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getPrediction()"},{"path":"/reference/ctsmTMB.html","id":"method-getsimulation-","dir":"Reference","previous_headings":"","what":"Method getSimulation()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getSimulation()"},{"path":"/reference/ctsmTMB.html","id":"method-estimate-","dir":"Reference","previous_headings":"","what":"Method estimate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Estimate fixed effects parameters specified model.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$estimate(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = 3,   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   control = list(trace = 1, iter.max = 1e+05, eval.max = 1e+05),   use.hessian = FALSE,   laplace.residuals = FALSE,   unconstrained.optim = FALSE,   compile = FALSE,   silent = FALSE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector specifying filtering method used state/likelihood calculations. Must one either \"ekf\", \"ekf_rtmb\", ukf\" \"laplace\". natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residauls natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approxmation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. control list control parameters parsed nlminb control argument. See ?stats::nlminb information use.hessian boolean value. default (TRUE) causes optimization algorithm stats::nlminb use fixed effects hessian (negative log) likelihood performing optimization. feature available kalman filter methods without random effects. laplace.residuals boolean - whether calculate one-step ahead residuls using method oneStepPredict. unconstrained.optim boolean value. TRUE optimization carried unconstrained .e. without parameter bounds specified setParameter. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-constructnegloglike-","dir":"Reference","previous_headings":"","what":"Method constructNegLogLike()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Construct extract function handlers negative log likelihood function. handlers TMB's MakeADFun constructed returned. enables user e.g. choose optimization algorithm, just control optimization workflow.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$constructNegLogLike(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = 3,   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   compile = FALSE,   silent = FALSE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector - one either \"ekf\", \"ukf\" \"tmb\". Sets estimation method. package three available methods implemented: natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep time-step used filtering schemes. time-step two different uses depending chosen method. Kalman Filters: time-step used numerically solving moment differential equations. Laplace Approximation: time-step used Euler-Maruyama simulation scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residauls natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approxmation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-predict-","dir":"Reference","previous_headings":"","what":"Method predict()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$predict(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   initial.state = self$getInitialState(),   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   silent = FALSE,   pars = NULL,   k.ahead = 1,   return.k.ahead = 0:k.ahead,   return.covariance = TRUE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. initial.state named list two entries 'x0' 'p0' containing initial state covariance state unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate function run, default values found optimum. k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. return.covariance booelan value indicate whether covariance (instead correlation) returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-simulate-","dir":"Reference","previous_headings":"","what":"Method simulate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-26","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$simulate(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   simulation.timestep = diff(data$t),   initial.state = self$getInitialState(),   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   silent = FALSE,   pars = NULL,   n.sims = 100,   k.ahead = 1,   return.k.ahead = 0:k.ahead )"},{"path":"/reference/ctsmTMB.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. simulation.timestep timestep used euler-maruyama scheme initial.state named list two entries 'x0' 'p0' containing initial state covariance state unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate function run, default values found optimum. n.sims number simulations k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. return.covariance booelan value indicate whether covariance (instead correlation) returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Function print model object","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-27","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$print()"},{"path":"/reference/ctsmTMB.html","id":"method-summary-","dir":"Reference","previous_headings":"","what":"Method summary()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Summary function fit","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-28","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$summary(correlation = FALSE)"},{"path":"/reference/ctsmTMB.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"correlation boolean value. default (FALSE) provide fixed effects parameter correlation matrix.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-plot-","dir":"Reference","previous_headings":"","what":"Method plot()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Function print model object","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-29","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$plot(plot.obs = 1, ggtheme = getggplot2theme())"},{"path":"/reference/ctsmTMB.html","id":"arguments-18","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. ggtheme ggplot2 theme use creating ggplot. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed","code":""},{"path":"/reference/ctsmTMB.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"objects class cloneable method.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-30","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$clone(deep = FALSE)"},{"path":"/reference/ctsmTMB.html","id":"arguments-19","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"deep Whether make deep clone.","code":""},{"path":[]},{"path":"/reference/execute_ekf_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"export — execute_ekf_prediction","title":"export — execute_ekf_prediction","text":"export","code":""},{"path":"/reference/execute_ekf_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"export — execute_ekf_prediction","text":"","code":"execute_ekf_prediction(   f__R,   g__R,   dfdx__R,   h__R,   dhdx__R,   hvar__R,   obsMat,   inputMat,   parVec,   covMat,   stateVec,   ode_timestep_size,   ode_timesteps,   bool_is_not_na_obsMat,   number_of_available_obs,   n,   m,   last_pred_id,   k_step_ahead,   ode_solver )"},{"path":"/reference/execute_ekf_simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"export — execute_ekf_simulation","title":"export — execute_ekf_simulation","text":"export","code":""},{"path":"/reference/execute_ekf_simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"export — execute_ekf_simulation","text":"","code":"execute_ekf_simulation(   f__R,   g__R,   dfdx__R,   h__R,   dhdx__R,   hvar__R,   obsMat,   inputMat,   parVec,   covMat,   stateVec,   ode_timestep_size,   ode_timesteps,   simulation_timestep_size,   simulation_timesteps,   bool_is_not_na_obsMat,   number_of_available_obs,   n,   m,   ng,   last_pred_id,   k_step_ahead,   ode_solver,   nsims )"},{"path":"/reference/plot.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB.fit","title":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB.fit","text":"Basic summary objects class 'ctsmTMB'","code":""},{"path":"/reference/plot.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit plot(fit, plot.obs = 1, ggtheme = getggplot2theme())"},{"path":"/reference/plot.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB.fit","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. ggtheme ggplot2 theme use creating ggplot. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed","code":""},{"path":"/reference/plot.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB.fit","text":"list plots","code":""},{"path":"/reference/plot.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB","title":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB","text":"Basic summary objects class 'ctsmTMB'","code":""},{"path":"/reference/plot.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB","text":"","code":"# S3 method for ctsmTMB plot(object, plot.obs = 1, ggtheme = getggplot2theme())"},{"path":"/reference/plot.ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. ggtheme ggplot2 theme use creating ggplot. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed","code":""},{"path":"/reference/plot.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmTMB' — plot.ctsmTMB","text":"huge amount information","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmTMB.pred' from predict — plot.ctsmTMB.pred","title":"Basic summary of objects of class 'ctsmTMB.pred' from predict — plot.ctsmTMB.pred","text":"Basic summary objects class 'ctsmTMB.pred' predict","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmTMB.pred' from predict — plot.ctsmTMB.pred","text":"","code":"# S3 method for ctsmTMB.pred plot(pred.data, n.ahead = 0, state.name = NULL, ...)"},{"path":"/reference/plot.ctsmTMB.pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmTMB.pred' from predict — plot.ctsmTMB.pred","text":"huge amount information","code":""},{"path":"/reference/plot.sdeTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB.fit","title":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB.fit","text":"Basic summary objects class 'sdeTMB'","code":""},{"path":"/reference/plot.sdeTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB.fit","text":"","code":"# S3 method for sdeTMB.fit plot(   fit,   plot.obs = 1,   pacf = FALSE,   extended = FALSE,   ggtheme = getggplot2theme() )"},{"path":"/reference/plot.sdeTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB.fit","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed ggtheme ggplot2 theme use creating ggplot.","code":""},{"path":"/reference/plot.sdeTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB.fit","text":"list plots","code":""},{"path":"/reference/plot.sdeTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB","title":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB","text":"Basic summary objects class 'sdeTMB'","code":""},{"path":"/reference/plot.sdeTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB","text":"","code":"# S3 method for sdeTMB plot(   object,   plot.obs = 1,   pacf = FALSE,   extended = FALSE,   ggtheme = getggplot2theme() )"},{"path":"/reference/plot.sdeTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed ggtheme ggplot2 theme use creating ggplot.","code":""},{"path":"/reference/plot.sdeTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'sdeTMB' — plot.sdeTMB","text":"huge amount information","code":""},{"path":"/reference/plot.sdeTMB.pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'sdeTMB.pred' from predict — plot.sdeTMB.pred","title":"Basic summary of objects of class 'sdeTMB.pred' from predict — plot.sdeTMB.pred","text":"Basic summary objects class 'sdeTMB.pred' predict","code":""},{"path":"/reference/plot.sdeTMB.pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'sdeTMB.pred' from predict — plot.sdeTMB.pred","text":"","code":"# S3 method for sdeTMB.pred plot(pred.data, n.ahead = 0, state.name = NULL, ...)"},{"path":"/reference/plot.sdeTMB.pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'sdeTMB.pred' from predict — plot.sdeTMB.pred","text":"huge amount information","code":""},{"path":"/reference/print.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects of class 'ctsmTMB' — print.ctsmTMB.fit","title":"Basic print of objects of class 'ctsmTMB' — print.ctsmTMB.fit","text":"Basic print objects class 'ctsmTMB'","code":""},{"path":"/reference/print.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects of class 'ctsmTMB' — print.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit print(fit)"},{"path":"/reference/print.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects of class 'ctsmTMB' — print.ctsmTMB.fit","text":"huge amount information","code":""},{"path":"/reference/print.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects of class 'ctsmTMB' — print.ctsmTMB","title":"Basic print of objects of class 'ctsmTMB' — print.ctsmTMB","text":"Basic print objects class 'ctsmTMB'","code":""},{"path":"/reference/print.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects of class 'ctsmTMB' — print.ctsmTMB","text":"","code":"# S3 method for ctsmTMB print(object, ...)"},{"path":"/reference/print.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects of class 'ctsmTMB' — print.ctsmTMB","text":"huge amount information","code":""},{"path":"/reference/print.sdeTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects of class 'sdeTMB' — print.sdeTMB.fit","title":"Basic print of objects of class 'sdeTMB' — print.sdeTMB.fit","text":"Basic print objects class 'sdeTMB'","code":""},{"path":"/reference/print.sdeTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects of class 'sdeTMB' — print.sdeTMB.fit","text":"","code":"# S3 method for sdeTMB.fit print(fit)"},{"path":"/reference/print.sdeTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects of class 'sdeTMB' — print.sdeTMB.fit","text":"huge amount information","code":""},{"path":"/reference/print.sdeTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects of class 'sdeTMB' — print.sdeTMB","title":"Basic print of objects of class 'sdeTMB' — print.sdeTMB","text":"Basic print objects class 'sdeTMB'","code":""},{"path":"/reference/print.sdeTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects of class 'sdeTMB' — print.sdeTMB","text":"","code":"# S3 method for sdeTMB print(object, ...)"},{"path":"/reference/print.sdeTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects of class 'sdeTMB' — print.sdeTMB","text":"huge amount information","code":""},{"path":"/reference/profile.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"#' Full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","title":"#' Full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"#' Full multi-dimensional profile likelihood calculations","code":""},{"path":"/reference/profile.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"#' Full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit profile(   fit,   parlist,   grid.size = rep(10, length(parlist)),   grid.qnt = rep(3, length(parlist)),   hessian = FALSE,   trace = 0,   control = list(trace = trace, iter.max = 1000, eval.max = 1000) )"},{"path":"/reference/profile.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"#' Full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"parnames named list parameter values, one vector parameter names profiled. initial values parameters inspired TMB implementation https://github.com/kaskr/adcomp/blob/master/TMB/R/tmbprofile.R","code":""},{"path":"/reference/profile0.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"#' Inner profile likelihood calculation — profile0.ctsmTMB.fit","title":"#' Inner profile likelihood calculation — profile0.ctsmTMB.fit","text":"#' Inner profile likelihood calculation","code":""},{"path":"/reference/profile0.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"#' Inner profile likelihood calculation — profile0.ctsmTMB.fit","text":"","code":"profile0.ctsmTMB.fit(fit, parnames, par.vals = fit$par.fixed)"},{"path":"/reference/profile0.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"#' Inner profile likelihood calculation — profile0.ctsmTMB.fit","text":"parnames vector parameter names profiled. initial values parameters inspired TMB implementation https://github.com/kaskr/adcomp/blob/master/TMB/R/tmbprofile.R","code":""},{"path":"/reference/rcpp_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction function that calls the underlying Rcpp prediction function — rcpp_prediction","title":"Prediction function that calls the underlying Rcpp prediction function — rcpp_prediction","text":"Prediction function calls underlying Rcpp prediction function","code":""},{"path":"/reference/rcpp_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction function that calls the underlying Rcpp prediction function — rcpp_prediction","text":"","code":"rcpp_prediction(self, private)"},{"path":"/reference/rcpp_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction function that calls the underlying Rcpp prediction function — rcpp_prediction","text":"self model object private model object private fields","code":""},{"path":"/reference/rcpp_simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Stochastic Euler-Maruyama simulation function that calls the underlying Rcpp simulation function — rcpp_simulation","title":"Stochastic Euler-Maruyama simulation function that calls the underlying Rcpp simulation function — rcpp_simulation","text":"Stochastic Euler-Maruyama simulation function calls underlying Rcpp simulation function","code":""},{"path":"/reference/rcpp_simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stochastic Euler-Maruyama simulation function that calls the underlying Rcpp simulation function — rcpp_simulation","text":"","code":"rcpp_simulation(self, private, n.sims)"},{"path":"/reference/rcpp_simulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stochastic Euler-Maruyama simulation function that calls the underlying Rcpp simulation function — rcpp_simulation","text":"self model object private model object private fields","code":""},{"path":"/reference/sdeTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for the 'sdeTMB' R6 class — sdeTMB","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"following public methods used construct stochastic state space model system, consisting set stochastic differential equations (SDEs), one algebraic observation equations (AOEs). AOEs used infer information value (latent) states governed SDEs, thus must functions least one state.","code":""},{"path":"/reference/sdeTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"function returns object class R6 sdeTMB, can used define stochastic state space system.","code":""},{"path":[]},{"path":"/reference/sdeTMB.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"sdeTMB$new() sdeTMB$add_systems() sdeTMB$add_observations() sdeTMB$add_observation_variances() sdeTMB$add_inputs() sdeTMB$add_parameters() sdeTMB$add_algebraics() sdeTMB$set_initial_state() sdeTMB$set_lamperti() sdeTMB$set_modelname() sdeTMB$set_cppfile_directory() sdeTMB$set_map() sdeTMB$get_systems() sdeTMB$get_observations() sdeTMB$get_observation_variances() sdeTMB$get_algebraics() sdeTMB$get_initial_state() sdeTMB$get_parameters() sdeTMB$construct_nll() sdeTMB$estimate() sdeTMB$simulate() sdeTMB$predict() sdeTMB$print() sdeTMB$summary() sdeTMB$plot() sdeTMB$clone()","code":""},{"path":"/reference/sdeTMB.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Initialize private fields","code":""},{"path":"/reference/sdeTMB.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$new()"},{"path":"/reference/sdeTMB.html","id":"method-add-systems-","dir":"Reference","previous_headings":"","what":"Method add_systems()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Define add multiple stochastic differential equation governing process individual state variables form d<state> ~ f(t,<states>,<inputs>) * dt + g1(t,<states>,<inputs>) * dw1  + g2(t,<states>,<inputs>) * dw2 + ... + gN(t,<states>,<inputs>) * dwN f drift, g1, g2, ..., gN diffusions, differential brownian motions dw1, dw2, ..., dwN.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$add_systems(form, ...)"},{"path":"/reference/sdeTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"form formula specifying stochastic differential equation added system. ... additional formulas similar form specifying multiple equations .","code":""},{"path":"/reference/sdeTMB.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"# Specify Ornstein-Uhlenbeck Process add_systems(dx ~ theta * (mu - x + u) * dt + sigma * dw)"},{"path":"/reference/sdeTMB.html","id":"method-add-observations-","dir":"Reference","previous_headings":"","what":"Method add_observations()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Define add relationship observed variable system states. observation equation takes form <observation> ~ h(t,<states>,<inputs>) + e) h observation function, e normally distributed noise zero mean variance specified. observation variable present data provided calling estimate(.data) parameter estimation.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$add_observations(form, ..., obsnames = NULL)"},{"path":"/reference/sdeTMB.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"form formula class specifying obsevation equation added system. ... additional formulas identical form specify multiple observation equations time. obsnames character vector specifying name observation. observation left-hand side consists just single variable name (class 'call' instead 'name') given name form obs__# # number, unless obsnames provided.","code":""},{"path":"/reference/sdeTMB.html","id":"examples-1","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"#Specify observation directly as a latent state add_observations(y ~ x)  Specify observation as the sum of exponentials of two latent states add_observations(y ~ exp(x1) + exp(x2))"},{"path":"/reference/sdeTMB.html","id":"method-add-observation-variances-","dir":"Reference","previous_headings":"","what":"Method add_observation_variances()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Specify variance observation equation. defined observation variable y e.g. add_observations(y ~  h(t,<states>,<inputs>) pertubed Gaussian noise zero mean variance -specified using add_observation_variances(y ~ p(t,<states>,<inputs>). can instance declare add_observation_variances(y ~ sigma_x^2 sigma_x fixed effect parameter declared add_parameters.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$add_observation_variances(form, ...)"},{"path":"/reference/sdeTMB.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"form formula class specifying obsevation equation added system. ... additional formulas identical form specify multiple observation equations time.","code":""},{"path":"/reference/sdeTMB.html","id":"method-add-inputs-","dir":"Reference","previous_headings":"","what":"Method add_inputs()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Declare variables data inputs Declare whether variable contained system, observation observation variance equations input variable. e.g. system equation contains input variable u declared using add_inputs(u). input u must contained data.frame .data provided calling estimate predict methods.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$add_inputs(...)"},{"path":"/reference/sdeTMB.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"... variable names specifies name input variables defined system.","code":""},{"path":"/reference/sdeTMB.html","id":"method-add-parameters-","dir":"Reference","previous_headings":"","what":"Method add_parameters()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer value, well lower / upper bounds optimization. two ways declare parameters: can declare parameters using formulas .e. add_parameters(  theta = c(1,0,10), mu = c(0,-10,10) ). first value initial value optimizer, second value lower optimization bound third value upper optimization bound. can provide 3-column matrix rows corresponds different parameters, parameter names provided rownames matrix. columns values corresponds description vector format .","code":""},{"path":"/reference/sdeTMB.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$add_parameters(...)"},{"path":"/reference/sdeTMB.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"... named vector matrix described .","code":""},{"path":"/reference/sdeTMB.html","id":"method-add-algebraics-","dir":"Reference","previous_headings":"","what":"Method add_algebraics()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Add algebraic relations. Algebraic relations convenient way transform parameters equations. Ornstein-Uhlenbeck process rate parameter theta always positive, estimation log-domain good idea. Instead writing exp(theta) directly system equation one can transform log domain using algebraic relation add_algebraics(theta ~ exp(logtheta)). instances theta replaced exp(logtheta) compiling C++ function. Note must provide values logtheta now instead theta declaring parameters add_parameters","code":""},{"path":"/reference/sdeTMB.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$add_algebraics(form, ...)"},{"path":"/reference/sdeTMB.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"form formula specifying stochastic differential equation(s) added system. ... additional formulas similar form specifying multiple equations .","code":""},{"path":"/reference/sdeTMB.html","id":"method-set-initial-state-","dir":"Reference","previous_headings":"","what":"Method set_initial_state()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$set_initial_state(initial.state, estimate = FALSE)"},{"path":"/reference/sdeTMB.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate boolean value indicates whether initial conditions shall estimated fixed effects parameters. provided mean covariance used initial guesses","code":""},{"path":"/reference/sdeTMB.html","id":"method-set-lamperti-","dir":"Reference","previous_headings":"","what":"Method set_lamperti()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Set Lamperti Transformation provided system equations state dependent diffusion available ways advantageous perform transformation remove state dependence. comes cost complicated drift function. following types state-dependence currently supported 'identity' - diffusion state-independent (default) 'log' - diffusion proportional x * dw 'logit' - diffusion proportional x * (1-x) * dw 'sqrt-logit' - diffusion proportional sqrt(x * (1-x)) * dw","code":""},{"path":"/reference/sdeTMB.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$set_lamperti(transforms, states = NULL)"},{"path":"/reference/sdeTMB.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"transforms character vector - one either \"identity, \"log\", \"logit\", \"sqrt-logit\" states vector state names specified transformations applied .","code":""},{"path":"/reference/sdeTMB.html","id":"method-set-modelname-","dir":"Reference","previous_headings":"","what":"Method set_modelname()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Set modelname used create C++ file TMB calling TMB::MakeADFun (negative log) likelihood function created directory specified set_cppfile_directory method name <modelname>.cpp","code":""},{"path":"/reference/sdeTMB.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$set_modelname(name)"},{"path":"/reference/sdeTMB.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"name string defining model name.","code":""},{"path":"/reference/sdeTMB.html","id":"method-set-cppfile-directory-","dir":"Reference","previous_headings":"","what":"Method set_cppfile_directory()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Set path directory constructed C++ file created. specify entire path, unless want construct subfolder current working directory - can call e.g. set_cppfile_directory(\"folder_in_current_wd\").","code":""},{"path":"/reference/sdeTMB.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$set_cppfile_directory(directory)"},{"path":"/reference/sdeTMB.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"directory string specifying local directory","code":""},{"path":"/reference/sdeTMB.html","id":"method-set-map-","dir":"Reference","previous_headings":"","what":"Method set_map()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Enable maximum posterior (MAP) estimation. Adds maximum posterior contribution (negative log) likelihood function evaluating fixed effects parameters multivariate Gaussian mean covariance provided.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$set_map(mean, cov)"},{"path":"/reference/sdeTMB.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"mean mean vector Gaussian prior parameter distribution cov covariance matrix Gaussian prior parameter distribution","code":""},{"path":"/reference/sdeTMB.html","id":"method-get-systems-","dir":"Reference","previous_headings":"","what":"Method get_systems()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Retrieve system equations.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$get_systems()"},{"path":"/reference/sdeTMB.html","id":"method-get-observations-","dir":"Reference","previous_headings":"","what":"Method get_observations()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Retrieve observation equations.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$get_observations()"},{"path":"/reference/sdeTMB.html","id":"method-get-observation-variances-","dir":"Reference","previous_headings":"","what":"Method get_observation_variances()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Retrieve observation variances","code":""},{"path":"/reference/sdeTMB.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$get_observation_variances()"},{"path":"/reference/sdeTMB.html","id":"method-get-algebraics-","dir":"Reference","previous_headings":"","what":"Method get_algebraics()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Retrieve algebraic relations","code":""},{"path":"/reference/sdeTMB.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$get_algebraics()"},{"path":"/reference/sdeTMB.html","id":"method-get-initial-state-","dir":"Reference","previous_headings":"","what":"Method get_initial_state()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/sdeTMB.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$get_initial_state()"},{"path":"/reference/sdeTMB.html","id":"method-get-parameters-","dir":"Reference","previous_headings":"","what":"Method get_parameters()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Get initial (estimated) parameters.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$get_parameters(type = \"all\", value = \"all\")"},{"path":"/reference/sdeTMB.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"type one \"\", free\" \"fixed\" parameters. value one \"\", initial\", \"estimate\", \"lower\" \"upper\"","code":""},{"path":"/reference/sdeTMB.html","id":"method-construct-nll-","dir":"Reference","previous_headings":"","what":"Method construct_nll()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Construct extract function handlers negative log likelihood function. handlers TMB's MakeADFun constructed returned. enables user e.g. choose optimization algorithm, just control optimization workflow.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$construct_nll(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = 3,   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   compile = FALSE,   silent = FALSE )"},{"path":"/reference/sdeTMB.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector - one either \"ekf\", \"ukf\" \"tmb\". Sets estimation method. package three available methods implemented: natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep time-step used filtering schemes. time-step two different uses depending chosen method. Kalman Filters: time-step used numerically solving moment differential equations. Laplace Approximation: time-step used Euler-Maruyama simulation scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residauls natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approxmation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/sdeTMB.html","id":"method-estimate-","dir":"Reference","previous_headings":"","what":"Method estimate()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Estimate fixed effects parameters specified model.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$estimate(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = 3,   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   control = list(trace = 1, iter.max = 1e+05, eval.max = 1e+05),   use.hessian = FALSE,   laplace.residuals = FALSE,   unconstrained.optim = FALSE,   compile = FALSE,   silent = FALSE )"},{"path":"/reference/sdeTMB.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector - one either \"ekf\", \"ukf\" \"tmb\". Sets estimation method. package three available methods implemented: natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residauls natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approxmation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. control list control parameters parsed nlminb control argument. See ?stats::nlminb information use.hessian boolean value. default (TRUE) causes optimization algorithm stats::nlminb use fixed effects hessian (negative log) likelihood performing optimization. feature available kalman filter methods without random effects. laplace.residuals boolean - whether calculate one-step ahead residuls using method oneStepPredict. unconstrained.optim boolean value. TRUE optimization carried unconstrained .e. without parameter bounds specified add_parameters. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/sdeTMB.html","id":"method-simulate-","dir":"Reference","previous_headings":"","what":"Method simulate()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$simulate(   data,   method = \"ekf\",   ode.timestep = diff(data$t),   ode.solver = \"rk4\",   pars = NULL,   initial.state = self$get_initial_state(),   n.sims = 100,   simulation.timestep = diff(data$t),   k.ahead = 1,   return.k.ahead = NULL,   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   silent = FALSE )"},{"path":"/reference/sdeTMB.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided add_parameters, unless estimate function run, default values found optimum. initial.state named list two entries 'x0' 'p0' containing initial state covariance state n.sims number simulations simulation.timestep timestep used euler-maruyama scheme k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. return.covariance booelan value indicate whether covariance (instead correlation) returned.","code":""},{"path":"/reference/sdeTMB.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/sdeTMB.html","id":"method-predict-","dir":"Reference","previous_headings":"","what":"Method predict()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$predict(   data,   method = \"ekf\",   ode.timestep = diff(data$t),   ode.solver = \"rk4\",   pars = NULL,   initial.state = self$get_initial_state(),   k.ahead = 1,   return.k.ahead = 0:k.ahead,   return.covariance = TRUE,   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   silent = FALSE )"},{"path":"/reference/sdeTMB.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided add_parameters, unless estimate function run, default values found optimum. initial.state named list two entries 'x0' 'p0' containing initial state covariance state k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. return.covariance booelan value indicate whether covariance (instead correlation) returned. unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/sdeTMB.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/sdeTMB.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Function print model object","code":""},{"path":"/reference/sdeTMB.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$print()"},{"path":"/reference/sdeTMB.html","id":"method-summary-","dir":"Reference","previous_headings":"","what":"Method summary()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Summary function fit","code":""},{"path":"/reference/sdeTMB.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$summary(correlation = FALSE)"},{"path":"/reference/sdeTMB.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"correlation boolean value. default (FALSE) provide fixed effects parameter correlation matrix.","code":""},{"path":"/reference/sdeTMB.html","id":"method-plot-","dir":"Reference","previous_headings":"","what":"Method plot()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"Function print model object","code":""},{"path":"/reference/sdeTMB.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$plot(   plot.obs = 1,   pacf = FALSE,   extended = FALSE,   ggtheme = getggplot2theme() )"},{"path":"/reference/sdeTMB.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed ggtheme ggplot2 theme use creating ggplot.","code":""},{"path":"/reference/sdeTMB.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"objects class cloneable method.","code":""},{"path":"/reference/sdeTMB.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"","code":"sdeTMB$clone(deep = FALSE)"},{"path":"/reference/sdeTMB.html","id":"arguments-18","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'sdeTMB' R6 class — sdeTMB","text":"deep Whether make deep clone.","code":""},{"path":[]},{"path":"/reference/setAlgebraics.html","id":null,"dir":"Reference","previous_headings":"","what":"Add algebraic relationships to the model object. — setAlgebraics","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"Algebraic relations convenient way transform parameters equations, reduce clutter specying various equations, instance ensure positivity (log-transform).","code":""},{"path":"/reference/setAlgebraics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"","code":"setAlgebraics(form,                ...)"},{"path":"/reference/setAlgebraics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"form formula specifying algebraic relation. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":"/reference/setAlgebraics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"left-hand side provided formula specifies parameter overwritten expression right-hand side. also means left-hand side parameter vanish model formulation link{setParameter} therefore specify values new parameters.","code":""},{"path":"/reference/setAlgebraics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"","code":"# Example 1 setAlgebraics( sigma ~ exp(logsigma), theta ~ invlogit(alpha + beta) ) #> Error in setAlgebraics(sigma ~ exp(logsigma), theta ~ invlogit(alpha +     beta)): could not find function \"setAlgebraics\""},{"path":"/reference/setInitialState.html","id":null,"dir":"Reference","previous_headings":"","what":"Set initial state mean and covariance — setInitialState","title":"Set initial state mean and covariance — setInitialState","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/setInitialState.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set initial state mean and covariance — setInitialState","text":"","code":"setInitialState(initial.state, estimate = FALSE)"},{"path":"/reference/setInitialState.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set initial state mean and covariance — setInitialState","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate boolean value indicates whether initial conditions shall estimated fixed effects parameters. provided mean covariance used initial guesses","code":""},{"path":"/reference/setParameter.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify parameters in the model object — setParameter","title":"Specify parameters in the model object — setParameter","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer values, well lower / upper bounds. Parameters can declared either vectors matrices. first entry initial value, second entry lower bound third entry upper bound. Providing first entry fixes particular parameter value.","code":""},{"path":"/reference/setParameter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify parameters in the model object — setParameter","text":"","code":"setParameter(...)"},{"path":"/reference/setParameter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify parameters in the model object — setParameter","text":"... comma-seperated series vectors/matrix entries","code":""},{"path":[]},{"path":"/reference/setVariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Add observation variances to the model object. — setVariance","title":"Add observation variances to the model object. — setVariance","text":"Specify observation variance existing observation equation.","code":""},{"path":"/reference/setVariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add observation variances to the model object. — setVariance","text":"","code":"setVariance(form,                           ...)"},{"path":"/reference/setVariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add observation variances to the model object. — setVariance","text":"form formula class specifying obsevation equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":[]},{"path":"/reference/set_initial_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Set initial state mean and covariance — set_initial_state","title":"Set initial state mean and covariance — set_initial_state","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/set_initial_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set initial state mean and covariance — set_initial_state","text":"","code":"set_initial_state(initial.state, estimate = FALSE)"},{"path":"/reference/set_initial_state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set initial state mean and covariance — set_initial_state","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate boolean value indicates whether initial conditions shall estimated fixed effects parameters. provided mean covariance used initial guesses","code":""},{"path":"/reference/summary.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"Basic summary objects class 'ctsmTMB'","code":""},{"path":"/reference/summary.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"","code":"# S3 method for ctsmTMB summary(object, correlation = FALSE)"},{"path":"/reference/summary.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"huge amount information","code":""},{"path":"/reference/summary.sdeTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'sdeTMB' — summary.sdeTMB","title":"Basic summary of objects of class 'sdeTMB' — summary.sdeTMB","text":"Basic summary objects class 'sdeTMB'","code":""},{"path":"/reference/summary.sdeTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'sdeTMB' — summary.sdeTMB","text":"","code":"# S3 method for sdeTMB summary(object, correlation = FALSE)"},{"path":"/reference/summary.sdeTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'sdeTMB' — summary.sdeTMB","text":"huge amount information","code":""},{"path":"/news/index.html","id":"ctsmtmb-100","dir":"Changelog","previous_headings":"","what":"ctsmTMB 1.0.0","title":"ctsmTMB 1.0.0","text":"first release package","code":""}]
