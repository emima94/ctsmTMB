[{"path":"/articles/ctsmTMB.html","id":"initialising","dir":"Articles","previous_headings":"","what":"Initialising","title":"Getting Started","text":"initialise ctsmTMB model object using Printing model object console reveals basic information :","code":"library(ctsmTMB) model <- ctsmTMB$new() print(model) ## ctsmTMB model object:               ## States       0 ## Diffusions   0 ## Observations 0 ## Inputs       0 ## Parameters   0"},{"path":"/articles/ctsmTMB.html","id":"add-system-equations","dir":"Articles","previous_headings":"","what":"Add system equations","title":"Getting Started","text":"First specify stochastic differential equation governing latent state \\(x_t\\). straight-forward using R formulas, choosing appropriate character names parameters. emphasize drift terms must multiplied dt diffusion terms dw dw# # number e.g. dw2. single state equation may contain number diffusion terms .e.","code":"model$addSystem(dx ~ theta * (mu - x) * dt + sigma_x * dw) model$addSystem(dx ~ theta * (mu - x) * dt + sigma_x1 * dw1 + x * sigma_x2 * dw2 + dw3)"},{"path":"/articles/ctsmTMB.html","id":"add-observation-equations","dir":"Articles","previous_headings":"","what":"Add observation equations","title":"Getting Started","text":"Now observation equations system must specified. amounts specifying mean variance residual normal distribution. First mean specified .e. variable used left-hand side, y, determines name relevant observations -provided data maximum likelihood estimation later.","code":"model$addObs(y ~ x)"},{"path":"/articles/ctsmTMB.html","id":"add-observation-variances","dir":"Articles","previous_headings":"","what":"Add observation variances","title":"Getting Started","text":"Next specify residual variance, using name given observation equation , addObs:","code":"model$setVariance(y ~ sigma_y^2 * u)"},{"path":"/articles/ctsmTMB.html","id":"add-inputs","dir":"Articles","previous_headings":"","what":"Add inputs","title":"Getting Started","text":"Next, declare variables time-dependent inputs via shall must also provided data later, similar observations.","code":"model$addInput(u)"},{"path":"/articles/ctsmTMB.html","id":"add-parameters","dir":"Articles","previous_headings":"","what":"Add parameters","title":"Getting Started","text":"must also specify (fixed effects) parameters, addition initial/lower/upper values estimation. parameter can fixed supplying just single value. instance typically useful fix observation noise parameters simultaneous identification observation process noise difficult practice, knowledge observation noise may known. Thus, let us fix \\(\\sigma_{y}\\) somewhat arbitrary reasonable value: Let’s inspect model object , see longer empty:","code":"model$setParameter(   theta   = c(initial = 5,    lower = 0,    upper = 20),   mu      = c(initial = 0,    lower = -10,  upper = 10),   sigma_x = c(initial = 1e-1, lower = 1e-5, upper = 5),   sigma_y = c(initial = 1e-1, lower = 1e-5, upper = 5) ) model$setParameter(   sigma_y  = 0.05 ) print(model) ## ctsmTMB model object:               ## States       1 ## Diffusions   1 ## Observations 1 ## Inputs       1 ## Parameters   4 ##  ## System Equations: ##  ##   dx ~ theta * (mu - x) * dt + sigma_x * dw  ##  ## Observation Equations: ##  ##   y:  y ~ x + e   e ~ N(0, sigma_y^2 * u)  ##  ##  ## Free Parameters: ##   theta, mu, sigma_x ##  ## Fixed Parameters: ##   sigma_y"},{"path":"/articles/ctsmTMB.html","id":"set-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set initial state and covariance","title":"Getting Started","text":"Lastly state distribution initial time point must specified via mean variance. Note higher dimensions provided covariance cov must matrix. simple initial covariance just scaled identity e.g. two dimensions cov = 1e-1 * diag(2)","code":"initial.state <- list(mean=1, cov=1e-1) model$setInitialState(initial.state=initial.state)"},{"path":"/articles/ctsmTMB.html","id":"generate-data","dir":"Articles","previous_headings":"","what":"Generate Data","title":"Getting Started","text":"model now fully specified, state parameter estimation can performed data hand. particular example generate fake data. can achieved simulating stochastic realization stochastic differential equation, adding observation noise . achieve task using simulate method model object, perform stochastic simulations based Euler-Maruyama scheme. user referred simulation vignette details. choose true parameters \\[ \\theta = 10.0 \\qquad \\mu=1.00 \\qquad \\sigma_{x} = 1.00 \\qquad \\sigma_{y}=0.05 \\] code performs simulation prepares data likelihood estimation:","code":"library(ggplot2)  # Set simulation settings set.seed(11) true.pars <- c(theta=10, mu=1, sigma_x=1, sigma_y=0.05) dt.sim <- 1e-3 t.end <- 1 t.sim <- seq(0, t.end, by=dt.sim) df.sim <- data.frame(t=t.sim, u=1, y=NA)  # Perform simulation sim <- model$simulate(data=df.sim,                        pars=true.pars,                        n.sims=1,                        silent=T,                        initial.state=initial.state) x <- sim$states$x$i0$x1  # Extract observations from simulation and add noise iobs <- seq(1,length(t.sim), by=10) t.obs <- t.sim[iobs] y = x[iobs] + true.pars[\"sigma_y\"] * rnorm(length(iobs))  # Create data-frame data <- data.frame(   t = t.obs,   u = 1,   y = y )  # Plot the simulation and observed data ggplot() +   geom_line(aes(x=t.sim,y=x,color=\"Simulation\")) +   geom_point(aes(x=t.obs,y=y,fill=\"Observations\")) +   ctsmTMB:::getggplot2theme() + labs(x=\"t\", y=\"x\",color=\"\",fill=\"\")"},{"path":"/articles/ctsmTMB.html","id":"perform-estimation","dir":"Articles","previous_headings":"","what":"Perform estimation","title":"Getting Started","text":"can now pass data estimate method. build model, perform various checks, construct computational graph automatic differentiation, perform optimization. Note: data must contain increasing time column named t columns specified inputs observations, case u y. Note: time-consuming step estimation procedure construction AD graph underlying likelihood function, time spent task relative optimization time even models parameters. output generated optimization objective (negative log-likelihood) value parameter values current step. optimizer used ctsmTMB nlminb optimizer stats library. refer user estimation vignette details available arguments estimate, ‘use another optimizer’ vignette details use another optimizer nlminb.","code":"fit <- model$estimate(data) ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.052 seconds. ## Minimizing the negative log-likelihood... ##   0:     1400.0171:  5.00000  0.00000 0.100000 ##   1:    -64.612226:  4.98142 0.0913549  1.09565 ##   2:    -74.658900:  4.79393  1.14526  1.00122 ##   3:    -74.682470:  4.52045  1.00665  1.00785 ##   4:    -74.734734:  4.66161  1.06392  1.00501 ##   5:    -74.745518:  4.73877  1.07682  1.00450 ##   6:    -74.779976:  5.00284  1.09713  1.00396 ##   7:    -74.860990:  5.64276  1.11379  1.00408 ##   8:    -75.070516:  7.18786  1.10429  1.00635 ##   9:    -75.265661:  11.3571  1.00526  1.01491 ##  10:    -75.356843:  9.53201  1.05607  1.00844 ##  11:    -75.394350:  9.92466  1.04390  1.00746 ##  12:    -75.453133:  10.4866  1.02483  1.00122 ##  13:    -75.527071:  10.6227  1.01657 0.989961 ##  14:    -75.768819:  10.2550  1.00728 0.936849 ##  15:    -75.842025:  9.50002  1.01958 0.912180 ##  16:    -75.851608:  9.27045  1.02899 0.911285 ##  17:    -75.852200:  9.26599  1.03199 0.912005 ##  18:    -75.852208:  9.27461  1.03231 0.912029 ##  19:    -75.852209:  9.27737  1.03232 0.912025 ##  20:    -75.852209:  9.27778  1.03232 0.912024 ##   Optimization finished!: ##             Elapsed time: 0.004 seconds. ##             The objective value is: -7.585221e+01 ##             The maximum gradient component is: 5.4e-05 ##             The convergence message is: relative convergence (4) ##             Iterations: 20 ##             Evaluations: Fun: 22 Grad: 21 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished!"},{"path":"/articles/ctsmTMB.html","id":"inspecting-the-fit-object","dir":"Articles","previous_headings":"","what":"Inspecting the fit object","title":"Getting Started","text":"fit object contains following entries first boolean indicates whether estimation successful just copy optimization message stats::nlminb. second likelihood value found optimum third likelihood gradient optimum fourth likelihood hessian optimum","code":"names(fit) ##  [1] \"convergence\"  \"nll\"          \"nll.gradient\" \"nll.hessian\"  \"par.fixed\"    ##  [6] \"sd.fixed\"     \"cov.fixed\"    \"states\"       \"residuals\"    \"observations\" ## [11] \"tvalue\"       \"Pr.tvalue\"    \"private\" fit$convergence ## [1] 0 fit$nll ## [1] -75.85221 fit$nll.gradient ##         theta            mu       sigma_x  ## -2.315829e-07  5.350033e-05  7.049035e-06 fit$nll.hessian ##               theta           mu     sigma_x ## theta    0.05211939  -0.05360169  -0.5703124 ## mu      -0.05360169 102.97419206   0.4686782 ## sigma_x -0.57031238   0.46867821 114.4596547"},{"path":"/articles/ctsmTMB.html","id":"parameter-estimates","dir":"Articles","previous_headings":"Inspecting the fit object","what":"Parameter estimates","title":"Getting Started","text":"Printing fit object reveals standard coefficient matrix parameter estimates. can see parameter estimate associated standard error together one-dimensional t-test statistic associated P-value common hypothesis test \\[ H_{0}: p = 0 \\\\ H_{1}: p \\neq 0 \\] Note large uncertainty \\(\\theta\\) primarily caused relatively short time-series (2 seconds), relative characteristic time process \\(\\tau = 1/\\theta = 0.1 \\, \\text{sec}\\). parameter-related information can extracted fit object. estimated (fixed) parameters: standard deviations (fixed) parameters: covariance (fixed) parameters: parameter covariance found inverting likelihood hessian found optimum .e.:","code":"print(fit) ## Coefficent Matrix  ##         Estimate Std. Error t value  Pr(>|t|)     ## theta   9.277779   4.505959  2.0590   0.04207 *   ## mu      1.032320   0.098572 10.4728 < 2.2e-16 *** ## sigma_x 0.912024   0.096128  9.4876 1.207e-15 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 fit$par.fixed ##     theta        mu   sigma_x  ## 9.2777787 1.0323200 0.9120244 fit$sd.fixed ##      theta         mu    sigma_x  ## 4.50595858 0.09857172 0.09612767 fit$cov.fixed ##               theta           mu      sigma_x ## theta   20.30366268 1.010851e-02 1.011246e-01 ## mu       0.01010851 9.716385e-03 1.058147e-05 ## sigma_x  0.10112465 1.058147e-05 9.240528e-03 solve(fit$nll.hessian) ##               theta           mu      sigma_x ## theta   20.30366268 1.010851e-02 1.011246e-01 ## mu       0.01010851 9.716385e-03 1.058147e-05 ## sigma_x  0.10112465 1.058147e-05 9.240528e-03"},{"path":"/articles/ctsmTMB.html","id":"state-estimates","dir":"Articles","previous_headings":"Inspecting the fit object","what":"State estimates","title":"Getting Started","text":"optimal state distributions associated estimated parameters can extracted model object well. example used Extended Kalman filter (default filtering algorithm specified argument method=\"ekf\" estimate). method produces prior posterior state estimates. prior estimates one-step-ahead predictions, posterior estimated priors updated current-time available observations. user referred Kalman Filter vignette information theoretical details. states can easily plotted using provided S3 plot.ctsmTMB.fit method. plot prior posterior states observations:   Note: decrease variance posterior state estimate expected states updated observations.","code":"plot(fit, type=\"states\",state.type=\"prior\",against=\"y\") plot(fit, type=\"states\",state.type=\"posterior\",against=\"y\")"},{"path":"/articles/ctsmTMB.html","id":"residual-analysis","dir":"Articles","previous_headings":"Inspecting the fit object","what":"Residual analysis","title":"Getting Started","text":"Model validation typically involves inspecting properties prediction residuals. model residuals contained fit$residuals entries: can also easily generate residual analysis plot S3 plot.ctsmTMB.fit method. actually default arguments plot.ctsmTMB.fit. produces time-series residuals, histogram, quantile-quantile plot, auto/partial-correlations cumulative periodogram:","code":"names(fit$residuals) ## [1] \"residuals\"  \"sd\"         \"normalized\" \"cov\" plot(fit)"},{"path":"/articles/ctsmTMB.html","id":"profiling-the-likelihood","dir":"Articles","previous_headings":"","what":"Profiling the likelihood","title":"Getting Started","text":"can perform likelihood profiling profile S3 method fit object, plot result calling plot S3 method . example can inspect profile likelihood \\(\\theta\\) follows:","code":"a <- fit$par.fixed[\"theta\"] - 5 b <- fit$par.fixed[\"theta\"] + 5 prof <- profile(fit, list(\"theta\"=seq(a,b,length.out=25)), silent=TRUE) plot(prof)"},{"path":"/articles/ctsmTMB.html","id":"extra-algebraic-equations","dir":"Articles","previous_headings":"","what":"Extra: Algebraic equations","title":"Getting Started","text":"model definitions can kept clean defining algebraic expressions replace variables defined equations. typical scenario algebraic equations can used rename parameters must strictly positive. Example model \\(\\theta\\) strictly positive parameter \\(\\hat{\\theta} = \\exp(\\log\\theta)\\). can achieved setting following algebraic expression: effect replace occurrences theta model equations exp(logtheta). final thing add new parameter entry model object describes values logtheta","code":"model$setAlgebraics(theta ~ exp(logtheta)) model$setParameter(logtheta = log(c(initial=5, lower=0, upper=20)))"},{"path":[]},{"path":"/articles/estimate.html","id":"argument-method","dir":"Articles","previous_headings":"Arguments","what":"Argument: method","title":"Estimating Parameters","text":"method argument decides estimation/filtering algorithm used. Currently, following methods available: method='lkf': Linear Kalman Filter. method='ekf': Extended Kalman Filter. method='laplace': Laplace Approximation. difference Kalman filtering methods, Laplace method way approach likelihood computations, thus information filters produce: Kalman filters produce prior posterior state estimates. prior estimates conditioned observations starting time \\(t_0\\) til previous time-point \\(t_{k-1}\\). posterior estimates conditioned also observations available “current” time-point \\(t_{k}\\). denoted respectively \\[ \\text{Prior:} \\quad \\mathrm{E}\\left[ x_{t_k} \\mid y_{t_{k-1}}, y_{t_{k-2}},...,y_{t_0} \\right] \\] \\[ \\text{Posterior:} \\quad \\mathrm{E}\\left[ x_{t_k} \\mid y_{t_{k}}, y_{t_{k-1}},...,y_{t_0} \\right] \\] Laplace filter produces smoothed state estimates. state estimate based observations time-points \\(t_{0}\\) \\(t_{N}\\) \\(N\\) last index time-series. denoted \\[ \\text{Smoothed:} \\quad \\mathrm{E}\\left[ x_{t_k} \\mid y_{N}, y_{N-1},...,y_{t_{k}},...,y_{t_1}, y_{t_0} \\right] \\] likelihood contributions Kalman filters based prior estimates, one-step-ahead predictions. gives rise independent one-step-ahead residuals, ideal residual analysis goodness--fit model validation. Laplace filter produce residuals inherently, must instead compute side. Residual calculations disabled default determined laplace.residuals argument. computations costly slow. user referred documentation TMB::oneStepPredict information.","code":""},{"path":"/articles/estimate.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.solver","title":"Estimating Parameters","text":"argument used Kalman filtering methods determine ODE integrator used solving moment differential equations .e. \\[ \\dfrac{d\\mathrm{E}\\left[x_t\\right]}{dt} = f(\\mathrm{E}\\left[x_t\\right]) \\] \\[ \\dfrac{d\\mathrm{V}\\left[x_t\\right]}{dt} = \\dfrac{df}{dx}\\bigg\\vert_{(\\mathrm{E}\\left[x_t\\right])}\\mathrm{V}\\left[x_t\\right] + \\mathrm{V}\\left[x_t\\right]\\left[\\dfrac{df}{dx}\\bigg\\vert_{(\\mathrm{E}\\left[x_t\\right])}\\right]^{T} + g(\\mathrm{E}\\left[x_t\\right])g(\\mathrm{E}\\left[x_t\\right])^{T} \\] ctsmTMB package implements Explicit Forward-Euler euler Explicit 4th Order Runge-Kutta rk4 methods. addition methods available deSolve::ode also available use RTMBode package, significantly slower two solvers, primarily add possibility implicit adaptive solvers. recommend using fast simple solvers begin modelling.","code":""},{"path":"/articles/estimate.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.timestep","title":"Estimating Parameters","text":"argument two different implications depending whether Kalman filtering Laplace filtering carried . method accepts either single scalar value used global time-step, vector length diff(data$t) specifying individual time-steps. input values interpolated linearly time-points one step taken. Kalman filters: case argument controls time-step used euler rk4 ODE solvers. Laplace filter: case argument controls number added intermediate time-points observations represents additional state (random effect) particular time-point. provided time-step \\(\\Delta t_{}\\) divide correspond time-difference \\(t_{+1}-t_{}\\) data rounded . Consider following example time-difference two observations data 3 seconds, time-step 0.7. produces non-integer number steps .e.: \\[ N_{} = \\dfrac{t_{+1}-t_{}}{\\Delta t_i} = \\dfrac{3}{0.7} = 4.28... \\] Thus number steps taken rounded \\(N^{*}_i = \\left\\lceil N_i \\right\\rceil = \\left\\lceil 4.28... \\right\\rceil = 5\\) corrected time-step becomes \\[ \\Delta t^{*}_{} = \\dfrac{3}{N^{*}_{}} = \\dfrac{3}{5} = 0.6 \\] Note: exception rule remainder less \\(\\epsilon = 10^{-3}\\) .e. instance \\(N_i = 4.0001\\) time-step accepted, number steps rounded \\(N^{*}_{}= \\left\\lfloor N_i \\right\\rfloor = 4\\).","code":""},{"path":"/articles/estimate.html","id":"argument-loss-and-loss_c","dir":"Articles","previous_headings":"Arguments","what":"Argument: loss and loss_c","title":"Estimating Parameters","text":"following losses currently available: loss='quadratic' (default) loss='huber' loss='tukey' argument affects Kalman filtering methods, used regularize likelihood contributions, removing influence large outliers. ith likelihood contributions given : \\[ -\\log L_{}(\\theta) \\propto f(r_i) \\] \\(r_i = \\sqrt{e_{}^{T} \\Sigma_{}^{-1} e_{}}\\) normalized residual, \\(e_{}\\) ith residual vector, \\(\\Sigma_{}^{-1}\\) ith residual precision matrix. loss argument changes function \\(f\\) follows: loss='quadratic' \\(f\\) quadratic residuals .e. \\[ f(r) = r^2 \\] likelihood contributions exactly Gaussian. loss='huber' \\(f\\) Huber’s \\(\\psi\\) function given \\[ \\psi_{c}(r) = \\left\\{ \\begin{array}{l} r^2 & \\text{} \\,\\, r \\leq c \\\\ c(2r-c) & \\text{otherwise} \\end{array} \\right\\} \\] quadratic/linear residuals /threshold determined \\(c\\). loss='tukey' \\(f\\) Tukey’s byweight function given \\[ l_{c}(r) = \\left\\{ \\begin{array}{l} r^2 & \\text{} \\,\\, r \\leq c \\\\ c^2 & \\text{otherwise} \\end{array} \\right\\} \\] quadratic/constant residuals /threshold determined \\(c\\). practice smooth approximation Huber Tukey implemented practice using construction \\[ \\tilde{\\psi}_{c}(r) = r^2 (1-\\sigma_{c}(r)) + c^2 \\sigma_{c}(r) \\] \\[ \\tilde{l}_{c}(r) = r^2 (1-\\sigma_{c}(r)) + c(2r-c) \\sigma_{c}(r) \\] \\(\\sigma(r)\\) sigmoid function \\[ \\sigma_{c}(r) = \\dfrac{1}{1+\\exp(-5(r-c))} \\] plot shows actual implemented loss functions (almost indistinguishable) \\(c=5\\). threshold value marked dashed line line \\(x = c\\). Loss Functions loss_c argument used determine value \\(c\\). default values chosen based fact assumed (multivariate) normal distribution residuals, squared (normalized) residuals follows \\(\\chi^{2}_{m}\\) distribution degrees freedom equal number elements \\(e_{}\\) .e: \\[ r_{}^2 = e_{}^{T} \\Sigma_{}^{-1} e_{} \\sim \\chi^{2}_{m} \\] therefore reasonable choose threshold level (value \\(c\\)) determines whether \\(r_{}\\) outlier, level null-hypothesis \\[ H_{0}: r_{}^2 \\sim \\chi^{2}_{m} \\] rejected critical value \\(1 - \\alpha\\). Choosing significance level \\(\\alpha = 0.05\\) appropriate \\(c\\) threshold value becomes \\(m\\) number observation equations. Note: significance level higher chosen missing observations indices \\(\\) systems multiple observation equations.","code":"m <- 1 qchisq(0.95,df=m) ## [1] 3.841459"},{"path":"/articles/estimate.html","id":"argument-use_hessian","dir":"Articles","previous_headings":"Arguments","what":"Argument: use_hessian","title":"Estimating Parameters","text":"argument boolean determines whether likelihood hessian constructed automatic differentiation TMB used optimization procedure providing hessian argument stats::nlminb. default use.hessian=FALSE. argument effect method=laplace due restrictions TMB/RTMB. effect providing hessian typically optimum found fewer iterations, cost computing hessian relatively large, often faster optimize using gradient.","code":""},{"path":"/articles/estimate.html","id":"argument-laplace-residuals","dir":"Articles","previous_headings":"Arguments","what":"Argument: laplace.residuals","title":"Estimating Parameters","text":"boolean controls whether model residuals calculated TMB::oneStepPredict Laplace filtering used (method=laplace). takes considerable amount time - typically much longer estimation .","code":""},{"path":"/articles/estimate.html","id":"argument-unconstrainted-optim","dir":"Articles","previous_headings":"Arguments","what":"Argument: unconstrainted.optim","title":"Estimating Parameters","text":"boolean allows quick unconstrained estimation removing parameter boundaries specified setParameter. may useful sometimes, quickly check whether estimation issues occur ill boundaries.","code":""},{"path":"/articles/estimate.html","id":"argument-estimate-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: estimate.initial.state","title":"Estimating Parameters","text":"boolean determines whether initial-time state distribution (mean covariance) estimated . default estimate.initial.state=FALSE estimated simply taken values provided setInitialState. estimate.initial.state=TRUE mean covariance estimated stationary solution moment differential equations using input values initial time-point. stationary solution obtained first solving \\[ \\dfrac{d\\mathrm{E}\\left[x_{\\infty}\\right]}{dt} = f(\\mathrm{E}\\left[x_\\infty\\right]) = 0 \\] \\(\\mathrm{E}\\left[x_\\infty\\right]\\) using Newton’s method. stationary mean used solve \\[ \\dfrac{d\\mathrm{V}\\left[x_\\infty\\right]}{dt} = \\dfrac{df}{dx}\\bigg\\vert_{(\\mathrm{E}\\left[x_\\infty\\right])}\\mathrm{V}\\left[x_\\infty\\right] + \\mathrm{V}\\left[x_\\infty\\right]\\left[\\dfrac{df}{dx}\\bigg\\vert_{(\\mathrm{E}\\left[x_\\infty\\right])}\\right]^{T} + g(\\mathrm{E}\\left[x_\\infty\\right])g(\\mathrm{E}\\left[x_\\infty\\right])^{T} = 0 \\] stationary covariance \\(\\mathrm{V}\\left[x_\\infty\\right]\\) calling linear solver vectorized system equations (using kronecker products).","code":""},{"path":"/articles/estimate.html","id":"argument-control","dir":"Articles","previous_headings":"Arguments","what":"Argument: control","title":"Estimating Parameters","text":"argument list controls various settings stats::nlminb optimizer. See documentation ?stats::nlminb information. default list(trace=1,iter.max=1e5,eval.max=1e5) prints iteration steps, increases default number iterations function calls allowed optimization procedure terminates. Note:: user remember disabling tracing passing control = list(trace=0) remove ìter.maxand eval.max arguments, provided well needed.","code":""},{"path":"/articles/estimate.html","id":"argument-silent","dir":"Articles","previous_headings":"Arguments","what":"Argument: silent","title":"Estimating Parameters","text":"boolean argument controls whether various information messages printed ctsmTMB model building, compilation estimation.","code":""},{"path":"/articles/estimate.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Estimating Parameters","text":"Insert Example","code":""},{"path":"/articles/observation_equations.html","id":"adding-observation-equations","dir":"Articles","previous_headings":"","what":"Adding observation equations","title":"AddObs - Details","text":"Let’s assume observations \\(y_{t}\\) log-normally distributed conditioned \\(x_{t}\\) .e. \\[ \\log y_{t_{}} \\sim N(x_{t_{}},\\sigma_{y}^{2}) \\] sufficient user provide data column y provided data.frame e.g. estimate predict adding following observation equation Note kind observation equations, left-hand side function one () observed variables must explicitly named using obsnames argument.","code":"obj$addObs(   log(y) ~ x, obsnames = \"log_y\" )"},{"path":"/articles/observation_equations.html","id":"adding-observation-variances","dir":"Articles","previous_headings":"","what":"Adding observation variances","title":"AddObs - Details","text":"names given obsnames important needed specify observation variance. example code work, observation named log_y correct way add observation variance :","code":"obj$setVariance(   y ~ sigma_y^2 ) ## Error in check_observation_variance_eqs(form, self, private): Please add an observation equation for y before specifying its variance obj$setVariance(   log_y ~ sigma_y^2 )"},{"path":"/articles/observation_equations.html","id":"multiple-observation-equations","dir":"Articles","previous_headings":"","what":"Multiple observation equations","title":"AddObs - Details","text":"must supply multiple obsnames supplying multiple observation equations, although name used left-hand side just single variable .e.","code":"obj$addObs(   log(y) ~ x,   y ~ x,   y^2+z^3 ~ x,   obsnames = c(\"log_y\", NA, \"y2_plus_z3\") )"},{"path":"/articles/predict.html","id":"notation","dir":"Articles","previous_headings":"","what":"Notation","title":"Moment Predictions","text":"Let set observations initial time \\(t_0\\) current time \\(t_{}\\) noted \\[ \\mathcal{Y}_{} = \\left\\{ y_{}, y_{-1},...,y_{1},y_{0}\\right\\} \\] k-step prediction prior estimate state mean covariance k time-steps “future” (without updating observations along way) .e.: \\[ \\hat{x}_{+k|} = \\mathrm{E}\\left[ x_{t_{+k}} | y_{t_{}} \\right] \\\\ \\hat{P}_{+k|} = \\mathrm{V}\\left[ x_{t_{+k}} | y_{t_{}} \\right] \\] obtain predictions integrating moment differential equations (linear \\(f\\)) forward time .e: \\[ \\hat{x}_{+k|} = \\hat{x}_{|} + \\int_{t_{}}^{t_{+k}} f(\\hat{x}_{}(\\tau)) \\, d\\tau \\\\ \\hat{P}_{+k|} = \\hat{P}_{|} + \\int_{t_{}}^{t_{+k}} (\\hat{x}_{}(\\tau)) \\hat{P}_{}(\\tau) + \\hat{P}_{}(\\tau) ^{T}(\\hat{x}_{}(\\tau)) + G(\\hat{x}_{}(\\tau)) G^{T}(\\hat{x}_{}(\\tau)) \\, d\\tau \\] \\(\\hat{x}_{}(\\tau) = \\mathrm{E}\\left[ x_{\\tau} | y_{t_{}} \\right]\\) \\(\\hat{P}_{}(\\tau) = \\mathrm{V}\\left[ x_{\\tau} | y_{t_{}} \\right]\\), \\(= \\dfrac{df}{dx}\\)","code":""},{"path":"/articles/predict.html","id":"arguments","dir":"Articles","previous_headings":"","what":"Arguments","title":"Moment Predictions","text":"predict method accepts following arguments","code":"model$predict(data,               pars = NULL,               use.cpp = FALSE,               method = \"ekf\",               ode.solver = \"euler\",               ode.timestep = diff(data$t),               k.ahead = Inf,               return.k.ahead = NULL,               return.covariance = TRUE,               initial.state = self$getInitialState(),               estimate.initial.state = private$estimate.initial,               silent = FALSE )"},{"path":"/articles/predict.html","id":"argument-pars","dir":"Articles","previous_headings":"Arguments","what":"Argument: pars","title":"Moment Predictions","text":"argument vector parameter values, used generate predictions. default behaviour use parameters obtained latest call estimate () alternative use initial guesses defined setParameter.","code":""},{"path":"/articles/predict.html","id":"argument-use-cpp","dir":"Articles","previous_headings":"Arguments","what":"Argument: use.cpp","title":"Moment Predictions","text":"argument boolean determines whether pure R (use.cpp=FALSE, default) C++ (use.cpp=TRUE) implementation used calculate predictions. advantage C++ implementation computational speed comes cost 5-10 seconds compilation time (first time session C++ implementation used, subsequent calls faster). number prediction steps compute given maximized k.ahead = nrow(data)/2. C++ implementation therefore typically advantageous (relatively large) range around maximum, least data sufficiently many rows.","code":"k.ahead * (nrow(data) - k.ahead)"},{"path":"/articles/predict.html","id":"argument-method","dir":"Articles","previous_headings":"Arguments","what":"Argument: method","title":"Moment Predictions","text":"See description estimate vignette. Note: predict method currently available using Extended Kalman filter (method=\"ekf).","code":""},{"path":"/articles/predict.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.solver","title":"Moment Predictions","text":"See description estimate vignette. Note: argument use.cpp=TRUE solvers available euler rk4.","code":""},{"path":"/articles/predict.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.timestep","title":"Moment Predictions","text":"See description estimate vignette.","code":""},{"path":"/articles/predict.html","id":"argument-k-ahead","dir":"Articles","previous_headings":"Arguments","what":"Argument: k.ahead","title":"Moment Predictions","text":"integer argument determines number prediction steps desired.","code":""},{"path":"/articles/predict.html","id":"argument-return-k-ahead","dir":"Articles","previous_headings":"Arguments","what":"Argument: return.k.ahead","title":"Moment Predictions","text":"vector integers determines k-step predictions returned. default behaviour return prediction steps (determined k.ahead).","code":""},{"path":"/articles/predict.html","id":"argument-return-covariance","dir":"Articles","previous_headings":"Arguments","what":"Argument: return.covariance","title":"Moment Predictions","text":"boolean argument determines whether covariance (return.covariance=TRUE, default) prediction correlations returned. returned diagonal elements always variances, trivial 1’s correlation matrix.","code":""},{"path":"/articles/predict.html","id":"argument-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: initial.state","title":"Moment Predictions","text":"See description estimate vignette.","code":""},{"path":"/articles/predict.html","id":"argument-estimate-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: estimate.initial.state","title":"Moment Predictions","text":"See description estimate vignette.","code":""},{"path":"/articles/predict.html","id":"argument-silent","dir":"Articles","previous_headings":"Arguments","what":"Argument: silent","title":"Moment Predictions","text":"See description estimate vignette.","code":""},{"path":"/articles/predict.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Moment Predictions","text":"consider modified Ornstein Uhlenbeck process: \\[ \\mathrm{d}x_{t} = \\theta (a_t - x_{t}) \\, \\mathrm{d}t \\, + \\sigma_{x} \\, \\mathrm{d}b_{t} \\\\ y_{t_{k}} = x_{t_{k}} + \\varepsilon_{t_{k}} \\] mean complex time-varying input \\(a_t = tu_{t}^{2}-\\cos(tu_{t})\\), \\(u_{t}\\) given time-varying input signal. create model simulate data follows: true parameters \\[ \\theta = 20 \\qquad \\sigma_{x} = 1.00 \\qquad \\sigma_{y}=0.05 \\] data plotted : good starting point using predictions, check appropriate parameter values, may provided setParameter good initial guesses optimization. Note however setParameter must called order predict callable (parameter names model needs identified), parameter values can changed calling predict. Let’s calculate predictions series parameter values (changing theta): Note: default behaviour predict use “full” prediction horizon e.g. k.ahead big possible (k.ahead = nrow(.data)-1), using parameters setParameter case pars=c(2,1,1): output predict list two data.frames, one states one observations. five first columns two data.frames identical - contain columns j (indices), associated time-points t.t.j, k.ahead. remaining columns states mean predictions, associated covariances. observations data.frame currently contain mean estimates, obtained passing mean state estimates observation function, case \\(y = h(x) = x\\). actual observed data also provided suffix .data. plot predictions data can perhaps identify \\(\\theta \\\\left[10,50\\right]\\) (\\(\\theta=20\\) truth ).","code":"model = ctsmTMB$new() model$addSystem(dx ~ theta * (t*u^2-cos(t*u) - x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 2, lower = 0,    upper = 100),   sigma_x = c(initial = 0.2, lower = 1e-5, upper = 5),   sigma_y = c(initial = 5e-2) ) model$setInitialState(list(1, 1e-1*diag(1)))  # Set simulation settings set.seed(20) true.pars <- c(theta=20, sigma_x=1, sigma_y=5e-2) dt.sim <- 1e-3 t.sim <- seq(0, 1, by=dt.sim) u.sim <- cumsum(rnorm(length(t.sim),sd=0.1)) df.sim <- data.frame(t=t.sim, y=NA, u=u.sim)  # Perform simulation sim <- model$simulate(data=df.sim,                        pars=true.pars,                        n.sims=1,                       silent=T) x <- sim$states$x$i0$x1  # Extract observations from simulation and add noise iobs <- seq(1,length(t.sim), by=10) t.obs <- t.sim[iobs] u.obs <- u.sim[iobs] y = x[iobs] + true.pars[\"sigma_y\"] * rnorm(length(iobs))  # Create data-frame .data <- data.frame(   t = t.obs,   u = u.obs,   y = y ) pred = model$predict(.data, k.ahead=nrow(.data)-1, pars=c(1, 1, 0.05)) pred1 = model$predict(.data, k.ahead=nrow(.data)-1, pars=c(10, 1, 0.05)) pred2 = model$predict(.data, k.ahead=nrow(.data)-1, pars=c(50, 1, 0.05)) pred3 = model$predict(.data, k.ahead=nrow(.data)-1, pars=c(100, 1, 0.05)) head(pred$states) ##   i. j. t.i  t.j k.ahead        x       var.x ## 1  0  0   0 0.00       0 1.228755 0.002439024 ## 2  0  1   0 0.01       1 1.206468 0.012390244 ## 3  0  2   0 0.02       2 1.184417 0.022142439 ## 4  0  3   0 0.03       3 1.162597 0.031699590 ## 5  0  4   0 0.04       4 1.141237 0.041065598 ## 6  0  5   0 0.05       5 1.120086 0.050244286 head(pred$observations) ##   i. j. t.i  t.j k.ahead        y      y.data ## 1  0  0   0 0.00       0 1.228755  1.23447430 ## 2  0  1   0 0.01       1 1.206468  0.97884420 ## 3  0  2   0 0.02       2 1.184417  0.57395038 ## 4  0  3   0 0.03       3 1.162597  0.35458516 ## 5  0  4   0 0.04       4 1.141237 -0.04251396 ## 6  0  5   0 0.05       5 1.120086 -0.18870233"},{"path":"/articles/predict.html","id":"forecasting-evaluation","dir":"Articles","previous_headings":"","what":"Forecasting Evaluation","title":"Moment Predictions","text":"can evaluate forecast performance model comparing predictions observed data. start estimating likely parameters model: predict appropriate forecast horizon. example let horizon 25-steps: Let’s plot 10-step predictions observations.  Lastly lets calculate mean prediction accuracy using RMSE-score:","code":"fit = model$estimate(.data) ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.055 seconds. ## Minimizing the negative log-likelihood... ##   0:     920.28471:  2.00000 0.200000 ##   1:    -32.748040:  2.01465  1.19989 ##   2:    -49.267078:  6.01432  1.14877 ##   3:    -75.321450:  22.0129 0.935117 ##   4:    -77.133918:  17.1351  1.00124 ##   5:    -77.819764:  18.6698 0.979520 ##   6:    -77.842339:  18.9070 0.974925 ##   7:    -77.858520:  18.9749 0.971871 ##   8:    -77.965268:  19.2199 0.949778 ##   9:    -78.089423:  19.2483 0.922061 ##  10:    -78.223819:  18.9467 0.889066 ##  11:    -78.259319:  18.6421 0.884139 ##  12:    -78.262250:  18.5681 0.888087 ##  13:    -78.262281:  18.5649 0.888761 ##  14:    -78.262281:  18.5649 0.888771 ##   Optimization finished!: ##             Elapsed time: 0.003 seconds. ##             The objective value is: -7.826228e+01 ##             The maximum gradient component is: 2.1e-06 ##             The convergence message is: relative convergence (4) ##             Iterations: 14 ##             Evaluations: Fun: 16 Grad: 15 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished! print(fit) ## Coefficent Matrix  ##          Estimate Std. Error t value  Pr(>|t|)     ## theta   18.564856   1.376804 13.4840 < 2.2e-16 *** ## sigma_x  0.888771   0.091936  9.6673 4.855e-16 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 pred.horizon <- 25 pred = model$predict(.data, k.ahead=pred.horizon) ## Checking data... ## Predicting with R... ## Returning results... ## Finished! pred.H = pred$states[pred$states$k.ahead==pred.horizon,] rmse = c() k.ahead = 1:pred.horizon for(i in k.ahead){   xy = data.frame(     x = pred$states[pred$states$k.ahead==i,\"x\"],     y = pred$observations[pred$observations$k.ahead==i,\"y.data\"]   )   rmse[i] = sqrt(mean((xy[[\"x\"]] - xy[[\"y\"]])^2)) }"},{"path":"/articles/simulate.html","id":"notation","dir":"Articles","previous_headings":"","what":"Notation","title":"Stochastic Simulations","text":"Let set observations initial time \\(t_0\\) current time \\(t_{}\\) noted \\[ \\mathcal{Y}_{} = \\left\\{ y_{}, y_{-1},...,y_{1},y_{0}\\right\\} \\] k-step simulation sample stochastic path model stochastic differential equation k time-steps future, conditioned current state estimate mean covariance \\[ \\hat{x}_{|} = \\mathrm{E}\\left[ x_{t_{}} | y_{t_{}} \\right] \\\\ P_{|} = \\mathrm{V}\\left[ x_{t_{}} | y_{t_{}} \\right] \\] single stochastic simulation can obtained using Euler-Maruyama scheme \\[ X_{t_{j+1}} = X_{t_{j}} + f(X_{t_{j}},u_{t_{j}},t_{j}) \\, \\Delta t_{j} + G(X_{t_{j}},u_{t_{j}},t_{j}) \\, \\Delta B_{j} \\] \\(j=,...,+k\\), initial point follows \\[ X_{t_{}} \\sim N(\\hat{x}_{|}, P_{|} ) \\] \\[ \\Delta B_{j} \\sim N(0,\\Delta t_{j}) \\]","code":""},{"path":"/articles/simulate.html","id":"arguments","dir":"Articles","previous_headings":"","what":"Arguments","title":"Stochastic Simulations","text":"simulate method accepts following arguments","code":"model$simulate(data,                pars = NULL,                use.cpp = FALSE,                method = \"ekf\",                ode.solver = \"rk4\",                ode.timestep = diff(data$t),                simulation.timestep = diff(data$t),                k.ahead = nrow(data)-1,                return.k.ahead = 0:k.ahead,                n.sims = 100,                initial.state = self$getInitialState(),                estimate.initial.state = private$estimate.initial,                silent = FALSE)"},{"path":"/articles/simulate.html","id":"argument-pars","dir":"Articles","previous_headings":"Arguments","what":"Argument: pars","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"/articles/simulate.html","id":"argument-use-cpp","dir":"Articles","previous_headings":"Arguments","what":"Argument: use.cpp","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"/articles/simulate.html","id":"argument-method","dir":"Articles","previous_headings":"Arguments","what":"Argument: method","title":"Stochastic Simulations","text":"See description estimate vignette. Note: simulate method currently available using Extended Kalman filter (method=\"ekf).","code":""},{"path":"/articles/simulate.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.solver","title":"Stochastic Simulations","text":"See description estimate vignette. Note: argument use.cpp=TRUE solvers available euler rk4.","code":""},{"path":"/articles/simulate.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"Arguments","what":"Argument: ode.timestep","title":"Stochastic Simulations","text":"See description estimate vignette.","code":""},{"path":"/articles/simulate.html","id":"argument-k-ahead","dir":"Articles","previous_headings":"Arguments","what":"Argument: k.ahead","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"/articles/simulate.html","id":"argument-return-k-ahead","dir":"Articles","previous_headings":"Arguments","what":"Argument: return.k.ahead","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"/articles/simulate.html","id":"argument-simulation-timestep","dir":"Articles","previous_headings":"Arguments","what":"Argument: simulation.timestep","title":"Stochastic Simulations","text":"argument ode.timestep determines time-steps used data-points performing Euler-Maruyama simulation.","code":""},{"path":"/articles/simulate.html","id":"argument-n-sims","dir":"Articles","previous_headings":"Arguments","what":"Argument: n.sims","title":"Stochastic Simulations","text":"number stochastic simulations (trajectories) generated.","code":""},{"path":"/articles/simulate.html","id":"argument-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: initial.state","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"/articles/simulate.html","id":"argument-estimate-initial-state","dir":"Articles","previous_headings":"Arguments","what":"Argument: estimate.initial.state","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"/articles/simulate.html","id":"argument-silent","dir":"Articles","previous_headings":"Arguments","what":"Argument: silent","title":"Stochastic Simulations","text":"See description predict vignette.","code":""},{"path":"/articles/simulate.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Stochastic Simulations","text":"consider modified Ornstein Uhlenbeck process: \\[ \\mathrm{d}x_{t} = \\theta (a_t - x_{t}) \\, \\mathrm{d}t \\, + \\sigma_{x} \\, \\mathrm{d}b_{t} \\\\ y_{t_{k}} = x_{t_{k}} + \\varepsilon_{t_{k}} \\] mean complex time-varying input \\(a_t = tu_{t}^{2}-\\cos(tu_{t})\\), \\(u_{t}\\) given time-varying input signal. create model simulate data follows: can simulate many trajectories using: parameters \\(\\theta = 20, \\sigma_{x} = 1, \\sigma_{y} = 0.05\\). Note: value \\(\\sigma_{y}\\) impact “full” simulations (.e. choosing maximum k.ahead) since data updates occur. simulations can plotted quickly using matplot:  Lets see effect setting \\(\\sigma_{x} = 3\\):  Lets see effect setting \\(\\theta = 50\\):","code":"model = ctsmTMB$new() model$addSystem(dx ~ theta * (t*u^2-cos(t*u) - x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 2, lower = 0,    upper = 100),   sigma_x = c(initial = 0.2, lower = 1e-5, upper = 5),   sigma_y = c(initial = 5e-2) ) model$setInitialState(list(1, 1e-1*diag(1))) # Set simulation settings set.seed(20) true.pars <- c(theta=20, sigma_x=1, sigma_y=5e-2) dt.sim <- 1e-3 t.sim <- seq(0, 1, by=dt.sim) u.sim <- cumsum(rnorm(length(t.sim),sd=0.1)) df.sim <- data.frame(t=t.sim, y=NA, u=u.sim)  # Simulate data sim <- model$simulate(data=df.sim,                        pars=true.pars,                        n.sims=1,                       silent=T)  # Grab first simulation trajectory x <- sim$states$x$i0$x1  # Extract observations from simulation and add noise iobs <- seq(1,length(t.sim), by=10) t.obs <- t.sim[iobs] u.obs <- u.sim[iobs] y = x[iobs] + true.pars[\"sigma_y\"] * rnorm(length(iobs))  # Create data-frame .data <- data.frame(   t = t.obs,   u = u.obs,   y = y ) sim <- model$simulate(data=.data,                        pars=c(20,1,0.05),                        n.sims=100,                       silent=T) # Get the first (and only in this case) k-step simulation data.frame X <- sim$states$x$i0  # Grab all the simulations (the first five columns are indices, time, etc.) Y <- X[,-c(1:5)]  # Grab prediction time column t <- X[,\"t.j\"]  # Plot matplot(t,Y,type=\"l\", ylim=c(-4,4)) sim <- model$simulate(data=.data,                        pars=c(20,3,0.05),                        n.sims=100,                       silent=T) sim <- model$simulate(data=.data,                        pars=c(50,1,0.05),                        n.sims=100,                       silent=T)"},{"path":"/articles/using_another_optimizer.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"Extracting the Likelihood Function and Changing Optimizer","text":"use common Ornstein-Uhlenbeck process showcase use likelihood. \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/using_another_optimizer.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Extracting the Likelihood Function and Changing Optimizer","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/using_another_optimizer.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"Extracting the Likelihood Function and Changing Optimizer","text":"principle ready call estimate method run optimization scheme using built-optimization uses stats::nlminb .e. Inside package optimise objective function respect fixed parameters using construction function handlers TMB::MakeADFun parsing stats::nlminb .e.","code":"fit = obj$estimate(.data) ## Building model... ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.052 seconds. ## Minimizing the negative log-likelihood... ##   0:     936.11682:  1.60944  0.00000 -2.30259 -2.30259 ##   1:     87.083269:  1.05839 0.612612 -1.83165 -1.98751 ##   2:     30.831804:  1.42872 0.571166 -1.47012 -1.13285 ##   3:     27.093246:  1.22027  1.42418 -1.16175 -1.49867 ##   4:    0.42802599:  1.21559  1.07263 -0.807822 -1.53233 ##   5:    -29.837043:  1.68587 0.793054 0.591933 -2.65227 ##   6:    -32.378284:  1.71155 0.797170 0.422376 -2.67022 ##   7:    -33.322237:  1.80730 0.816713 0.294476 -2.60826 ##   8:    -35.484031:  2.11436 0.813309 0.261892 -2.45452 ##   9:    -36.943433:  2.20642 0.984187 0.199473 -2.38963 ##  10:    -38.269996:  2.39678  1.01007 0.128045 -2.32821 ##  11:    -38.662773:  2.46559  1.03990 0.118501 -2.31645 ##  12:    -39.208765:  2.61559  1.05578 0.0954213 -2.30526 ##  13:    -39.271267:  2.67270  1.09444 0.113168 -2.30196 ##  14:    -39.341842:  2.73859  1.07795 0.123778 -2.32079 ##  15:    -39.346399:  2.71897  1.07807 0.124258 -2.33025 ##  16:    -39.347572:  2.71957  1.07662 0.127387 -2.32720 ##  17:    -39.347641:  2.72307  1.07756 0.127613 -2.32681 ##  18:    -39.347669:  2.72144  1.07762 0.127756 -2.32677 ##  19:    -39.347672:  2.72159  1.07745 0.127677 -2.32686 ##  20:    -39.347672:  2.72164  1.07749 0.127690 -2.32684 ##  21:    -39.347672:  2.72163  1.07749 0.127690 -2.32684 ##   Optimization finished!: ##             Elapsed time: 0.004 seconds. ##             The objective value is: -3.934767e+01 ##             The maximum gradient component is: 8.4e-06 ##             The convergence message is: relative convergence (4) ##             Iterations: 21 ##             Evaluations: Fun: 30 Grad: 22 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished! nll = TMB::MakeADFun(...) opt = stats::nlminb(start=nll$par, objective=nll$fn, grad=nll$gr, hessian=nll$he)"},{"path":"/articles/using_another_optimizer.html","id":"extract-function-handlers","dir":"Articles","previous_headings":"","what":"Extract function handlers","title":"Extracting the Likelihood Function and Changing Optimizer","text":"likelihood method allows retrieve nll object holds negative log-likelihood, derivatives. method takes arguments similar estimate. initial parameters (supplied user) stored objective function can evaluated gradient can evaluated hessian can evaluated can now use optimize function using e.g. stats::optim instead.","code":"nll = obj$likelihood(.data) ## Checking data... ## Succesfully returned function handlers nll$par ##   logtheta         mu logsigma_x logsigma_y  ##   1.609438   0.000000  -2.302585  -2.302585 nll$fn(nll$par) ## [1] 936.1168 nll$gr(nll$par) ##          [,1]      [,2]      [,3]     [,4] ## [1,] 1430.881 -1590.748 -1222.864 -818.151 nll$he(nll$par) ##           [,1]       [,2]       [,3]       [,4] ## [1,]  2348.091 -2949.2028 -1700.6171 -1167.7123 ## [2,] -2949.203  1691.7601  2308.7901   874.6161 ## [3,] -1700.617  2308.7901   938.3781  1516.2869 ## [4,] -1167.712   874.6161  1516.2869   311.1072"},{"path":"/articles/using_another_optimizer.html","id":"extract-parameter-lowerupper-bounds","dir":"Articles","previous_headings":"","what":"Extract parameter lower/upper bounds","title":"Extracting the Likelihood Function and Changing Optimizer","text":"can extract parameter bounds specified calling setParameter() method using getParameters method (note nll$par pars$initial identical).","code":"pars = obj$getParameters() print(pars) ##            type   estimate   initial     lower     upper ## logtheta   free  2.7216294  1.609438      -Inf  2.995732 ## mu         free  1.0774882  0.000000 -10.00000 10.000000 ## logsigma_x free  0.1276898 -2.302585 -11.51293  1.609438 ## logsigma_y free -2.3268411 -2.302585 -11.51293  1.609438"},{"path":"/articles/using_another_optimizer.html","id":"optimize-manually-using-statsoptim","dir":"Articles","previous_headings":"","what":"Optimize manually using stats::optim","title":"Extracting the Likelihood Function and Changing Optimizer","text":"supply initial parameter values, objective function handler gradient handler, parameter bounds optim.","code":"opt = stats::optim(par=nll$par,                     fn=nll$fn,                     gr=nll$gr,                     method=\"L-BFGS-B\",                     lower=pars$lower,                     upper=pars$upper)"},{"path":"/articles/using_another_optimizer.html","id":"compare-results-between-the-two-optimizers","dir":"Articles","previous_headings":"","what":"Compare results between the two optimizers","title":"Extracting the Likelihood Function and Changing Optimizer","text":"Lets compare results using stats::optim extracted function handler versus internal optimisation uses stats::nlminb stored fit:","code":"# Estimated parameters data.frame(external=opt$par, internal=fit$par.fixed) ##              external   internal ## logtheta    2.7216300  2.7216294 ## mu          1.0774878  1.0774882 ## logsigma_x  0.1276904  0.1276898 ## logsigma_y -2.3268419 -2.3268411 # Neg. Log-Likelihood data.frame(external=opt$value, internal=fit$nll) ##    external  internal ## 1 -39.34767 -39.34767 # Gradient components data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed))) ##        external      internal ## 1  7.587709e-06 -8.417709e-06 ## 2 -5.872425e-05  8.215885e-06 ## 3  1.062722e-05  4.106731e-06 ## 4 -1.917425e-05  1.643487e-06"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Phillip Vetter. Author, maintainer, copyright holder. Jan Møller. Contributor. Uffe Thygesen. Contributor. Peder Bacher. Contributor. Henrik Madsen. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vetter PB, Møller JK, Thygesen U, Bacher P, Madsen H (2025). ctsmTMB: Continuous Time Stochastic Modelling using Template Model Builder. R Package Version 1.0, https://github.com/phillipbvetter/ctsmTMB.","code":"@Manual{,   title = {ctsmTMB: Continuous Time Stochastic Modelling using Template Model Builder},   author = {Phillip Brinck Vetter and Jan K. Møller and Uffe Thygesen and Peder Bacher and Henrik Madsen},   year = {2025},   note = {R Package Version 1.0},   url = {https://github.com/phillipbvetter/ctsmTMB}, }"},{"path":[]},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"Welcome GitHub repository hosts ctsmTMB (Continuous Time Stochastic Modelling using Template Model Builder), intended successor , heavily inspired , CTSM package (Continuous Time Stochastic Modelling). purpose package facilitate user-friendly tool (state parameter) inference, forecasting, (multi-dimensional) continuous-discrete stochastic state space systems, .e. systems form dxt = f(t, xt, ut, θ) dt + g(t, xt, ut, θ) dBt ytk = h(tk, xtk, utk, θ) latent state xt evolves continuously time, governed set stochastic differential equations, information system available discrete times observations ytk. ctsmTMB package essentially wrapper around TMB/RTMB packages (Template Model Builder) provide automatic differentiation likelihood function, access computational tools Laplace approximation. likelihood function constructed based (symbolic) user-provided state space equations, may specified using implemented OOP-style R6 ctsmTMB class, methods addSystem (defining system equations), addObs (defining observation equations). primary work-horse ctsmTMB estimate method, carries inference minimizing (negative log) likelihood using stats::nlminb quasi-Newton optimizer. resulting object contains maximum likelihood parameter state estimates, associated marginal uncertainties. available inference methods Linear Extended Kalman filters addition filtration (actually smoothing) using Laplace approximation approach. package facilities forecasting predict (moment forecasts) simulate (stochastic path simulations) methods. calculations may carried either R (default) additional speed C++ using Rcpp.","code":""},{"path":"/index.html","id":"estimation-methods","dir":"","previous_headings":"","what":"Estimation Methods","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"following state reconstruction algorithms currently available: (Continuous-Discrete) Linear Kalman Filter, lkf. (Continuous-Discrete) Extended Kalman Filter, ekf. (Continuous-Discrete) Laplace “Filter” laplace.","code":""},{"path":"/index.html","id":"kalman-filters","dir":"","previous_headings":"","what":"Kalman Filters","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"package currently mostly tailored towards Kalman Filter. advantages methods : hessian likelihood function (w.r.t parameters) available. model residuals easier compute e.g. model validation. Multi-step predictions / simulations state updates easier compute. cases TMB simply provides automatic differentiation.","code":""},{"path":"/index.html","id":"laplace-filter","dir":"","previous_headings":"","what":"Laplace “Filter”","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"state-reconstructions based laplace (approximation) method smoothed estimates, meaning states optimized jointly, given observations data. Laplace Approximation natively built-completely handled TMB. package implements stability-improved method due Thygesen, 2025. particular advantage Laplace filter : possibility unimodal non-Gaussian observation densities accommodate need e.g. heavier distribution tails. yet implemented. method typically useful model-training goal forecasting likelihood contributions based smoothed estimates, rather one-step predictions Kalman filters.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can install package copying command R. important note users must working C++ compilers install use ctsmTMB.","code":"remotes::install_github(repo=\"phillipbvetter/ctsmTMB\", dependencies=TRUE)"},{"path":"/index.html","id":"windows","dir":"","previous_headings":"","what":"Windows","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"C++ compilation R requires Rtools: Go https://cran.r-project.org/bin/windows/Rtools/ find latest version. Go “Control Panel -> System ->”Advanced” (tab) -> “Environment Variables” -> Highlight “Path” -> “Edit” -> Add character string “Variable Value” path Rtools folder **C:;C:*.","code":""},{"path":"/index.html","id":"mac--unix","dir":"","previous_headings":"","what":"Mac / Unix","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"Mac users install Command Line Tools. Run following command Terminal","code":"xcode-select --install"},{"path":"/index.html","id":"test-the-installation","dir":"","previous_headings":"","what":"Test the Installation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"installed package good idea test whether TMB C++ compilation works. able run examples without compilation errors: information see TMB GitHub associated installation instructions.","code":"library(TMB) runExample(all=TRUE)"},{"path":"/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can visit package webpage browse vignettes example uses, particular see Getting Started.","code":""},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can access documentation methods methods documentation also available package homepage.","code":"?ctsmTMB"},{"path":"/index.html","id":"code-example---inference-in-1d-ornstein-uhlenbeck-process","dir":"","previous_headings":"","what":"Code Example - Inference in 1D Ornstein-Uhlenbeck Process","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"","code":"library(ggplot2) library(patchwork) library(dplyr) library(reshape2) library(ctsmTMB)  ############################################################ # Data simulation ############################################################  # Simulate data using Euler Maruyama set.seed(20) pars = c(theta=10, mu=1, sigma_x=1, sigma_y=0.1) #  dt.sim = 1e-3 t.sim = seq(0,5,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) u.sim = cumsum(rnorm(length(t.sim),sd=0.05)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + pars[1]*(pars[2]-x[i]+u.sim[i])*dt.sim + pars[3]*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 ids = seq(1,length(t.sim),by=round(dt.obs / dt.sim)) t.obs = t.sim[ids] y = x[ids] + pars[4] * rnorm(length(t.obs)) # forcing input u = u.sim[ids]  # Create data .data = data.frame(   t = t.obs,   y = y,   u = u )  ############################################################ # Model creation and estimation ############################################################  # Create model object model = ctsmTMB$new()  # Add system equations model$addSystem(   dx ~ theta * (mu-x+u) * dt + sigma_x*dw )  # Add observation equations model$addObs(   y ~ x )  # Set observation equation variances model$setVariance(   y ~ sigma_y^2 )  # Add vector input model$addInput(u)  # Specify parameter initial values and lower/upper bounds in estimation model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = c(initial=1e-1, lower=1e-10, upper=30) )  # Set initial state mean and covariance model$setInitialState(list(x[1], 1e-1*diag(1)))  # Carry out estimation with default settings (extended kalman filter) fit <- model$estimate(data=.data, method=\"ekf\")  # Check parameter estimates against truth p0 = fit$par.fixed cbind(p0,pars)  # Create plot of one-step predictions, simulated states and observations t.est = fit$states$mean$prior$t x.mean = fit$states$mean$prior$x x.sd = fit$states$sd$prior$x plot1 = ggplot() +   geom_ribbon(aes(x=t.est, ymin=x.mean-2*x.sd, ymax=x.mean+2*x.sd),fill=\"grey\", alpha=0.9) +   geom_line(aes(x=t.est, x.mean),col=\"steelblue\",lwd=1) +   geom_line(aes(x=t.sim,y=x)) +    geom_point(aes(x=t.obs,y=y),col=\"tomato\",size=0.5) +   labs(title=\"1-Step State Estimates vs Observations\", x=\"Time\", y=\"\") +   theme_minimal()  # Predict to obtain k-step-ahead predictions to see model forecasting ability pred.list = model$predict(data=.data,                            k.ahead=10,                            method=\"ekf\", )  # Create plot all 10-step predictions against data pred = pred.list$states pred10step = pred %>% dplyr::filter(k.ahead==10) plot2 = ggplot() +   geom_ribbon(aes(x=pred10step$t.j,                    ymin=pred10step$x-2*sqrt(pred10step$var.x),                   ymax=pred10step$x+2*sqrt(pred10step$var.x)),fill=\"grey\", alpha=0.9) +   geom_line(aes(x=pred10step$t.j,pred10step$x),color=\"steelblue\",lwd=1) +   geom_point(aes(x=t.obs,y=y),color=\"tomato\",size=0.5) +   labs(title=\"10 Step Predictions vs Observations\", x=\"Time\", y=\"\") +   theme_minimal()  # Perform prediction ignoring all data pred.list = model$predict(data=.data,method=\"ekf\")  # Perform simulation ignoring all data sim.list = model$simulate(data=.data, method=\"ekf\", n.sims=10)  # Collapse simulation data for easy use with ggplot  sim.df = sim.list$states$x$i0 %>%   select(!c(\"i\",\"j\",\"t.i\",\"k.ahead\")) %>%   reshape2::melt(., id.var=\"t.j\")  # Plot all simulations and the prediction against observations plot3 = ggplot() +   geom_line(data=sim.df, aes(x=t.j, y=value, group=variable),color=\"grey\") +   geom_line(aes(x=pred.list$states$t.j,y=pred.list$states$x),color=\"steelblue\") +   geom_point(aes(x=t.obs,y=y),color=\"tomato\",size=0.5) +   labs(title=\"No Update Prediction and Simulations vs Observations\", x=\"Time\", y=\"\") +   theme_minimal() + theme(legend.position = \"none\")  # Create plot p1 <- patchwork::wrap_plots(plot1, plot2, plot3, ncol=1)  # Create one-step-ahead residual analysis plot p2 <- plot(fit)  # Wrap both plots patchwork::wrap_plots(p1,p2[[1]], ncol=2)"},{"path":"/index.html","id":"bibliography","dir":"","previous_headings":"","what":"Bibliography","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"U. H. Thygesen K. Kristensen (2025), “Inference stochastic differential equations using Laplace approximation: Demonstration examples”. : arXiv:2503.21358v2.","code":""},{"path":"/reference/Ornstein.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a simulated Ornstein-Uhlenbeck process with time-dependent mean — Ornstein","title":"Sample from a simulated Ornstein-Uhlenbeck process with time-dependent mean — Ornstein","text":"data simulated using standard Euler-Maruyama method. simulated process governed SDE #' dx ~ theta * (mu + u - x) * dt + sigma_x * dw parameters used simulation theta = 2, mu = 0.5, sigma_x = 1.358, sigma_y = 1e-8 simulation time-step 1e-3, observation time-step 1e-1. simulation taken t = 0..20","code":""},{"path":"/reference/Ornstein.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a simulated Ornstein-Uhlenbeck process with time-dependent mean — Ornstein","text":"","code":"Ornstein"},{"path":"/reference/Ornstein.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample from a simulated Ornstein-Uhlenbeck process with time-dependent mean — Ornstein","text":"data frame 201 rows 3 columns. columns represent variables: t (time), y (observation) u (input).","code":""},{"path":"/reference/addInput.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify input variables in the model object. — addInput","title":"Specify input variables in the model object. — addInput","text":"Declare whether variable contained system, observation observation variance equations input variable.","code":""},{"path":"/reference/addInput.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify input variables in the model object. — addInput","text":"","code":"addInput(...)"},{"path":"/reference/addInput.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify input variables in the model object. — addInput","text":"... series variable names (unquoted) match variable names defined system treated input variables.","code":""},{"path":"/reference/addObs.html","id":null,"dir":"Reference","previous_headings":"","what":"Add observation equations to model object — addObs","title":"Add observation equations to model object — addObs","text":"Add observation equation ctsmTMB model-object links states observed variable.","code":""},{"path":"/reference/addObs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add observation equations to model object — addObs","text":"","code":"addObs(form, ..., obsnames = NULL)"},{"path":"/reference/addObs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add observation equations to model object — addObs","text":"form formula specifying observation equation added system. ... formulas similar form, used allow specifying multiple formulas comma-separation rather providing list. obsnames character vector specifying observation names used observation left-hand side function call. See details.","code":""},{"path":[]},{"path":"/reference/addObs.html","id":"obsnames","dir":"Reference","previous_headings":"","what":"obsnames","title":"Add observation equations to model object — addObs","text":"obsnames argument used left-hand side form function variable .e. log(y) (class 'call' instead 'name'). user provide data y, log-transformation handled internally. supported functions discussed addSystem.","code":""},{"path":"/reference/addSystem.html","id":null,"dir":"Reference","previous_headings":"","what":"Add state equations to model object — addSystem","title":"Add state equations to model object — addSystem","text":"Add stochastic differential equation ctsmTMB model-object governs differential evolution states specified model.","code":""},{"path":"/reference/addSystem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add state equations to model object — addSystem","text":"","code":"addSystem(form, ...)"},{"path":"/reference/addSystem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add state equations to model object — addSystem","text":"form formula specifying stochastic differential equation added system. ... formulas similar form, used allow specifying multiple formulas comma-separation rather providing list.","code":""},{"path":[]},{"path":"/reference/addSystem.html","id":"usable-functions","dir":"Reference","previous_headings":"","what":"Usable functions","title":"Add state equations to model object — addSystem","text":"formulas can contain elementary functions log, exp, logit invlogit. general supported functions 1) defined derivative table Deriv package, 2) understood TMB C++ side.","code":""},{"path":"/reference/ctsm.html","id":null,"dir":"Reference","previous_headings":"","what":"Shortcut class constructor — ctsm","title":"Shortcut class constructor — ctsm","text":"just short-cut class constructor users can model <- ctsm() instead model <- ctsmTMB$new().","code":""},{"path":"/reference/ctsm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shortcut class constructor — ctsm","text":"","code":"ctsm()"},{"path":"/reference/ctsm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shortcut class constructor — ctsm","text":"","code":"library(ctsmTMB) model <- ctsm()"},{"path":"/reference/ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"following public methods used construct stochastic state space model system, consisting set stochastic differential equations (SDEs), one algebraic observation equations (AOEs). AOEs used infer information value (latent) states governed SDEs, thus must functions least one state.","code":""},{"path":"/reference/ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"function returns object class R6 ctsmTMB, can used define stochastic state space system.","code":""},{"path":[]},{"path":"/reference/ctsmTMB.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"ctsmTMB$new() ctsmTMB$.private() ctsmTMB$addSystem() ctsmTMB$addObs() ctsmTMB$setVariance() ctsmTMB$addInput() ctsmTMB$setParameter() ctsmTMB$setAlgebraics() ctsmTMB$setInitialState() ctsmTMB$setInitialVarianceScaling() ctsmTMB$setLamperti() ctsmTMB$setModelname() ctsmTMB$setMAP() ctsmTMB$getSystems() ctsmTMB$getObservations() ctsmTMB$getVariances() ctsmTMB$getAlgebraics() ctsmTMB$getInitialState() ctsmTMB$getParameters() ctsmTMB$getEstimate() ctsmTMB$getLikelihood() ctsmTMB$getPrediction() ctsmTMB$getSimulation() ctsmTMB$estimate() ctsmTMB$likelihood() ctsmTMB$predict() ctsmTMB$simulate() ctsmTMB$print() ctsmTMB$clone()","code":""},{"path":"/reference/ctsmTMB.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Initialize private fields","code":""},{"path":"/reference/ctsmTMB.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$new()"},{"path":"/reference/ctsmTMB.html","id":"method-private-","dir":"Reference","previous_headings":"","what":"Method .private()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Extract private fields ctsmTMB model object. Primarily used debugging.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$.private()"},{"path":"/reference/ctsmTMB.html","id":"method-addsystem-","dir":"Reference","previous_headings":"","what":"Method addSystem()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Define stochastic differential equation(s) form d<state> ~ f(t,<states>, <inputs>) * dt + g(t, <states>, <inputs>) * dw","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addSystem(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula specifying stochastic differential equation ... additional formulas similar form specifying multiple equations .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-addobs-","dir":"Reference","previous_headings":"","what":"Method addObs()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Define algebraic observation equations form <observation> ~ h(t, <states>, <inputs>) + e) h observation function, e normally distributed noise zero mean. function specifies observation name, mean h.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addObs(form, ..., obsnames = NULL)"},{"path":"/reference/ctsmTMB.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula specifying observation equation ... additional formulas similar form specifying multiple equations . obsnames character vector specifying name observation. used left-hand side form consists just single variable (class 'call').","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setvariance-","dir":"Reference","previous_headings":"","what":"Method setVariance()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Specify variance observation equation. defined observation variable y e.g. addObs(y ~  h(t,<states>,<inputs>) perturbed Gaussian noise zero mean variance -specified using setVariance(y ~ p(t,<states>,<inputs>). can instance declare setVariance(y ~ sigma_x^2 sigma_x fixed effect parameter declared setParameter.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setVariance(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula class specifying observation equation added system. ... additional formulas identical form specify multiple observation equations time.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-addinput-","dir":"Reference","previous_headings":"","what":"Method addInput()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare variables data inputs Declare whether variable contained system, observation observation variance equations input variable. e.g. system equation contains input variable u declared using addInput(u). input u must contained data.frame .data provided calling estimate predict methods.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addInput(...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"... variable names specifies name input variables defined system.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setparameter-","dir":"Reference","previous_headings":"","what":"Method setParameter()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer guess, well lower / upper bounds optimization. two ways declare parameters: can declare parameters using formulas .e. setParameter(  theta = c(1,0,10), mu = c(0,-10,10) ). first value initial value optimizer, second value lower optimization bound third value upper optimization bound. can provide 3-column matrix rows corresponds different parameters, parameter names provided rownames matrix. columns values corresponds description vector format .","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setParameter(...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"... named vector matrix described .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setalgebraics-","dir":"Reference","previous_headings":"","what":"Method setAlgebraics()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Add algebraic relations. Algebraic relations convenient way transform parameters equations. Ornstein-Uhlenbeck process rate parameter theta always positive, estimation log-domain good idea. Instead writing exp(theta) directly system equation one can transform log domain using algebraic relation setAlgebraics(theta ~ exp(logtheta)). instances theta replaced exp(logtheta) compiling C++ function. Note must provide values logtheta now instead theta declaring parameters setParameter","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setAlgebraics(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form algebraic formula ... additional formulas","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setinitialstate-","dir":"Reference","previous_headings":"","what":"Method setInitialState()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setInitialState(initial.state)"},{"path":"/reference/ctsmTMB.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setinitialvariancescaling-","dir":"Reference","previous_headings":"","what":"Method setInitialVarianceScaling()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"scalar value multiplied onto estimated initial state covariance matrix. scaling applied initial state/cov estimated, set user.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setInitialVarianceScaling(scaling)"},{"path":"/reference/ctsmTMB.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"scaling numeric scalar value.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setlamperti-","dir":"Reference","previous_headings":"","what":"Method setLamperti()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set Lamperti Transformation provided system equations state dependent diffusion available ways advantageous perform transformation remove state dependence. comes cost complicated drift function. following types state-dependence currently supported 'identity' - diffusion state-independent (default) 'log' - diffusion proportional x * dw 'logit' - diffusion proportional x * (1-x) * dw 'sqrt-logit' - diffusion proportional sqrt(x * (1-x)) * dw","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setLamperti(transforms, states = NULL)"},{"path":"/reference/ctsmTMB.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"transforms character vector - one either \"identity, \"log\", \"logit\", \"sqrt-logit\" states vector state names specified transformations applied .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setmodelname-","dir":"Reference","previous_headings":"","what":"Method setModelname()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set modelname used create C++ file TMB calling TMB::MakeADFun (negative log) likelihood function created directory specified setCppfilesDirectory method name <modelname>.cpp","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setModelname(name)"},{"path":"/reference/ctsmTMB.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"name string defining model name.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setmap-","dir":"Reference","previous_headings":"","what":"Method setMAP()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Enable maximum posterior (MAP) estimation. Adds maximum posterior contribution (negative log) likelihood function  evaluating fixed effects parameters multivariate Gaussian mean covariance provided.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setMAP(mean, cov)"},{"path":"/reference/ctsmTMB.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"mean mean vector Gaussian prior parameter distribution cov covariance matrix Gaussian prior parameter distribution","code":""},{"path":"/reference/ctsmTMB.html","id":"method-getsystems-","dir":"Reference","previous_headings":"","what":"Method getSystems()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve system equations.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getSystems()"},{"path":"/reference/ctsmTMB.html","id":"method-getobservations-","dir":"Reference","previous_headings":"","what":"Method getObservations()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve observation equations.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getObservations()"},{"path":"/reference/ctsmTMB.html","id":"method-getvariances-","dir":"Reference","previous_headings":"","what":"Method getVariances()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve observation variances","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getVariances()"},{"path":"/reference/ctsmTMB.html","id":"method-getalgebraics-","dir":"Reference","previous_headings":"","what":"Method getAlgebraics()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve algebraic relations","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getAlgebraics()"},{"path":"/reference/ctsmTMB.html","id":"method-getinitialstate-","dir":"Reference","previous_headings":"","what":"Method getInitialState()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getInitialState()"},{"path":"/reference/ctsmTMB.html","id":"method-getparameters-","dir":"Reference","previous_headings":"","what":"Method getParameters()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Get initial (estimated) parameters.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getParameters(type = \"all\", value = \"all\")"},{"path":"/reference/ctsmTMB.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"type one \"\", free\" \"fixed\" parameters. value one \"\", initial\", \"estimate\", \"lower\" \"upper\"","code":""},{"path":"/reference/ctsmTMB.html","id":"method-getestimate-","dir":"Reference","previous_headings":"","what":"Method getEstimate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getEstimate()"},{"path":"/reference/ctsmTMB.html","id":"method-getlikelihood-","dir":"Reference","previous_headings":"","what":"Method getLikelihood()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getLikelihood()"},{"path":"/reference/ctsmTMB.html","id":"method-getprediction-","dir":"Reference","previous_headings":"","what":"Method getPrediction()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getPrediction()"},{"path":"/reference/ctsmTMB.html","id":"method-getsimulation-","dir":"Reference","previous_headings":"","what":"Method getSimulation()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getSimulation()"},{"path":"/reference/ctsmTMB.html","id":"method-estimate-","dir":"Reference","previous_headings":"","what":"Method estimate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Estimate fixed effects parameters specified model.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$estimate(   data,   method = \"ekf\",   ode.solver = \"euler\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = NULL,   control = list(trace = 1, iter.max = 1e+05, eval.max = 1e+05),   use.hessian = FALSE,   laplace.residuals = FALSE,   unconstrained.optim = FALSE,   estimate.initial.state = FALSE,   silent = FALSE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector specifying filtering method used state/likelihood calculations. Must one either \"lkf\", \"ekf\", \"laplace\". ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residuals natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approximation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 control list control parameters parsed nlminb control argument. See ?stats::nlminb information use.hessian boolean value. default (TRUE) causes optimization algorithm stats::nlminb use fixed effects hessian (negative log) likelihood performing optimization. feature available kalman filter methods without random effects. laplace.residuals boolean - whether calculate one-step ahead residuals using method oneStepPredict. unconstrained.optim boolean value. TRUE optimization carried unconstrained .e. without parameter bounds specified setParameter. estimate.initial.state boolean value. TRUE initial state covariance matrices estimated stationary solution linearized mean covariance differential equations. system contains time-varying inputs, first element used. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-likelihood-","dir":"Reference","previous_headings":"","what":"Method likelihood()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Construct extract function handlers negative log likelihood function. handlers TMB's MakeADFun constructed returned. enables user e.g. choose optimization algorithm, just control optimization workflow.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$likelihood(   data,   method = \"ekf\",   ode.solver = \"euler\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = NULL,   estimate.initial.state = FALSE,   silent = FALSE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector specifying filtering method used state/likelihood calculations. Must one either \"lkf\", \"ekf\", \"laplace\". ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep time-step used filtering schemes. time-step two different uses depending chosen method. Kalman Filters: time-step used numerically solving moment differential equations. Laplace Approximation: time-step used Euler-Maruyama simulation scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residuals natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approximation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 estimate.initial.state boolean value. TRUE initial state covariance matrices estimated stationary solution linearized mean covariance differential equations. system contains time-varying inputs, first element used. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-predict-","dir":"Reference","previous_headings":"","what":"Method predict()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$predict(   data,   pars = NULL,   method = \"ekf\",   ode.solver = \"euler\",   ode.timestep = diff(data$t),   k.ahead = nrow(data) - 1,   return.k.ahead = 0:k.ahead,   return.covariance = TRUE,   initial.state = self$getInitialState(),   estimate.initial.state = private$estimate.initial,   silent = FALSE,   use.cpp = FALSE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate function run, default values found optimum. method prediction method ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. return.covariance boolean value indicate whether covariance (instead correlation) returned. initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate.initial.state bool - stationary estimation initial mean covariance silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. use.cpp boolean indicate whether use C++ perform calculations","code":""},{"path":"/reference/ctsmTMB.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-simulate-","dir":"Reference","previous_headings":"","what":"Method simulate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-26","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$simulate(   data,   pars = NULL,   use.cpp = FALSE,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   simulation.timestep = diff(data$t),   k.ahead = nrow(data) - 1,   return.k.ahead = 0:k.ahead,   n.sims = 100,   initial.state = self$getInitialState(),   estimate.initial.state = private$estimate.initial,   silent = FALSE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate function run, default values found optimum. use.cpp boolean indicate whether use C++ perform calculations method natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continuous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continuous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute Jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. simulation.timestep timestep used euler-maruyama scheme k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. n.sims number simulations initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate.initial.state bool - stationary estimation initial mean covariance silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. return.covariance boolean value indicate whether covariance (instead correlation) returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Function print model object","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-27","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$print()"},{"path":"/reference/ctsmTMB.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"objects class cloneable method.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-28","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$clone(deep = FALSE)"},{"path":"/reference/ctsmTMB.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"deep Whether make deep clone.","code":""},{"path":"/reference/ctsmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # adding a single system equations model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw)  # adding an observation equation and setting variance model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2)  # add model input model$addInput(u)  # add parameters model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 )  # set the model initial state model$setInitialState(list(1,1e-1))  # extract the likelihood handlers nll <- model$likelihood(data=Ornstein) #> Building model... #> Checking data... #> Constructing objective function... #> ...took: 0.093 seconds. #> Succesfully returned function handlers  # calculate likelihood, gradient and hessian w.r.t parameters nll$fn(nll$par) #> [1] 159.3085 nll$gr(nll$par) #>          [,1]      [,2]      [,3] #> [1,] 30.81298 -38.65746 -170.1326 nll$he(nll$par) #>           [,1]      [,2]      [,3] #> [1,]  46.88374 -66.66397 -61.73576 #> [2,] -66.66397  19.99982  77.31402 #> [3,] -61.73576  77.31402 908.18058  # estimate the parameters using an extended kalman filter fit <- model$estimate(data=Ornstein) #> Checking data... #> Minimizing the negative log-likelihood... #>   0:     159.30847:  1.00000  1.50000  1.00000 #>   1:     154.15990: 0.826082  1.71820  1.96028 #>   2:     136.01211: 0.614019  2.04466  1.64652 #>   3:     129.29879: 0.625113  2.06221  1.47868 #>   4:     128.42258: 0.666452  2.12632  1.14915 #>   5:     122.27008: 0.825282  2.37200  1.31892 #>   6:     106.61489:  1.59116  3.48574  1.25982 #>   7:     101.72505:  2.18624  3.49501  1.18917 #>   8:     99.610055:  2.43782  3.00283 0.957522 #>   9:     91.160123:  3.00760  2.93833  1.13182 #>  10:     87.333934:  3.60427  2.95994  1.07975 #>  11:     86.392347:  3.62036  3.05856  1.06026 #>  12:     85.804273:  4.02690  3.03800  1.04788 #>  13:     85.776558:  4.04412  3.02977  1.06498 #>  14:     85.771776:  4.04182  3.03209  1.06035 #>  15:     85.771772:  4.04188  3.03208  1.06018 #>  16:     85.771772:  4.04186  3.03210  1.06019 #>  17:     85.771772:  4.04186  3.03210  1.06019 #> \t Optimization finished!: #>             Elapsed time: 0.007 seconds. #>             The objective value is: 8.577177e+01 #>             The maximum gradient component is: 2.7e-05 #>             The convergence message is: relative convergence (4) #>             Iterations: 17 #>             Evaluations: Fun: 25 Grad: 18 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # perform moment predictions pred <- model$predict(data=Ornstein) #> Checking data... #> Predicting with R... #> Returning results... #> Finished!  # perform stochatic simulations sim <- model$simulate(data=Ornstein, n.sims=10) #> Checking data... #> Simulating with R... #> Constructing return data.frame... #> Finished."},{"path":"/reference/plot.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"function creates residual plots estimated ctsmTMB object","code":""},{"path":"/reference/plot.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit plot(   x,   print.plot = 1,   type = \"residuals\",   state.type = \"prior\",   against.obs = NULL,   ggtheme = getggplot2theme(),   ... )"},{"path":"/reference/plot.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"x R6 ctsmTMB fit object print.plot single integer determining element states/observations (depending argument type). type character vector either 'residuals' 'states' determining plot. state.type character vector either 'prior', 'posterior' 'smoothed' determining kind states plot. .obs name observation plot state predictions . ggtheme ggplot2 theme use creating ggplot. ... additional arguments","code":""},{"path":"/reference/plot.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"(list ) ggplot residual plot(s)","code":""},{"path":"/reference/plot.ctsmTMB.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Building model... #> Checking data... #> Constructing objective function and derivative tables... #> ...took: 0.084 seconds. #> Minimizing the negative log-likelihood... #>   0:     159.30847:  1.00000  1.50000  1.00000 #>   1:     154.15990: 0.826082  1.71820  1.96028 #>   2:     136.01211: 0.614019  2.04466  1.64652 #>   3:     129.29879: 0.625113  2.06221  1.47868 #>   4:     128.42258: 0.666452  2.12632  1.14915 #>   5:     122.27008: 0.825282  2.37200  1.31892 #>   6:     106.61489:  1.59116  3.48574  1.25982 #>   7:     101.72505:  2.18624  3.49501  1.18917 #>   8:     99.610055:  2.43782  3.00283 0.957522 #>   9:     91.160123:  3.00760  2.93833  1.13182 #>  10:     87.333934:  3.60427  2.95994  1.07975 #>  11:     86.392347:  3.62036  3.05856  1.06026 #>  12:     85.804273:  4.02690  3.03800  1.04788 #>  13:     85.776558:  4.04412  3.02977  1.06498 #>  14:     85.771776:  4.04182  3.03209  1.06035 #>  15:     85.771772:  4.04188  3.03208  1.06018 #>  16:     85.771772:  4.04186  3.03210  1.06019 #>  17:     85.771772:  4.04186  3.03210  1.06019 #> \t Optimization finished!: #>             Elapsed time: 0.006 seconds. #>             The objective value is: 8.577177e+01 #>             The maximum gradient component is: 2.7e-05 #>             The convergence message is: relative convergence (4) #>             Iterations: 17 #>             Evaluations: Fun: 25 Grad: 18 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # plot residuals plot(fit) #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database #> Warning: font family 'Avenir Next Condensed' not found in PostScript font database   # plot filtered states plot(fit, type=\"states\", against=\"y\")"},{"path":"/reference/plot.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","text":"function creates residual plots estimated ctsmTMB object","code":""},{"path":"/reference/plot.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","text":"","code":"# S3 method for ctsmTMB plot(x, plot.obs = 1, ggtheme = getggplot2theme(), ...)"},{"path":"/reference/plot.ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","text":"x R6 ctsmTMB object plot.obs vector integers indicate observations plotted. multiple requested list plots, one observation returned instead. ggtheme ggplot2 theme use creating ggplot. ... additional arguments","code":""},{"path":"/reference/plot.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","text":"(list ) ggplot residual plot(s)","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"Plot k-step predictions ctsmTMB prediction object","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"","code":"# S3 method for ctsmTMB.pred plot(   x,   y,   k.ahead = unique(x[[\"states\"]][[\"k.ahead\"]]),   state.name = NULL,   type = \"states\",   against = NULL,   ... )"},{"path":"/reference/plot.ctsmTMB.pred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"x ctsmTMB.pred object y used k.ahead integer indicating k-ahead predictions plot state.name string indicating states plot type one 'states' 'observations', plot name observations plot predictions ... additional arguments","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"plot predicted states","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Building model... #> Checking data... #> Constructing objective function and derivative tables... #> ...took: 0.09 seconds. #> Minimizing the negative log-likelihood... #>   0:     159.30847:  1.00000  1.50000  1.00000 #>   1:     154.15990: 0.826082  1.71820  1.96028 #>   2:     136.01211: 0.614019  2.04466  1.64652 #>   3:     129.29879: 0.625113  2.06221  1.47868 #>   4:     128.42258: 0.666452  2.12632  1.14915 #>   5:     122.27008: 0.825282  2.37200  1.31892 #>   6:     106.61489:  1.59116  3.48574  1.25982 #>   7:     101.72505:  2.18624  3.49501  1.18917 #>   8:     99.610055:  2.43782  3.00283 0.957522 #>   9:     91.160123:  3.00760  2.93833  1.13182 #>  10:     87.333934:  3.60427  2.95994  1.07975 #>  11:     86.392347:  3.62036  3.05856  1.06026 #>  12:     85.804273:  4.02690  3.03800  1.04788 #>  13:     85.776558:  4.04412  3.02977  1.06498 #>  14:     85.771776:  4.04182  3.03209  1.06035 #>  15:     85.771772:  4.04188  3.03208  1.06018 #>  16:     85.771772:  4.04186  3.03210  1.06019 #>  17:     85.771772:  4.04186  3.03210  1.06019 #> \t Optimization finished!: #>             Elapsed time: 0.006 seconds. #>             The objective value is: 8.577177e+01 #>             The maximum gradient component is: 2.7e-05 #>             The convergence message is: relative convergence (4) #>             Iterations: 17 #>             Evaluations: Fun: 25 Grad: 18 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # perform moment predictions pred <- model$predict(Ornstein) #> Checking data... #> Predicting with R... #> Returning results... #> Finished!  # plot the k.ahead=10 predictions plot(pred, against=\"y.data\")    # plot filtered states plot(fit, type=\"states\", against=\"y\")"},{"path":"/reference/plot.ctsmTMB.profile.html","id":null,"dir":"Reference","previous_headings":"","what":"#' Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","title":"#' Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","text":"#' Plot profile likelihood ctsmTMB object","code":""},{"path":"/reference/plot.ctsmTMB.profile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"#' Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","text":"","code":"# S3 method for ctsmTMB.profile plot(x, y, include.opt = TRUE, ...)"},{"path":"/reference/plot.ctsmTMB.profile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"#' Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","text":"x profile.ctsmTMB object y use include.opt boolean indicates whether include total likelihood optimizer plot. ... additional arguments","code":""},{"path":"/reference/plot.ctsmTMB.profile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"#' Plot a profile likelihood ctsmTMB object — plot.ctsmTMB.profile","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Building model... #> Checking data... #> Constructing objective function and derivative tables... #> ...took: 0.089 seconds. #> Minimizing the negative log-likelihood... #>   0:     159.30847:  1.00000  1.50000  1.00000 #>   1:     154.15990: 0.826082  1.71820  1.96028 #>   2:     136.01211: 0.614019  2.04466  1.64652 #>   3:     129.29879: 0.625113  2.06221  1.47868 #>   4:     128.42258: 0.666452  2.12632  1.14915 #>   5:     122.27008: 0.825282  2.37200  1.31892 #>   6:     106.61489:  1.59116  3.48574  1.25982 #>   7:     101.72505:  2.18624  3.49501  1.18917 #>   8:     99.610055:  2.43782  3.00283 0.957522 #>   9:     91.160123:  3.00760  2.93833  1.13182 #>  10:     87.333934:  3.60427  2.95994  1.07975 #>  11:     86.392347:  3.62036  3.05856  1.06026 #>  12:     85.804273:  4.02690  3.03800  1.04788 #>  13:     85.776558:  4.04412  3.02977  1.06498 #>  14:     85.771776:  4.04182  3.03209  1.06035 #>  15:     85.771772:  4.04188  3.03208  1.06018 #>  16:     85.771772:  4.04186  3.03210  1.06019 #>  17:     85.771772:  4.04186  3.03210  1.06019 #> \t Optimization finished!: #>             Elapsed time: 0.006 seconds. #>             The objective value is: 8.577177e+01 #>             The maximum gradient component is: 2.7e-05 #>             The convergence message is: relative convergence (4) #>             Iterations: 17 #>             Evaluations: Fun: 25 Grad: 18 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # calculate profile likelihood out <- profile(fit,parlist=list(theta=NULL)) #> Iteration: 1 / 10  #> Iteration: 2 / 10  #> Iteration: 3 / 10  #> Iteration: 4 / 10  #> Iteration: 5 / 10  #> Iteration: 6 / 10  #> Iteration: 7 / 10  #> Iteration: 8 / 10  #> Iteration: 9 / 10  #> Iteration: 10 / 10   # plot profile plot(out)"},{"path":"/reference/print.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"Basic print objects ctsmTMB fit objects","code":""},{"path":"/reference/print.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit print(x, ...)"},{"path":"/reference/print.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"x ctsmTMB fit object ... additional arguments","code":""},{"path":"/reference/print.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"Print ctsmTMB fit object","code":""},{"path":"/reference/print.ctsmTMB.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Building model... #> Checking data... #> Constructing objective function and derivative tables... #> ...took: 0.087 seconds. #> Minimizing the negative log-likelihood... #>   0:     159.30847:  1.00000  1.50000  1.00000 #>   1:     154.15990: 0.826082  1.71820  1.96028 #>   2:     136.01211: 0.614019  2.04466  1.64652 #>   3:     129.29879: 0.625113  2.06221  1.47868 #>   4:     128.42258: 0.666452  2.12632  1.14915 #>   5:     122.27008: 0.825282  2.37200  1.31892 #>   6:     106.61489:  1.59116  3.48574  1.25982 #>   7:     101.72505:  2.18624  3.49501  1.18917 #>   8:     99.610055:  2.43782  3.00283 0.957522 #>   9:     91.160123:  3.00760  2.93833  1.13182 #>  10:     87.333934:  3.60427  2.95994  1.07975 #>  11:     86.392347:  3.62036  3.05856  1.06026 #>  12:     85.804273:  4.02690  3.03800  1.04788 #>  13:     85.776558:  4.04412  3.02977  1.06498 #>  14:     85.771776:  4.04182  3.03209  1.06035 #>  15:     85.771772:  4.04188  3.03208  1.06018 #>  16:     85.771772:  4.04186  3.03210  1.06019 #>  17:     85.771772:  4.04186  3.03210  1.06019 #> \t Optimization finished!: #>             Elapsed time: 0.006 seconds. #>             The objective value is: 8.577177e+01 #>             The maximum gradient component is: 2.7e-05 #>             The convergence message is: relative convergence (4) #>             Iterations: 17 #>             Evaluations: Fun: 25 Grad: 18 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # print fit print(fit) #> Coefficent Matrix  #>         Estimate Std. Error t value  Pr(>|t|)     #> theta   4.041864   0.382792  10.559 < 2.2e-16 *** #> mu      3.032097   0.059965  50.564 < 2.2e-16 *** #> sigma_x 1.060189   0.053072  19.976 < 2.2e-16 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"},{"path":"/reference/print.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of ctsmTMB objects — print.ctsmTMB","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"Basic print ctsmTMB objects","code":""},{"path":"/reference/print.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"","code":"# S3 method for ctsmTMB print(x, ...)"},{"path":"/reference/print.ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"x object class 'ctsmTMB' ... additional arguments (use)","code":""},{"path":"/reference/print.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"Print ctsmTMB model object","code":""},{"path":"/reference/print.ctsmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # print empty model print(model) #> ctsmTMB model object:               #> States       0 #> Diffusions   0 #> Observations 0 #> Inputs       0 #> Parameters   0  # add elements to model and see new print model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) print(model) #> ctsmTMB model object:               #> States       1 #> Diffusions   1 #> Observations 1 #> Inputs       1 #> Parameters   4 #>  #> System Equations: #>  #> \t dx ~ theta * (mu + u - x) * dt + sigma_x * dw  #>  #> Observation Equations: #>  #> \t y:  y ~ x + e \t e ~ N(0, sigma_y^2)  #>  #>  #> Free Parameters: #> \t theta, mu, sigma_x #>  #> Fixed Parameters: #> \t sigma_y"},{"path":"/reference/profile.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"#' Performs full multi-dimensional profile likelihood calculations","code":""},{"path":"/reference/profile.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit profile(   fitted,   parlist,   grid.size = rep(10, length(parlist)),   grid.qnt = rep(3, length(parlist)),   hessian = FALSE,   silent = FALSE,   control = list(trace = 0, iter.max = 1000, eval.max = 1000),   ... )"},{"path":"/reference/profile.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"fitted ctmsTMB fit object parlist named-list parameters profile . user can either supply grid-values list leave empty. one list empty grid-values calculated using estimated parameter mean value standard deviation. grid.size vector length(parlist) indicating number grid-points along parameter direction. used parlist empty. grid.qnt vector length(parlist) determining width grid points mean value multiples standard deviation. hessian boolean indicating whether use hessian profile optimization. silent boolean whether mute current iteration number control argument. control list optimization output controls (see nlminb) ... various arguments (use)","code":""},{"path":"/reference/profile.ctsmTMB.fit.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"implementation modified https://github.com/kaskr/adcomp/blob/master/TMB/R/tmbprofile.R","code":""},{"path":"/reference/profile.ctsmTMB.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Building model... #> Checking data... #> Constructing objective function and derivative tables... #> ...took: 0.087 seconds. #> Minimizing the negative log-likelihood... #>   0:     159.30847:  1.00000  1.50000  1.00000 #>   1:     154.15990: 0.826082  1.71820  1.96028 #>   2:     136.01211: 0.614019  2.04466  1.64652 #>   3:     129.29879: 0.625113  2.06221  1.47868 #>   4:     128.42258: 0.666452  2.12632  1.14915 #>   5:     122.27008: 0.825282  2.37200  1.31892 #>   6:     106.61489:  1.59116  3.48574  1.25982 #>   7:     101.72505:  2.18624  3.49501  1.18917 #>   8:     99.610055:  2.43782  3.00283 0.957522 #>   9:     91.160123:  3.00760  2.93833  1.13182 #>  10:     87.333934:  3.60427  2.95994  1.07975 #>  11:     86.392347:  3.62036  3.05856  1.06026 #>  12:     85.804273:  4.02690  3.03800  1.04788 #>  13:     85.776558:  4.04412  3.02977  1.06498 #>  14:     85.771776:  4.04182  3.03209  1.06035 #>  15:     85.771772:  4.04188  3.03208  1.06018 #>  16:     85.771772:  4.04186  3.03210  1.06019 #>  17:     85.771772:  4.04186  3.03210  1.06019 #> \t Optimization finished!: #>             Elapsed time: 0.006 seconds. #>             The objective value is: 8.577177e+01 #>             The maximum gradient component is: 2.7e-05 #>             The convergence message is: relative convergence (4) #>             Iterations: 17 #>             Evaluations: Fun: 25 Grad: 18 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # calculate profile likelihood out <- profile(fit,parlist=list(theta=NULL)) #> Iteration: 1 / 10  #> Iteration: 2 / 10  #> Iteration: 3 / 10  #> Iteration: 4 / 10  #> Iteration: 5 / 10  #> Iteration: 6 / 10  #> Iteration: 7 / 10  #> Iteration: 8 / 10  #> Iteration: 9 / 10  #> Iteration: 10 / 10"},{"path":"/reference/setAlgebraics.html","id":null,"dir":"Reference","previous_headings":"","what":"Add algebraic relationships to the model object. — setAlgebraics","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"Algebraic relations convenient way transform parameters equations, reduce clutter specifying various equations, instance ensure positivity (log-transform).","code":""},{"path":"/reference/setAlgebraics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"","code":"setAlgebraics(form, ...)"},{"path":"/reference/setAlgebraics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"form formula specifying algebraic relation. ... formulas similar form, used allow specifying multiple formulas comma-separation rather providing list.","code":""},{"path":"/reference/setAlgebraics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"left-hand side provided formula specifies parameter overwritten expression right-hand side. also means left-hand side parameter vanish model formulation link{setParameter} therefore specify values new parameters.","code":""},{"path":"/reference/setInitialState.html","id":null,"dir":"Reference","previous_headings":"","what":"Set initial state mean and covariance — setInitialState","title":"Set initial state mean and covariance — setInitialState","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/setInitialState.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set initial state mean and covariance — setInitialState","text":"","code":"setInitialState(initial.state)"},{"path":"/reference/setInitialState.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set initial state mean and covariance — setInitialState","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state","code":""},{"path":"/reference/setParameter.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify parameters in the model object — setParameter","title":"Specify parameters in the model object — setParameter","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer values, well lower / upper bounds. Parameters can declared either vectors matrices. first entry initial value, second entry lower bound third entry upper bound. Providing first entry fixes particular parameter value.","code":""},{"path":"/reference/setParameter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify parameters in the model object — setParameter","text":"","code":"setParameter(...)"},{"path":"/reference/setParameter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify parameters in the model object — setParameter","text":"... comma-separated series vectors/matrix entries","code":""},{"path":"/reference/setVariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Add observation variances to the model object. — setVariance","title":"Add observation variances to the model object. — setVariance","text":"Specify observation variance existing observation equation.","code":""},{"path":"/reference/setVariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add observation variances to the model object. — setVariance","text":"","code":"setVariance(form, ...)"},{"path":"/reference/setVariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add observation variances to the model object. — setVariance","text":"form formula class specifying observation equation added system. ... formulas similar form, used allow specifying multiple formulas comma-separation rather providing list.","code":""},{"path":"/reference/summary.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"Basic summary ctsmTMB fit object","code":""},{"path":"/reference/summary.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit summary(object, correlation = FALSE, ...)"},{"path":"/reference/summary.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"object ctsmTMB fit object correlation boolean indicating whether display parameter correlation structure ... additional arguments","code":""},{"path":"/reference/summary.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"summary estimated ctsmTMB model fit","code":""},{"path":"/reference/summary.ctsmTMB.fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"","code":"library(ctsmTMB) model <- ctsmTMB$new()  # create model model$addSystem(dx ~ theta * (mu+u-x) * dt + sigma_x*dw) model$addObs(y ~ x) model$setVariance(y ~ sigma_y^2) model$addInput(u) model$setParameter(   theta   = c(initial = 1, lower=1e-5, upper=50),   mu      = c(initial=1.5, lower=0, upper=5),   sigma_x = c(initial=1, lower=1e-10, upper=30),   sigma_y = 1e-2 ) model$setInitialState(list(1,1e-1))  # fit model to data fit <- model$estimate(Ornstein) #> Building model... #> Checking data... #> Constructing objective function and derivative tables... #> ...took: 0.087 seconds. #> Minimizing the negative log-likelihood... #>   0:     159.30847:  1.00000  1.50000  1.00000 #>   1:     154.15990: 0.826082  1.71820  1.96028 #>   2:     136.01211: 0.614019  2.04466  1.64652 #>   3:     129.29879: 0.625113  2.06221  1.47868 #>   4:     128.42258: 0.666452  2.12632  1.14915 #>   5:     122.27008: 0.825282  2.37200  1.31892 #>   6:     106.61489:  1.59116  3.48574  1.25982 #>   7:     101.72505:  2.18624  3.49501  1.18917 #>   8:     99.610055:  2.43782  3.00283 0.957522 #>   9:     91.160123:  3.00760  2.93833  1.13182 #>  10:     87.333934:  3.60427  2.95994  1.07975 #>  11:     86.392347:  3.62036  3.05856  1.06026 #>  12:     85.804273:  4.02690  3.03800  1.04788 #>  13:     85.776558:  4.04412  3.02977  1.06498 #>  14:     85.771776:  4.04182  3.03209  1.06035 #>  15:     85.771772:  4.04188  3.03208  1.06018 #>  16:     85.771772:  4.04186  3.03210  1.06019 #>  17:     85.771772:  4.04186  3.03210  1.06019 #> \t Optimization finished!: #>             Elapsed time: 0.006 seconds. #>             The objective value is: 8.577177e+01 #>             The maximum gradient component is: 2.7e-05 #>             The convergence message is: relative convergence (4) #>             Iterations: 17 #>             Evaluations: Fun: 25 Grad: 18 #>             See stats::nlminb for available tolerance/control arguments. #> Returning results... #> Finished!  # print model summary summary(fit, correlation=TRUE) #> Coefficent Matrix  #>         Estimate Std. Error t value  Pr(>|t|)     #> theta   4.041864   0.382792  10.559 < 2.2e-16 *** #> mu      3.032097   0.059965  50.564 < 2.2e-16 *** #> sigma_x 1.060189   0.053072  19.976 < 2.2e-16 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Correlation Matrix #>         theta mu    sigma_x #> theta    1.00               #> mu      -0.21  1.00         #> sigma_x  0.00  0.00  1.00"},{"path":"/reference/summary.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"Basic summary objects class 'ctsmTMB'","code":""},{"path":"/reference/summary.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"","code":"# S3 method for ctsmTMB summary(object, correlation = FALSE, ...)"},{"path":"/reference/summary.ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"object R6 ctsmTMB model object correlation boolean indicate whether return parameter correlations ... additional arguments","code":""},{"path":"/reference/summary.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"summary model object","code":""},{"path":"/news/index.html","id":"ctsmtmb-100","dir":"Changelog","previous_headings":"","what":"ctsmTMB 1.0.0","title":"ctsmTMB 1.0.0","text":"first release package","code":""}]
