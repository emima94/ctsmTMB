[{"path":"/articles/ctsmTMB.html","id":"initialising","dir":"Articles","previous_headings":"","what":"Initialising","title":"Getting Started","text":"initialise ctsmTMB model object using set model name, used generate underlying C++ files default files saved directory called ctsmTMB_cppfiles current working directory. files can stored another location specifying another directory : Now object created let us first inspect ’s printout: see model called sde_model (default), states, diffusions, observations, inputs parameters currently registered. name used name C++ file created locally, later recognize compiled model object.","code":"library(ctsmTMB) obj = ctsmTMB$new() obj$setModelname(\"getting_started_model\") obj$setCppfilesDirectory(\"some_path_to_a_directory\") print(obj) ## Stochastic State Space Model:                                   ## Name         getting_started_model ## States                           0 ## Diffusions                       0 ## Observations                     0 ## Inputs                           0 ## Parameters                       0"},{"path":"/articles/ctsmTMB.html","id":"add-system-equations","dir":"Articles","previous_headings":"","what":"Add system equations","title":"Getting Started","text":"can begin adding desired stochastic differential equation object. note drift term ends *dt diffusions specified dw dw# # can sequence numbers.","code":"obj$addSystem(dX ~ theta * (mu - X) * dt + sigma_x * dw)"},{"path":"/articles/ctsmTMB.html","id":"add-observation-equations","dir":"Articles","previous_headings":"","what":"Add observation equations","title":"Getting Started","text":"must also add observation equation. observations associated Y data also named Y.","code":"obj$addObs(Y ~ X)"},{"path":"/articles/ctsmTMB.html","id":"add-observation-variances","dir":"Articles","previous_headings":"","what":"Add observation variances","title":"Getting Started","text":"every observation variable must also specify variance normally distributed residuals observation equation variable name left-hand side formula must match name previously defined via add_observations, variance associated observation equation. Let’s inspect model object now specified one state \\(X\\) observation \\(Y\\). diffusions count number \\(\\mathrm{d}\\omega_{}\\) terms. single equation can multiple diffusion terms .e. sigma_1 * dw1 + sigma_2*dw2). also note inputs parameter specified yet.","code":"obj$setVariance(Y ~ sigma_y^2*U) print(obj) ## Stochastic State Space Model:                                   ## Name         getting_started_model ## States                           1 ## Diffusions                       1 ## Observations                     1 ## Inputs                           0 ## Parameters                       0 ##  ## System Equations: ##  ##   dX ~ theta * (mu - X) * dt + sigma_x * dw  ##  ## Observation Equations: ##  ##   Y:  Y ~ X + e   e ~ N(0, sigma_y^2 * U)"},{"path":"/articles/ctsmTMB.html","id":"add-inputs","dir":"Articles","previous_headings":"","what":"Add inputs","title":"Getting Started","text":"tell model variable names inputs via input values provided data, name, similar observations.","code":"obj$addInput(U)"},{"path":"/articles/ctsmTMB.html","id":"add-parameters","dir":"Articles","previous_headings":"","what":"Add parameters","title":"Getting Started","text":"must also specify (fixed effects) parameters, together initial value lower/upper bound, optimization. can fix parameter value (parameter becomes constant) supplying just single value. usually difficult identify noise parameters \\(\\left(\\sigma_{X},\\sigma_{Y}\\right)\\) practice, lets assume want fix \\(\\sigma_{Y}\\). done via Let’s inspect model object , see inputs parameters (non-fixed fixed) registered.","code":"obj$setParameter(   theta   = c(initial = 5,    lower = 0,    upper = 20),   mu      = c(initial = 0,    lower = -10,  upper = 10),   sigma_x = c(initial = 1e-1, lower = 1e-5, upper = 5),   sigma_y = c(initial = 1e-1, lower = 1e-5, upper = 5) ) obj$setParameter(   sigma_y  = 1e-1 ) print(obj) ## Stochastic State Space Model:                                   ## Name         getting_started_model ## States                           1 ## Diffusions                       1 ## Observations                     1 ## Inputs                           1 ## Parameters                       4 ##  ## System Equations: ##  ##   dX ~ theta * (mu - X) * dt + sigma_x * dw  ##  ## Observation Equations: ##  ##   Y:  Y ~ X + e   e ~ N(0, sigma_y^2 * U)  ##  ##  ## Fixed Parameters: ##   sigma_y"},{"path":"/articles/ctsmTMB.html","id":"set-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set initial state and covariance","title":"Getting Started","text":"last thing can perform estimation set initial value state(s) associated (co)variance. two inputs adequate since assume normally distributed state. choice value reflect ones belief initial state, often ballpark figure. Note use diag construct 1x1 matrix covariance, required method.","code":"obj$setInitialState(list(mean=3, cov=1e-1*diag(1)))"},{"path":"/articles/ctsmTMB.html","id":"fit-model-parameters-to-data","dir":"Articles","previous_headings":"","what":"Fit model parameters to data","title":"Getting Started","text":"now ready perform state filtration parameter estimation. first construct fake data simulating paths Ornstein-Uhlenbeck process using Euler-Maruyama scheme. data must contain time column named t columns specified inputs observations. pass data estimate method. method build compile generated C++ function negative log-likelihood, check supplied data contains necessary variables, construct objective function (computational tree must build automatic differentiation) start optimization. output generated optimization objective (negativ log-likelihood) value parameter values current step. optimizer used package stats::nlminb. optimizer great robustness ability use objective function hessian unlike e.g. ‘stats::optim’","code":"# Choosing parameters set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1  # Creating simulation path dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations from simulation and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data.frame data = data.frame(   t = t.obs,   Y = y,   U = c(rep(c(1,2),times=round(length(y)/2)),1) ) fit = obj$estimate(data) ## Building model... ## Compiling model... ## Note: Using Makevars in /Users/pbrve/.R/Makevars ## using C++ compiler: 'Apple clang version 15.0.0 (clang-1500.3.9.4)' ## using SDK: 'MacOSX14.4.sdk' ## ...took 11.06 seconds ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.043 seconds. ## Minimizing the negative log-likelihood... ##   0:     823.96514:  5.00000  0.00000 0.100000 ##   1:    -23.631306:  4.97573 0.143302  1.08938 ##   2:    -27.304674:  4.92116 0.635388  1.01957 ##   3:    -28.159625:  5.39399 0.797586  1.00873 ##   4:    -28.595330:  7.35194  1.20550  1.00142 ##   5:    -30.261929:  7.00584 0.966687  1.02771 ##   6:    -31.541810:  8.06439 0.949977  1.05900 ##   7:    -34.410489:  12.1976  1.03521  1.15875 ##   8:    -34.983141:  14.7762  1.09189  1.22006 ##   9:    -35.073719:  15.9169  1.05173  1.25649 ##  10:    -35.106105:  15.9356  1.07264  1.25375 ##  11:    -35.106680:  15.9721  1.07247  1.25451 ##  12:    -35.109686:  16.1150  1.07195  1.25645 ##  13:    -35.114592:  16.2646  1.07149  1.25647 ##  14:    -35.126076:  16.4874  1.07103  1.25146 ##  15:    -35.141346:  16.6208  1.07113  1.23793 ##  16:    -35.153357:  16.5245  1.07182  1.21997 ##  17:    -35.156849:  16.3305  1.07228  1.21163 ##  18:    -35.157137:  16.2622  1.07243  1.21149 ##  19:    -35.157143:  16.2571  1.07244  1.21183 ##  20:    -35.157143:  16.2572  1.07244  1.21186 ##  21:    -35.157143:  16.2572  1.07244  1.21186 ##   Optimization finished!: ##             Elapsed time: 0.028 seconds. ##             The objective value is: -3.515714e+01 ##             The maximum gradient component is: 2.9e-06 ##             The convergence message is: relative convergence (4) ##             Iterations: 21 ##             Evaluations: Fun: 23 Grad: 22 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished!"},{"path":"/articles/ctsmTMB.html","id":"important-note-for-model-changes","dir":"Articles","previous_headings":"","what":"Important Note for Model Changes","title":"Getting Started","text":"change model later stage retain model name, need recompile C++ objective function. can like : receive error messages calling estimate regarding variables specified model, likely forgot recompile.","code":"obj$estimate(data, compile=TRUE)"},{"path":"/articles/ctsmTMB.html","id":"parameter-estimates","dir":"Articles","previous_headings":"","what":"Parameter estimates","title":"Getting Started","text":"Let’s inspect results estimation. can print fit object see standard coefficient matrix parameter estimates. can see parameter estimate associated standard error together t-test statistic P-value associated standard null-hypothesis \\[ H_{0}: p = 0 \\\\ H_{1}: p \\neq 0 \\] Note true parameter values set simulation step \\(\\theta = 10\\), \\(\\mu=1\\) \\(\\sigma_{X} = 1\\). parameter values, standard deviations covariance matrix can extracted via: estimated (fixed) parameters: standard deviations (fixed) parameters: covariance (fixed) parameters:","code":"print(fit) ## Coefficent Matrix  ##          Estimate Std. Error t value  Pr(>|t|)     ## theta   16.257194   3.481811  4.6692 9.329e-06 *** ## mu       1.072440   0.079191 13.5425 < 2.2e-16 *** ## sigma_x  1.211858   0.158279  7.6565 1.178e-11 *** ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 fit$par.fixed ##     theta        mu   sigma_x  ## 16.257194  1.072440  1.211858 fit$sd.fixed ##      theta         mu    sigma_x  ## 3.48181119 0.07919093 0.15827877 fit$cov.fixed ##               theta          mu     sigma_x ## theta   12.12300915 0.078844171 0.176665520 ## mu       0.07884417 0.006271203 0.001125772 ## sigma_x  0.17666552 0.001125772 0.025052169"},{"path":"/articles/ctsmTMB.html","id":"state-estimates","dir":"Articles","previous_headings":"","what":"State estimates","title":"Getting Started","text":"can also plot prior posterior state estimates prior state estimate resulting estimate purely integrating mean covariance SDE system forward time, posterior state estimation obtained updating prior estimate information contained observation (using Bayes’ rule).","code":"library(ggplot2) library(patchwork) # ggplot2 theme mytheme =   theme_minimal() +    theme(     text             = element_text(\"Avenir Next Condensed\",size=15),     legend.text      = element_text(size=15),     axis.text        = element_text(size=15),     strip.text       = element_text(face=\"bold\",size=15),     panel.grid.major = element_blank(),     panel.grid.minor = element_blank(),     legend.box       = \"vertical\",     legend.position  = \"top\",     plot.title       = element_text(hjust=0.5)   ) t         = fit$states$mean$posterior$t xprior    = fit$states$mean$prior$X xpost     = fit$states$mean$posterior$X xpost_sd  = fit$states$sd$posterior$X  ggplot() +   geom_line(aes(x=t,y=xpost,color=\"State Estimates (Posterior)\"),lwd=1) +   geom_line(aes(x=t,y=xprior,color=\"State Estimates (Prior)\"),lwd=1) +   geom_ribbon(aes(x=t,ymin=xpost-2*xpost_sd,ymax=xpost+2*xpost_sd),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$Y,color=\"Observations\")) +   guides(color=guide_legend(override.aes=list(shape=c(16,NA,NA),size=c(2,NA,NA),linetype=c(NA,1,1),lwd=c(NA,1,1)))) +   labs(x = \"Time\", y = \"\", color=\"\") +   mytheme"},{"path":"/articles/ctsmTMB.html","id":"residual-analysis","dir":"Articles","previous_headings":"","what":"Residual analysis","title":"Getting Started","text":"can display standard residual analysis observations calling plot fit object, invokes S3 plot.ctsmTMB.fit method plot. includes quantile-quantile plot, histogram, auto-correlations cumulative periodogram. residuals (standard normalized) can extracted well, together standard deviation covariance matrix via fit$residuals","code":"plot(fit)"},{"path":"/articles/ctsmTMB.html","id":"extra-adding-algebraic-equations","dir":"Articles","previous_headings":"","what":"Extra: Adding algebraic equations","title":"Getting Started","text":"sake clarity can sometimes easier specify simple variables equations place (perhaps larger) expression. can redefine variable name providing algebraic relation. Let’s say wish consider positive values parameter \\(\\theta\\), appropriate estimate log-domain (since domain logarithm positive real axis). use \\(\\theta = \\exp\\left(\\log\\theta\\right)\\) introduce parameter logtheta replace theta. obviously just names, might well written exp(theta) directly specifying system equations, calling parameter logtheta reminds one really interested exponential parameter. specify algebraic relation like : parameter settings theta automatically transformed logtheta, must redefined:","code":"obj$setAlgebraics(theta ~ exp(logtheta)) obj$setParameter(logtheta = log(c(initial=5, lower=0, upper=20)))"},{"path":"/articles/estimate.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Estimating parameters and latent states","text":"now construct ctsmTMB model object per usual","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/estimate.html","id":"using-estimate---default-settings","dir":"Articles","previous_headings":"","what":"Using estimate - default settings","title":"Estimating parameters and latent states","text":"can run estimate directly default settings using default settings Let’s walk various arguments effect:","code":"obj$estimate(.data) obj$estimate(data = .data,               method = \"ekf\",              ode.solver = \"rk4\",              ode.timestep = diff(data$t),              loss = \"quadratic\",              loss_c = 3,              unscented_hyperpars = list(alpha=1, beta=0, kappa=3-private$number.of.states),              control = list(trace=1,iter.max=1e5,eval.max=1e5),              use.hessian = FALSE,              laplace.residuals = FALSE,              unconstrained.optim = FALSE,              compile = FALSE,              silent = FALSE)"},{"path":"/articles/estimate.html","id":"argument-method","dir":"Articles","previous_headings":"","what":"Argument: method","title":"Estimating parameters and latent states","text":"method argument determines underlying estimation techniques used. current implementation supports following method='ekf': Extended Kalman Filter. method='ukf': Unscented Kalman Filter - currently disabled. method='laplace': Laplace Approximation former two quite similar based Kalman Filter theory. assumptions normality state transition observation equation fundamental, although implemented filters standard non-linear filters, sense try overcome assumptions small non-linearities. Unscented Kalman Filter generally considered perform better cases. latter laplace method employs Laplace Approximation method integration random effects. formulation consider states random effects, parameters fixed. underlying assumption one normality, implementation allows flexibility choosing arbitrary distributions (yet implemented.) methods can used estimate parameter states. case laplace states smoothed (conditioned past future observations).","code":""},{"path":"/articles/estimate.html","id":"argument-ode-solver","dir":"Articles","previous_headings":"","what":"Argument: ode.solver","title":"Estimating parameters and latent states","text":"argument used Kalman Filter methods .e. ekf ukf. argument determines algorithm used integrate forward moment (mean variance) differential equations. current implementation supports ode.solver='euler': forward Euler scheme ode.solver='rk4': 4th order Runge-Kutta scheme","code":""},{"path":"/articles/estimate.html","id":"argument-ode-timestep","dir":"Articles","previous_headings":"","what":"Argument: ode.timestep","title":"Estimating parameters and latent states","text":"argument determines time-step used ODE solvers","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/articles/observation_equations.html","id":"adding-observation-equations","dir":"Articles","previous_headings":"","what":"Adding observation equations","title":"observations: Using functions on the left-hand side","text":"Let’s assume observations \\(y_{t}\\) log-normally distributed conditioned \\(x_{t}\\) .e. \\[ \\log y_{t_{}} \\sim \\mathcal{N}(x_{t_{}},\\sigma_{y}^{2}) \\] sufficient user provide data column y provided data.frame e.g. estimate predict adding following observation equation Note kind observation equations, left-hand side function one () observed variables must explicitly named using obsnames argument.","code":"obj$addObs(   log(y) ~ x, obsnames = \"log_y\" )"},{"path":"/articles/observation_equations.html","id":"adding-observation-variances","dir":"Articles","previous_headings":"","what":"Adding observation variances","title":"observations: Using functions on the left-hand side","text":"names given obsnames important needed specify observation variance. example code work, observation named log_y correct way add observation variance :","code":"obj$setVariance(   y ~ sigma_y^2 ) ## Error in check_observation_variance_eqs(form, self, private): Please add an observation equation for y before specifying its variance obj$setVariance(   log_y ~ sigma_y^2 )"},{"path":"/articles/observation_equations.html","id":"multiple-observation-equations","dir":"Articles","previous_headings":"","what":"Multiple observation equations","title":"observations: Using functions on the left-hand side","text":"must supply multiple obsnames supplying multiple observatin equations, although name used left-hand side just single variable .e.","code":"obj$addObs(   log(y) ~ x,   y ~ x,   y^2+z^3 ~ x,   obsnames = c(\"log_y\", NA, \"y2_plus_z3\") )"},{"path":"/articles/predict.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"Performing (moment) model predictions","text":"use Ornstein-Uhlenbeck process . \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/predict.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Performing (moment) model predictions","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/predict.html","id":"predict","dir":"Articles","previous_headings":"","what":"Predict","title":"Performing (moment) model predictions","text":"can use predict function without called estimate first, case initial value parameters provided add_parameters used. output predict list two data.frames, one states one observations. two data.frames share five initial columns contain indices j, associated time-points t.t.j, k.ahead contain indices, time-points associated k-step ahead , state/observation values associated standard deviations, observations provided data, predicted observation values based predicted state values. indices . j. table refer expectation variance state vector \\[ \\mathrm{E}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\\\ \\mathrm{V}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\] moments given indices \\(\\) (time \\(t_{}\\)) conditioned information available indices \\(j\\) (time \\(t_{j}\\)). sense state/covariance predictions \\(=j\\) posterior estimates, others prior estimates. default standard deviations states returned. entire covariance matrix elements can returned via","code":"pred = obj$predict(.data) head(pred$states) ##   i. j.  t.i  t.j k.ahead        x       var.x ## 1  0  0 0.00 0.00       0 3.095456 0.009090909 ## 2  0  1 0.00 0.01       1 2.944489 0.008320958 ## 3  1  1 0.01 0.01       0 2.827817 0.004541770 ## 4  1  2 0.01 0.02       1 2.689903 0.004204726 ## 5  2  2 0.02 0.02       0 2.673529 0.002960090 ## 6  2  3 0.02 0.03       1 2.543140 0.002773563 head(pred$observations) ##     i. j.  t.i  t.j k.ahead        y   y.data ## 1    0  0 0.00 0.00       0 3.095456 3.105001 ## 2    0  1 0.00 0.01       1 2.944489 2.687603 ## 2.1  1  1 0.01 0.01       0 2.827817 2.687603 ## 3    1  2 0.01 0.02       1 2.689903 2.634588 ## 3.1  2  2 0.02 0.02       0 2.673529 2.634588 ## 4    2  3 0.02 0.03       1 2.543140 2.267096 obj$predict(.data, return.covariance = TRUE)"},{"path":"/articles/predict.html","id":"set-number-of-prediction-steps","dir":"Articles","previous_headings":"","what":"Set number of prediction steps","title":"Performing (moment) model predictions","text":"number time steps ahead predictions desired can changed k.ahead argument. default behaviour save prediction steps 1 k.ahead selected desired, return.k.ahead argument can used indicate kept output.","code":"pred1 = obj$predict(.data, k.ahead=2) pred2 = obj$predict(.data, k.ahead=10, return.k.ahead=c(2,5,8)) head(pred1$states) ##   i. j.  t.i  t.j k.ahead        x       var.x ## 1  0  0 0.00 0.00       0 3.095456 0.009090909 ## 2  0  1 0.00 0.01       1 2.944489 0.008320958 ## 3  0  2 0.00 0.02       2 2.800884 0.007624277 ## 4  1  1 0.01 0.01       0 2.827817 0.004541770 ## 5  1  2 0.01 0.02       1 2.689903 0.004204726 ## 6  1  3 0.01 0.03       2 2.558715 0.003899757 head(pred2$states) ##    i. j.  t.i  t.j k.ahead        x       var.x ## 3   0  2 0.00 0.02       2 2.800884 0.007624277 ## 6   0  5 0.00 0.05       5 2.410743 0.005907387 ## 9   0  8 0.00 0.08       8 2.074946 0.004635482 ## 14  1  3 0.01 0.03       2 2.558715 0.003899757 ## 17  1  6 0.01 0.06       5 2.202306 0.003148193 ## 20  1  9 0.01 0.09       8 1.895543 0.002591421"},{"path":"/articles/predict.html","id":"set-the-model-parameters-used","dir":"Articles","previous_headings":"","what":"Set the model parameters used","title":"Performing (moment) model predictions","text":"default predict use initial parameters supplied setParameter, unless estimate function succesfully run, predict use parameter values found minimizer. can provide parameters using pars argument method .e.","code":"some.other.random.pars = rnorm(length(fit$par.fixed)) pred = obj$predict(.data, pars=some.other.random.pars)"},{"path":"/articles/predict.html","id":"set-the-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set the initial state and covariance","title":"Performing (moment) model predictions","text":"default behaviour predict use initial state covariance suppled calling set_initial_state method. can important change one wishes correctly predict first observations provided prediction data series. can supply x0 p0 arguments updated state covariance estimates","code":"new.initial.x0 = rnorm(1) new.initial.p0 = rnorm(1)*diag(1) pred = obj$predict(data=.data,                    initial.state = list(                      new.state.value,                      new.covariance.value                    ) )"},{"path":"/articles/predict.html","id":"the-solver-options","dir":"Articles","previous_headings":"","what":"The solver options","title":"Performing (moment) model predictions","text":"can choose solver options use via arguments ode.solver ode.timestep. ode.solver decides ode solver algorithm used solving mean variance ODEs SDE. ode.timestep determines time step-size using solving ODEs, default value minimum observed time difference provided data time vector (min(diff(.data$t))). time step-size can’t smaller . chosen time step-size \\(\\Delta_{step}\\) “almost” divide observation time differences data \\(\\Delta_{obs}\\) .e. \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} - \\bigg\\lfloor \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rfloor \\geq 0.02 \\] time step-size reduced divide evenly setting \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} = \\bigg\\lceil \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rceil \\] words: takes \\(3.561\\) time-steps get \\(t_{}\\) \\(t_{+1}\\) take \\(4\\) time-steps instead, calculate reduced time-step true. \\(3.01\\) time-steps retain original time-step, ignoring small temporal discrepancy. provide arguments via","code":"obj$predict(.data,             ode.timestep = min(diff(.data$t)) )"},{"path":"/articles/predict.html","id":"use-case","dir":"Articles","previous_headings":"","what":"Use-case","title":"Performing (moment) model predictions","text":"use model predictions observation compute model performance score e.g. RMSE (root-mean square error). first estimate model parameters, automatically used calling predict. predict 10-steps ahead, return values. Let’s plot 10-step predictions observations. notice 10-step predictions state uncertainty (95%) much larger filtered posterior state estimates fit .e. can calculate RMSE prediction score prediction step follows:","code":"fit = obj$estimate(.data) pred = obj$predict(.data, k.ahead=10) pred.states = pred$states pred.obs = pred$observations # ggplot2 theme library(ggplot2) mytheme =   theme_minimal() +    theme(     text             = element_text(\"Avenir Next Condensed\",size=15),     legend.text      = element_text(size=15),     axis.text        = element_text(size=15),     strip.text       = element_text(face=\"bold\",size=15),     legend.box       = \"vertical\",     legend.position  = \"top\",     plot.title       = element_text(hjust=0.5)   ) pred10 = pred.states[pred.states$k.ahead==10,] data = .data ggplot() +   geom_line(aes(x=pred10$t.j,y=pred10$x,color=\"10-Step Predictions\")) +     geom_ribbon(aes(x=pred10$t.j,ymin=pred10$x-2*sqrt(pred10$var.x),ymax=pred10$x+2*sqrt(pred10$var.x)),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(color=\"\",x=\"Time\",y=\"\") +   # coord_cartesian(xlim=c(0,0.1)) +   mytheme t         = fit$states$mean$posterior$t xpost     = fit$states$mean$posterior$x xpost_sd  = fit$states$sd$posterior$x  ggplot() +   geom_line(aes(x=t,y=xpost,color=\"0-Step Predictions (Posterior State Estimates)\"),lwd=1) +   geom_ribbon(aes(x=t,ymin=xpost-2*xpost_sd,ymax=xpost+2*xpost_sd),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(x = \"Time\", y = \"\", color=\"\") +   mytheme rmse = c() k.ahead = 1:10 for(i in k.ahead){   xy = data.frame(     x = pred.states[pred.states$k.ahead==i,\"x\"],     y = pred.obs[pred.obs$k.ahead==i,\"y.data\"]   )   rmse[i] = sqrt(mean((xy[[\"x\"]] - xy[[\"y\"]])^2)) }  ggplot() +   geom_line(aes(k.ahead, rmse), color=\"steelblue\") +    geom_point(aes(k.ahead, rmse), color=\"red\") +   labs(     title = \"Root-Mean Square Errors for Different Prediction Horizons\",     x = \"Prediction Steps\",     y = \"Root-Mean-Square Errors\"     ) +   mytheme"},{"path":"/articles/simulate.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"Performing stochastic model simulations","text":"use Ornstein-Uhlenbeck process . \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/simulate.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Performing stochastic model simulations","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/simulate.html","id":"predict","dir":"Articles","previous_headings":"","what":"Predict","title":"Performing stochastic model simulations","text":"can use predict function without called estimate first, case initial value parameters provided add_parameters used. output predict list two data.frames, one states one observations. two data.frames share five initial columns contain indices j, associated time-points t.t.j, k.ahead contain indices, time-points associated k-step ahead , state/observation values associated standard deviations, observations provided data, predicted observation values based predicted state values. indices . j. table refer expectation variance state vector \\[ \\mathrm{E}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\\\ \\mathrm{V}(x_{t_{}} | x_{t_{j}}, y_{t_{j}}) \\] moments given indices \\(\\) (time \\(t_{}\\)) conditioned information available indices \\(j\\) (time \\(t_{j}\\)). sense state/covariance predictions \\(=j\\) posterior estimates, others prior estimates. default standard deviations states returned. entire covariance matrix elements can returned via","code":"pred = obj$predict(.data) head(pred$states) ##   i. j.  t.i  t.j k.ahead        x       var.x ## 1  0  0 0.00 0.00       0 3.095456 0.009090909 ## 2  0  1 0.00 0.01       1 2.944489 0.008320958 ## 3  1  1 0.01 0.01       0 2.827817 0.004541770 ## 4  1  2 0.01 0.02       1 2.689903 0.004204726 ## 5  2  2 0.02 0.02       0 2.673529 0.002960090 ## 6  2  3 0.02 0.03       1 2.543140 0.002773563 head(pred$observations) ##     i. j.  t.i  t.j k.ahead        y   y.data ## 1    0  0 0.00 0.00       0 3.095456 3.105001 ## 2    0  1 0.00 0.01       1 2.944489 2.687603 ## 2.1  1  1 0.01 0.01       0 2.827817 2.687603 ## 3    1  2 0.01 0.02       1 2.689903 2.634588 ## 3.1  2  2 0.02 0.02       0 2.673529 2.634588 ## 4    2  3 0.02 0.03       1 2.543140 2.267096 obj$predict(.data, return.covariance = TRUE)"},{"path":"/articles/simulate.html","id":"set-number-of-prediction-steps","dir":"Articles","previous_headings":"","what":"Set number of prediction steps","title":"Performing stochastic model simulations","text":"number time steps ahead predictions desired can changed k.ahead argument. default behaviour save prediction steps 1 k.ahead selected desired, return.k.ahead argument can used indicate kept output.","code":"pred1 = obj$predict(.data, k.ahead=2) pred2 = obj$predict(.data, k.ahead=10, return.k.ahead=c(2,5,8)) head(pred1$states) ##   i. j.  t.i  t.j k.ahead        x       var.x ## 1  0  0 0.00 0.00       0 3.095456 0.009090909 ## 2  0  1 0.00 0.01       1 2.944489 0.008320958 ## 3  0  2 0.00 0.02       2 2.800884 0.007624277 ## 4  1  1 0.01 0.01       0 2.827817 0.004541770 ## 5  1  2 0.01 0.02       1 2.689903 0.004204726 ## 6  1  3 0.01 0.03       2 2.558715 0.003899757 head(pred2$states) ##    i. j.  t.i  t.j k.ahead        x       var.x ## 3   0  2 0.00 0.02       2 2.800884 0.007624277 ## 6   0  5 0.00 0.05       5 2.410743 0.005907387 ## 9   0  8 0.00 0.08       8 2.074946 0.004635482 ## 14  1  3 0.01 0.03       2 2.558715 0.003899757 ## 17  1  6 0.01 0.06       5 2.202306 0.003148193 ## 20  1  9 0.01 0.09       8 1.895543 0.002591421"},{"path":"/articles/simulate.html","id":"set-the-model-parameters-used","dir":"Articles","previous_headings":"","what":"Set the model parameters used","title":"Performing stochastic model simulations","text":"default predict use initial parameters supplied setParameter, unless estimate function succesfully run, predict use parameter values found minimizer. can provide parameters using pars argument method .e.","code":"some.other.random.pars = rnorm(length(fit$par.fixed)) pred = obj$predict(.data, pars=some.other.random.pars)"},{"path":"/articles/simulate.html","id":"set-the-initial-state-and-covariance","dir":"Articles","previous_headings":"","what":"Set the initial state and covariance","title":"Performing stochastic model simulations","text":"default behaviour predict use initial state covariance suppled calling set_initial_state method. can important change one wishes correctly predict first observations provided prediction data series. can supply x0 p0 arguments updated state covariance estimates","code":"new.initial.x0 = rnorm(1) new.initial.p0 = rnorm(1)*diag(1) pred = obj$predict(data=.data,                    initial.state = list(                      new.state.value,                      new.covariance.value                    ) )"},{"path":"/articles/simulate.html","id":"the-solver-options","dir":"Articles","previous_headings":"","what":"The solver options","title":"Performing stochastic model simulations","text":"can choose solver options use via arguments ode.solver ode.timestep. ode.solver decides ode solver algorithm used solving mean variance ODEs SDE. ode.timestep determines time step-size using solving ODEs, default value minimum observed time difference provided data time vector (min(diff(.data$t))). time step-size can’t smaller . chosen time step-size \\(\\Delta_{step}\\) “almost” divide observation time differences data \\(\\Delta_{obs}\\) .e. \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} - \\bigg\\lfloor \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rfloor \\geq 0.02 \\] time step-size reduced divide evenly setting \\[ \\frac{\\Delta_{obs}}{\\Delta_{step}} = \\bigg\\lceil \\frac{\\Delta_{obs}}{\\Delta_{step}} \\bigg\\rceil \\] words: takes \\(3.561\\) time-steps get \\(t_{}\\) \\(t_{+1}\\) take \\(4\\) time-steps instead, calculate reduced time-step true. \\(3.01\\) time-steps retain original time-step, ignoring small temporal discrepancy. provide arguments via","code":"obj$predict(.data,             ode.timestep = min(diff(.data$t)) )"},{"path":"/articles/simulate.html","id":"use-case","dir":"Articles","previous_headings":"","what":"Use-case","title":"Performing stochastic model simulations","text":"use model predictions observation compute model performance score e.g. RMSE (root-mean square error). first estimate model parameters, automatically used calling predict. predict 10-steps ahead, return values. Let’s plot 10-step predictions observations. notice 10-step predictions state uncertainty (95%) much larger filtered posterior state estimates fit .e. can calculate RMSE prediction score prediction step follows:","code":"fit = obj$estimate(.data) pred = obj$predict(.data, k.ahead=10) pred.states = pred$states pred.obs = pred$observations # ggplot2 theme library(ggplot2) mytheme =   theme_minimal() +    theme(     text             = element_text(\"Avenir Next Condensed\",size=15),     legend.text      = element_text(size=15),     axis.text        = element_text(size=15),     strip.text       = element_text(face=\"bold\",size=15),     legend.box       = \"vertical\",     legend.position  = \"top\",     plot.title       = element_text(hjust=0.5)   ) pred10 = pred.states[pred.states$k.ahead==10,] data = .data ggplot() +   geom_line(aes(x=pred10$t.j,y=pred10$x,color=\"10-Step Predictions\")) +     geom_ribbon(aes(x=pred10$t.j,ymin=pred10$x-2*sqrt(pred10$var.x),ymax=pred10$x+2*sqrt(pred10$var.x)),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(color=\"\",x=\"Time\",y=\"\") +   # coord_cartesian(xlim=c(0,0.1)) +   mytheme t         = fit$states$mean$posterior$t xpost     = fit$states$mean$posterior$x xpost_sd  = fit$states$sd$posterior$x  ggplot() +   geom_line(aes(x=t,y=xpost,color=\"0-Step Predictions (Posterior State Estimates)\"),lwd=1) +   geom_ribbon(aes(x=t,ymin=xpost-2*xpost_sd,ymax=xpost+2*xpost_sd),fill=\"grey\",alpha=0.5) +   geom_point(aes(x=data$t,data$y,color=\"Observations\")) +   labs(x = \"Time\", y = \"\", color=\"\") +   mytheme rmse = c() k.ahead = 1:10 for(i in k.ahead){   xy = data.frame(     x = pred.states[pred.states$k.ahead==i,\"x\"],     y = pred.obs[pred.obs$k.ahead==i,\"y.data\"]   )   rmse[i] = sqrt(mean((xy[[\"x\"]] - xy[[\"y\"]])^2)) }  ggplot() +   geom_line(aes(k.ahead, rmse), color=\"steelblue\") +    geom_point(aes(k.ahead, rmse), color=\"red\") +   labs(     title = \"Root-Mean Square Errors for Different Prediction Horizons\",     x = \"Prediction Steps\",     y = \"Root-Mean-Square Errors\"     ) +   mytheme"},{"path":"/articles/using_another_optimizer.html","id":"simulate-from-the-ornstein-uhlenbeck-process","dir":"Articles","previous_headings":"","what":"Simulate from the Ornstein-Uhlenbeck process","title":"Using another Optimizer","text":"use common Ornstein-Uhlenbeck process showcase use likelihood. \\[ \\mathrm{d}X_{t} = \\theta (\\mu - X_{t}) \\, \\mathrm{d}t \\, + \\sigma_{X} \\, \\mathrm{d}B_{t} \\] \\[ Y_{t_{k}} = X_{t_{k}} + e_{t_{k}}, \\qquad e_{t_{k}} \\sim \\mathcal{N}\\left(0,\\sigma_{Y}^{2}\\right)   \\] first create data simulating process","code":"# Simulate data using Euler Maruyama set.seed(10) theta=10; mu=1; sigma_x=1; sigma_y=1e-1 #  dt.sim = 1e-3 t.sim = seq(0,1,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + theta*(mu-x[i])*dt.sim + sigma_x*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 t.obs = seq(0,1,by=dt.obs) y = x[t.sim %in% t.obs] + sigma_y * rnorm(length(t.obs))  # Create data .data = data.frame(   t = t.obs,   y = y )"},{"path":"/articles/using_another_optimizer.html","id":"construct-model-object","dir":"Articles","previous_headings":"","what":"Construct model object","title":"Using another Optimizer","text":"now construct ctsmTMB model object","code":"# Create model object obj = ctsmTMB$new()  # Set name of model (and the created .cpp file) obj$setModelname(\"ornstein_uhlenbeck\")  # Add system equations obj$addSystem(   dx ~ theta * (mu-x) * dt + sigma_x*dw )  # Add observation equations obj$addObs(   y ~ x )  # Set observation equation variances obj$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations obj$setAlgebraics(   theta ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Specify parameter initial values and lower/upper bounds in estimation obj$setParameter(   logtheta   = log(c(initial = 5,    lower = 0,    upper = 20)),   mu         = c(    initial = 0,    lower = -10,  upper = 10),   logsigma_x = log(c(initial = 1e-1, lower = 1e-5, upper = 5)),   logsigma_y = log(c(initial = 1e-1, lower = 1e-5, upper = 5)) )  # Set initial state mean and covariance obj$setInitialState(list(x[1], 1e-1*diag(1)))"},{"path":"/articles/using_another_optimizer.html","id":"estimation","dir":"Articles","previous_headings":"","what":"Estimation","title":"Using another Optimizer","text":"principle ready call estimate method run optimization scheme using built-optimization uses stats::nlminb .e. Inside package optimise objective function respect fixed parameters using construction function handlers TMB::MakeADFun parsing stats::nlminb .e.","code":"fit = obj$estimate(.data) ## Building model... ## Compiling model... ## Note: Using Makevars in /Users/pbrve/.R/Makevars ## using C++ compiler: 'Apple clang version 15.0.0 (clang-1500.3.9.4)' ## using SDK: 'MacOSX14.4.sdk' ## ...took 10.29 seconds ## Checking data... ## Constructing objective function and derivative tables... ## ...took: 0.044 seconds. ## Minimizing the negative log-likelihood... ##   0:     921.77031:  1.60944  0.00000 -2.30259 -2.30259 ##   1:     86.857795:  1.06416 0.614170 -1.83281 -1.97888 ##   2:     31.849960:  1.43157 0.566368 -1.48426 -1.11793 ##   3:     29.255774:  1.22062  1.42236 -1.18700 -1.48456 ##   4:     2.6332703:  1.21162  1.06391 -0.839196 -1.50616 ##   5:    -28.360004:  1.69842 0.789400 0.678990 -2.68208 ##   6:    -31.783751:  1.72217 0.792252 0.505927 -2.70162 ##   7:    -32.935798:  1.82814 0.794076 0.369331 -2.66980 ##   8:    -34.998129:  2.13584 0.801094 0.363805 -2.49993 ##   9:    -38.060272:  2.43616  1.03138 0.233817 -2.31788 ##  10:    -38.611349:  2.53386  1.03053 0.151828 -2.34627 ##  11:    -38.948305:  2.62609  1.06853 0.198821 -2.27616 ##  12:    -39.203049:  2.73311  1.05589 0.129693 -2.30229 ##  13:    -39.275690:  2.73805  1.08259 0.162430 -2.29016 ##  14:    -39.308929:  2.76701  1.06735 0.191922 -2.29410 ##  15:    -39.341994:  2.80593  1.07554 0.193617 -2.31337 ##  16:    -39.346463:  2.79920  1.07739 0.200505 -2.32628 ##  17:    -39.346636:  2.80270  1.07746 0.202366 -2.32687 ##  18:    -39.346636:  2.80285  1.07748 0.202480 -2.32692 ##  19:    -39.346636:  2.80285  1.07748 0.202482 -2.32692 ##   Optimization finished!: ##             Elapsed time: 0.028 seconds. ##             The objective value is: -3.934664e+01 ##             The maximum gradient component is: 1.3e-04 ##             The convergence message is: relative convergence (4) ##             Iterations: 19 ##             Evaluations: Fun: 27 Grad: 20 ##             See stats::nlminb for available tolerance/control arguments. ## Returning results... ## Finished! nll = TMB::MakeADFun(...) opt = stats::nlminb(start=nll$par, objective=nll$fn, grad=nll$gr, hessian=nll$he)"},{"path":"/articles/using_another_optimizer.html","id":"extract-function-handlers","dir":"Articles","previous_headings":"","what":"Extract function handlers","title":"Using another Optimizer","text":"likelihood method allows retrieve nll object holds negative log-likelihood, derivatives. method takes arguments similar estimate. initial parameters (supplied user) stored objective function can evaluted gradient can evaluted hessian can evaluted can now use optimize function using e.g. stats::optim instead.","code":"nll = obj$likelihood(.data) ## Building model... ## Compiling model... ## Checking data... ## Constructing objective function... ## ...took: 0.041 seconds. ## Succesfully returned function handlers nll$par ##   logtheta         mu logsigma_x logsigma_y  ##   1.609438   0.000000  -2.302585  -2.302585 nll$fn(nll$par) ## [1] 921.7703 nll$gr(nll$par) ##          [,1]      [,2]      [,3]      [,4] ## [1,] 1382.854 -1557.574 -1191.374 -820.9253 nll$he(nll$par) ##           [,1]       [,2]       [,3]       [,4] ## [1,]  2226.705 -2859.2069 -1636.0560 -1136.3013 ## [2,] -2859.207  1663.1457  2251.5926   865.5807 ## [3,] -1636.056  2251.5926   905.1284  1486.3607 ## [4,] -1136.301   865.5807  1486.3607   346.7711"},{"path":"/articles/using_another_optimizer.html","id":"extract-parameter-lowerupper-bounds","dir":"Articles","previous_headings":"","what":"Extract parameter lower/upper bounds","title":"Using another Optimizer","text":"can extract parameter bounds specified calling setParameter() method using getParameters method (note nll$par pars$initial identical).","code":"pars = obj$getParameters() print(pars) ##            type   estimate   initial     lower     upper ## logtheta   free  2.8028461  1.609438      -Inf  2.995732 ## mu         free  1.0774793  0.000000 -10.00000 10.000000 ## logsigma_x free  0.2024819 -2.302585 -11.51293  1.609438 ## logsigma_y free -2.3269231 -2.302585 -11.51293  1.609438"},{"path":"/articles/using_another_optimizer.html","id":"optimize-manually-using-statsoptim","dir":"Articles","previous_headings":"","what":"Optimize manually using stats::optim","title":"Using another Optimizer","text":"supply initial parameter values, objective function handler gradient handler, parameter bounds optim.","code":"opt = stats::optim(par=nll$par,                     fn=nll$fn,                     gr=nll$gr,                     method=\"L-BFGS-B\",                     lower=pars$lower,                     upper=pars$upper)"},{"path":"/articles/using_another_optimizer.html","id":"compare-results-between-the-two-optimizers","dir":"Articles","previous_headings":"","what":"Compare results between the two optimizers","title":"Using another Optimizer","text":"Lets compare results using stats::optim extracted function handler versus internal optimisation uses stats::nlminb stored fit:","code":"# Estimated parameters data.frame(external=opt$par, internal=fit$par.fixed) ##              external   internal ## logtheta    2.8028428  2.8028461 ## mu          1.0774788  1.0774793 ## logsigma_x  0.2024796  0.2024819 ## logsigma_y -2.3269222 -2.3269231 # Neg. Log-Likelihood data.frame(external=opt$value, internal=fit$nll) ##    external  internal ## 1 -39.34664 -39.34664 # Gradient components data.frame(external=t(nll$gr(opt$par)), internal=t(nll$gr(fit$par.fixed))) ##        external      internal ## 1 -5.284383e-05 -2.269770e-06 ## 2 -1.491876e-04 -1.337658e-04 ## 3 -4.592109e-05  2.628658e-05 ## 4 -2.656532e-05 -2.239568e-06"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Phillip Vetter. Author, maintainer. Jan Møller. Contributor. Uffe Thygesen. Contributor. Peder Bacher. Contributor. Henrik Madsen. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vetter PB, Møller JK, Thygesen U, Bacher P, Madsen H (2024). ctsmTMB: Continuous Time Stochastic Modelling using Template Model Builder. R Package Version 1.0, https://github.com/phillipbvetter/ctsmTMB.","code":"@Manual{,   title = {ctsmTMB: Continuous Time Stochastic Modelling using Template Model Builder},   author = {Phillip Brinck Vetter and Jan K. Møller and Uffe Thygesen and Peder Bacher and Henrik Madsen},   year = {2024},   note = {R Package Version 1.0},   url = {https://github.com/phillipbvetter/ctsmTMB}, }"},{"path":[]},{"path":"/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"Welcome GitHub repository hosts ctsmTMB (Continuous Time Stochastic Modelling using Template Model Builder), intended successor , heavily inspired , CTSM package (Continuous Time Stochastic Modelling). purpose package facilitate user-friendly tool (state parameter) inference, forecasting, (multi-dimensional) continuous-discrete stochastic state space systems, .e. systems form $$ \\begin{align} dx_{t} & = f(t, x_t, u_t, \\theta) \\, dt + g(t, x_t, u_t, \\theta) \\, dB_{t} \\\\ y_{t_k} & = h(t, x_t, u_t, \\theta) \\end{align} $$ latent state xt evolves continuously time, governed set stochastic differential equations, information system available discrete times observations ytk. ctsmTMB package essentially “just” convience wrapper TMB/RTMB packages (Template Model Builder) provide automatic differentiation likelihood function, access computational tools Laplace approximation. likelihood function constructed based (symbolic) user-provided state space equations, may specified using implemented OOP-style R6 ctsmTMB class, methods addSystem (defining system equations), addObs (defining observation equations). primary work-horse ctsmTMB estimate method, carries inference minimizing (negative log) likelihood using stats::nlminb quasi-Newton optimizer due D. Gay. resulting object contains maximum likelihood parameter state estimates, associated marginal uncertainties. available inference methods non-linear Kalman filters (EKF UKF) filtration Laplace approxmation random-effects setting. user can extract likelihood function handles (function, gradient hessian) likelihood method e.g. want use another optimizer. package facilities forecasting predict simulate methods (state updates k-step ahead forecasts currently available using Kalman filters). difference two former produces moment predictions (mean covariance) latter produces stochastic path simulations (distributions). calculations carried C++ Rcpp package universe, particular using RcppXPtrUtils package sending C++ pointers model-specific functions (drift, diffusion, observation jacobians) rather sending (slow evaluate) R functions.","code":""},{"path":"/index.html","id":"estimation-methods","dir":"","previous_headings":"","what":"Estimation Methods","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"following state reconstruction algorithms currently available: (Continous-Discrete) Extended Kalman Filter, ekf. (Continous-Discrete) Unscented Kalman Filter, ukf. (Continuous-Discrete) Laplace Approximation laplace.","code":""},{"path":"/index.html","id":"kalman-filters","dir":"","previous_headings":"","what":"Kalman Filters","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"package currently mostly tailored towards Kalman Filter. advantages methods : hessian likelihood function (w.r.t parameters) available. model residuals easier compute e.g. model validation. Multi-step predictions / simulations state updates easier compute. cases TMB simply provides easy framework automatic differentiation. package currently mostly tailored towards Kalman Filter, available methods predict simulate k-step-ahead predictions simulations. also S3 method implementation plot called ctsmTMB.fit class object returned estimate method, plots basic residuals analysis using ggplot2 package. Unscented Kalman Filter implementation based Algorithm 4.7 S. Särkkä, 2007.","code":""},{"path":"/index.html","id":"laplace-filter","dir":"","previous_headings":"","what":"Laplace Filter","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"state-reconstructions based laplace method smoothed estimates, meaning states optimized jointly, given observations data. mathematicals details, see article package webpage. Laplace Approximation natively built-completely handled TMB. noteworthy advantages : C++ compilation needed (using RTMB). addition AD-compile time .e. call RTMB::MakeADFun, identical pre-compiled C++ code. possibility non-Gaussian (unimodal) observation densities accommodate need e.g. heavier distribution tails. method may less useful context model-training towards forecasting likelihood contributions based smoothed estimates, rather one-step predictions (case Kalman filters).","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can install package copying command R. important note users must working C++ compilers install use ctsmTMB.","code":"remotes::install_github(repo=\"phillipbvetter/ctsmTMB\", dependencies=TRUE)"},{"path":"/index.html","id":"windows","dir":"","previous_headings":"","what":"Windows","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"C++ compilation R requires Rtools: Go https://cran.r-project.org/bin/windows/Rtools/ find latest version. Go “Control Panel -> System ->”Advanced” (tab) -> “Environment Variables” -> Highlight “Path” -> “Edit” -> Add character string “Variable Value” path Rtools folder **C:;C:*.","code":""},{"path":"/index.html","id":"mac--unix","dir":"","previous_headings":"","what":"Mac / Unix","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"Mac users install Command Line Tools. Run following command Terminal","code":"xcode-select --install"},{"path":"/index.html","id":"test-the-installation","dir":"","previous_headings":"","what":"Test the Installation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"installed package good idea test whether TMB C++ compilation works. able run examples without compilation errors: information see TMB GitHub associated installation instructions.","code":"library(TMB) runExample(all=TRUE)"},{"path":"/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting Started","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can visit package webpage browse vignettes example uses, particular see Getting Started.","code":""},{"path":"/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"can access documentation methods invidually using standard syntax methods documentation also available package homepage.","code":"?ctsmTMB ?ctsmTMB::addSystem ?ctsmTMB::estimate"},{"path":"/index.html","id":"code-example---inference-in-1d-ornstein-uhlenbeck","dir":"","previous_headings":"","what":"Code Example - Inference in 1D Ornstein-Uhlenbeck","title":"Continuous Time Stochastic Modelling using Template Model Builder","text":"","code":"library(ggplot2) library(patchwork) library(dplyr) library(reshape2) library(ctsmTMB)  ############################################################ # Data simulation ############################################################  # Simulate data using Euler Maruyama set.seed(20) pars = c(theta=10, mu=1, sigma_x=1, sigma_y=0.1) #  dt.sim = 1e-3 t.sim = seq(0,5,by=dt.sim) dw = rnorm(length(t.sim)-1,sd=sqrt(dt.sim)) u.sim = cumsum(rnorm(length(t.sim),sd=0.05)) x = 3 for(i in 1:(length(t.sim)-1)) {   x[i+1] = x[i] + pars[1]*(pars[2]-x[i]+u.sim[i])*dt.sim + pars[3]*dw[i] }  # Extract observations and add noise dt.obs = 1e-2 ids = seq(1,length(t.sim),by=round(dt.obs / dt.sim)) t.obs = t.sim[ids] y = x[ids] + pars[4] * rnorm(length(t.obs)) # forcing input u = u.sim[ids]  # Create data .data = data.frame(   t = t.obs,   y = y,   u = u )  ############################################################ # Model creation and estimation ############################################################  # Create model object model = ctsmTMB$new()  # Set name of model (and the created .cpp file) model$setModelname(\"ornstein_uhlenbeck\")  # Add system equations model$addSystem(   dx ~ theta * (mu-x+u) * dt + sigma_x*dw )  # Add observation equations model$addObs(   y ~ x )  # Set observation equation variances model$setVariance(   y ~ sigma_y^2 )  # Specify algebraic relations model$setAlgebraics(   theta   ~ exp(logtheta),   sigma_x ~ exp(logsigma_x),   sigma_y ~ exp(logsigma_y) )  # Add vector input model$addInput(u)  # Specify parameter initial values and lower/upper bounds in estimation model$setParameter(   logtheta    = log(c(initial = 1, lower=1e-5, upper=50)),   mu          = c(initial=1.5, lower=0, upper=5),   logsigma_x  = log(c(initial=1, lower=1e-10, upper=30)),   logsigma_y  = log(c(initial=1e-1, lower=1e-10, upper=30)) )  # Set initial state mean and covariance model$setInitialState(list(x[1], 1e-1*diag(1)))  # Carry out estimation with default settings (extended kalman filter) fit <- model$estimate(data=.data, method=\"ekf\")  # Check parameter estimates against truth p0 = fit$par.fixed cbind(c(exp(p0[1]),p0[2],exp(p0[3]),exp(p0[4])), pars)  # Create plot of one-step predictions, simulated states and observations t.est = fit$states$mean$prior$t x.mean = fit$states$mean$prior$x x.sd = fit$states$sd$prior$x plot1 = ggplot() +   geom_ribbon(aes(x=t.est, ymin=x.mean-2*x.sd, ymax=x.mean+2*x.sd),fill=\"grey\", alpha=0.9) +   geom_line(aes(x=t.est, x.mean),col=\"steelblue\",lwd=1) +   geom_line(aes(x=t.sim,y=x)) +    geom_point(aes(x=t.obs,y=y),col=\"tomato\",size=1) +   labs(title=\"1-Step State Estimates vs Observations\", x=\"Time\", y=\"\") +   theme_minimal()  # Predict to obtain k-step-ahead predictions to see model forecasting ability pred.list = model$predict(data=.data,                          k.ahead=10,                          method=\"ekf\", )  # Create plot all 10-step predictions against data pred = pred.list$states pred10step = pred %>% dplyr::filter(k.ahead==10) plot2 = ggplot() +   geom_ribbon(aes(x=pred10step$t.j,                    ymin=pred10step$x-2*sqrt(pred10step$var.x),                   ymax=pred10step$x+2*sqrt(pred10step$var.x)),fill=\"grey\", alpha=0.9) +   geom_line(aes(x=pred10step$t.j,pred10step$x),color=\"steelblue\",lwd=1) +   geom_point(aes(x=t.obs,y=y),color=\"tomato\",size=1) +   labs(title=\"10 Step Predictions vs Observations\", x=\"Time\", y=\"\") +   theme_minimal()  # Perform full prediction without data update pred.list = model$predict(data=.data,                          k.ahead=1e6,                          method=\"ekf\", )  # Perform full simulation without data update sim.list = model$simulate(data=.data,                          k.ahead=1e6,                          method=\"ekf\" )  # Collapse simulation data for easy use with ggplot  sim.df = sim.list$states$x$i0 %>%   select(!c(\"i\",\"j\",\"t.i\",\"k.ahead\")) %>%   reshape2::melt(., id.var=\"t.j\")  # Plot all full simulations and the full prediction against observations # (full means no data-update at all) plot3 = ggplot() +   geom_line(data=sim.df, aes(x=t.j, y=value, group=variable),color=\"grey\") +   geom_line(aes(x=pred.list$states$t.j,y=pred.list$states$x),color=\"steelblue\") +   geom_point(aes(x=t.obs,y=y),color=\"tomato\",size=1) +   labs(title=\"No Update Prediction and Simulations vs Observations\", x=\"Time\", y=\"\") +   theme_minimal() + theme(legend.position = \"none\")  # Draw both plots patchwork::wrap_plots(plot1, plot2, plot3, ncol=1)  # Plot one-step-ahead residual analysis using the command below # plot(fit)"},{"path":"/reference/addInput.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify input variables in the model object. — addInput","title":"Specify input variables in the model object. — addInput","text":"Declare whether variable contained system, observation observation variance equations input variable.","code":""},{"path":"/reference/addInput.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify input variables in the model object. — addInput","text":"","code":"addInput(...)"},{"path":"/reference/addInput.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify input variables in the model object. — addInput","text":"... series variable names (unquouted) match variable names defined system treated input variables.","code":""},{"path":"/reference/addObs.html","id":null,"dir":"Reference","previous_headings":"","what":"Add observation equations to model object — addObs","title":"Add observation equations to model object — addObs","text":"Add observation equation ctsmTMB model-object links states observed variable.","code":""},{"path":"/reference/addObs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add observation equations to model object — addObs","text":"","code":"addObs(form, ..., obsnames = NULL)"},{"path":"/reference/addObs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add observation equations to model object — addObs","text":"form formula specifying observation equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list. obsnames character vector specifying observation names used observation left-hand side function call. See details.","code":""},{"path":[]},{"path":"/reference/addObs.html","id":"obsnames","dir":"Reference","previous_headings":"","what":"obsnames","title":"Add observation equations to model object — addObs","text":"obsnames argument used left-hand side form function variable .e. log(y) (class 'call' instead 'name'), Example 3. user provide data y, log-transformation handled internally. supported functions discussed addSystem.","code":""},{"path":"/reference/addSystem.html","id":null,"dir":"Reference","previous_headings":"","what":"Add state equations to model object — addSystem","title":"Add state equations to model object — addSystem","text":"Add stochastic differential equation ctsmTMB model-object governs differential evolution states specified model.","code":""},{"path":"/reference/addSystem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add state equations to model object — addSystem","text":"","code":"addSystem(form, ...)"},{"path":"/reference/addSystem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add state equations to model object — addSystem","text":"form formula specifying stochastic differential equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":[]},{"path":"/reference/addSystem.html","id":"usable-functions","dir":"Reference","previous_headings":"","what":"Usable functions","title":"Add state equations to model object — addSystem","text":"formulas can contain elementary functions log, exp, logit invlogit. general supported functions 1) defined derivative table Deriv package, 2) undestood TMB C++ side.","code":""},{"path":"/reference/create_return_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_prediction","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_prediction","text":"Generates user-friendly data.frame prediction results private$prediction","code":""},{"path":"/reference/create_return_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_prediction","text":"","code":"create_return_prediction(return.covariance, return.k.ahead, self, private)"},{"path":"/reference/create_return_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_prediction","text":"return.covariance boolean indicating whether return state covariances time-step. default behaviour return correlations. return.k.ahead vector integers indicating k.ahead prediction returned 1:k.ahead calculated. self R6 ctsmTMB model object private private fields R6 ctsmTMB model object","code":""},{"path":"/reference/create_return_simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_simulation","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_simulation","text":"Generates user-friendly data.frame prediction results private$prediction","code":""},{"path":"/reference/create_return_simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_simulation","text":"","code":"create_return_simulation(return.k.ahead, n.sims, self, private)"},{"path":"/reference/create_return_simulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates a user-friendly data.frame of prediction results from private$prediction — create_return_simulation","text":"return.k.ahead vector integers indicating k.ahead prediction returned 1:k.ahead calculated. n.sims integer number indicating number stochastic simulations self model object private model object private fields","code":""},{"path":"/reference/ctsmTMB.Deriv.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify Deriv::Deriv — ctsmTMB.Deriv","title":"Modify Deriv::Deriv — ctsmTMB.Deriv","text":"create Deriv function based Deriv::Deriv custom environment drules support new functions e.g erf","code":""},{"path":"/reference/ctsmTMB.Deriv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify Deriv::Deriv — ctsmTMB.Deriv","text":"","code":"ctsmTMB.Deriv(   f,   x = if (is.function(f)) NULL else all.vars(if (is.character(f)) parse(text = f) else f),   env = get_Deriv_environment(),   use.D = FALSE,   cache.exp = FALSE,   nderiv = NULL,   combine = \"c\",   drule = get_Deriv_drules() )"},{"path":"/reference/ctsmTMB.Deriv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify Deriv::Deriv — ctsmTMB.Deriv","text":"f see Deriv documentation x see Deriv documentation env see Deriv documentation use.D see Deriv documentation cache.exp see Deriv documentation nderiv see Deriv documentation combine see Deriv documentation drule see Deriv documentation","code":""},{"path":"/reference/ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"following public methods used construct stochastic state space model system, consisting set stochastic differential equations (SDEs), one algebraic observation equations (AOEs). AOEs used infer information value (latent) states governed SDEs, thus must functions least one state.","code":""},{"path":"/reference/ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"function returns object class R6 ctsmTMB, can used define stochastic state space system.","code":""},{"path":[]},{"path":"/reference/ctsmTMB.html","id":"public-methods","dir":"Reference","previous_headings":"","what":"Public methods","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"ctsmTMB$new() ctsmTMB$addSystem() ctsmTMB$addObs() ctsmTMB$setVariance() ctsmTMB$addInput() ctsmTMB$setParameter() ctsmTMB$setAlgebraics() ctsmTMB$setInitialState() ctsmTMB$setInitialVarianceScaling() ctsmTMB$setLamperti() ctsmTMB$setModelname() ctsmTMB$setCppfilesDirectory() ctsmTMB$setMAP() ctsmTMB$getSystems() ctsmTMB$getObservations() ctsmTMB$getVariances() ctsmTMB$getAlgebraics() ctsmTMB$getInitialState() ctsmTMB$getParameters() ctsmTMB$getEstimate() ctsmTMB$getLikelihood() ctsmTMB$getPrediction() ctsmTMB$getSimulation() ctsmTMB$estimate() ctsmTMB$likelihood() ctsmTMB$predict() ctsmTMB$simulate() ctsmTMB$print() ctsmTMB$summary() ctsmTMB$plot() ctsmTMB$clone()","code":""},{"path":"/reference/ctsmTMB.html","id":"method-new-","dir":"Reference","previous_headings":"","what":"Method new()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Initialize private fields","code":""},{"path":"/reference/ctsmTMB.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$new()"},{"path":"/reference/ctsmTMB.html","id":"method-addsystem-","dir":"Reference","previous_headings":"","what":"Method addSystem()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Define add multiple stochastic differential equation governing process individual state variables form d<state> ~ f(t,<states>,<inputs>) * dt + g1(t,<states>,<inputs>) * dw1  + g2(t,<states>,<inputs>) * dw2 + ... + gN(t,<states>,<inputs>) * dwN f drift, g1, g2, ..., gN diffusions, differential brownian motions dw1, dw2, ..., dwN.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-1","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addSystem(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula specifying stochastic differential equation added system. ... additional formulas similar form specifying multiple equations .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-addobs-","dir":"Reference","previous_headings":"","what":"Method addObs()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Define add relationship observed variable system states. observation equation takes form <observation> ~ h(t,<states>,<inputs>) + e) h observation function, e normally distributed noise zero mean variance specified. observation variable present data provided calling estimate(.data) parameter estimation.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-2","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addObs(form, ..., obsnames = NULL)"},{"path":"/reference/ctsmTMB.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula class specifying obsevation equation added system. ... additional formulas identical form specify multiple observation equations time. obsnames character vector specifying name observation. observation left-hand side consists just single variable name (class 'call' instead 'name') given name form obs__# # number, unless obsnames provided.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setvariance-","dir":"Reference","previous_headings":"","what":"Method setVariance()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Specify variance observation equation. defined observation variable y e.g. addObs(y ~  h(t,<states>,<inputs>) pertubed Gaussian noise zero mean variance -specified using setVariance(y ~ p(t,<states>,<inputs>). can instance declare setVariance(y ~ sigma_x^2 sigma_x fixed effect parameter declared setParameter.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-3","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setVariance(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form formula class specifying obsevation equation added system. ... additional formulas identical form specify multiple observation equations time.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-addinput-","dir":"Reference","previous_headings":"","what":"Method addInput()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare variables data inputs Declare whether variable contained system, observation observation variance equations input variable. e.g. system equation contains input variable u declared using addInput(u). input u must contained data.frame .data provided calling estimate predict methods.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-4","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$addInput(...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"... variable names specifies name input variables defined system.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setparameter-","dir":"Reference","previous_headings":"","what":"Method setParameter()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer value, well lower / upper bounds optimization. two ways declare parameters: can declare parameters using formulas .e. setParameter(  theta = c(1,0,10), mu = c(0,-10,10) ). first value initial value optimizer, second value lower optimization bound third value upper optimization bound. can provide 3-column matrix rows corresponds different parameters, parameter names provided rownames matrix. columns values corresponds description vector format .","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-5","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setParameter(...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"... named vector matrix described .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setalgebraics-","dir":"Reference","previous_headings":"","what":"Method setAlgebraics()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Add algebraic relations. Algebraic relations convenient way transform parameters equations. Ornstein-Uhlenbeck process rate parameter theta always positive, estimation log-domain good idea. Instead writing exp(theta) directly system equation one can transform log domain using algebraic relation setAlgebraics(theta ~ exp(logtheta)). instances theta replaced exp(logtheta) compiling C++ function. Note must provide values logtheta now instead theta declaring parameters setParameter","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-6","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setAlgebraics(form, ...)"},{"path":"/reference/ctsmTMB.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"form algebraic formula ... additional formulas","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setinitialstate-","dir":"Reference","previous_headings":"","what":"Method setInitialState()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-7","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setInitialState(initial.state, estimate = FALSE)"},{"path":"/reference/ctsmTMB.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate boolean value indicates whether initial conditions shall estimated fixed effects parameters. provided mean covariance used initial guesses","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setinitialvariancescaling-","dir":"Reference","previous_headings":"","what":"Method setInitialVarianceScaling()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"scalar value multiplied onto estimated intiial state covariance matrix. scaling applied initial state/cov estimated, set user.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-8","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setInitialVarianceScaling(scaling)"},{"path":"/reference/ctsmTMB.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"scaling numeric scalar value.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setlamperti-","dir":"Reference","previous_headings":"","what":"Method setLamperti()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set Lamperti Transformation provided system equations state dependent diffusion available ways advantageous perform transformation remove state dependence. comes cost complicated drift function. following types state-dependence currently supported 'identity' - diffusion state-independent (default) 'log' - diffusion proportional x * dw 'logit' - diffusion proportional x * (1-x) * dw 'sqrt-logit' - diffusion proportional sqrt(x * (1-x)) * dw","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-9","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setLamperti(transforms, states = NULL)"},{"path":"/reference/ctsmTMB.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"transforms character vector - one either \"identity, \"log\", \"logit\", \"sqrt-logit\" states vector state names specified transformations applied .","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setmodelname-","dir":"Reference","previous_headings":"","what":"Method setModelname()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set modelname used create C++ file TMB calling TMB::MakeADFun (negative log) likelihood function created directory specified setCppfilesDirectory method name <modelname>.cpp","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-10","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setModelname(name)"},{"path":"/reference/ctsmTMB.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"name string defining model name.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setcppfilesdirectory-","dir":"Reference","previous_headings":"","what":"Method setCppfilesDirectory()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Set path directory constructed C++ file created. specify entire path, unless want construct subfolder current working directory - can call e.g. setCppfilesDirectory(\"folder_in_current_wd\").","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-11","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setCppfilesDirectory(directory)"},{"path":"/reference/ctsmTMB.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"directory string specifying local directory","code":""},{"path":"/reference/ctsmTMB.html","id":"method-setmap-","dir":"Reference","previous_headings":"","what":"Method setMAP()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Enable maximum posterior (MAP) estimation. Adds maximum posterior contribution (negative log) likelihood function  evaluating fixed effects parameters multivariate Gaussian mean covariance provided.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-12","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$setMAP(mean, cov)"},{"path":"/reference/ctsmTMB.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"mean mean vector Gaussian prior parameter distribution cov covariance matrix Gaussian prior parameter distribution","code":""},{"path":"/reference/ctsmTMB.html","id":"method-getsystems-","dir":"Reference","previous_headings":"","what":"Method getSystems()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve system equations.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-13","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getSystems()"},{"path":"/reference/ctsmTMB.html","id":"method-getobservations-","dir":"Reference","previous_headings":"","what":"Method getObservations()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve observation equations.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-14","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getObservations()"},{"path":"/reference/ctsmTMB.html","id":"method-getvariances-","dir":"Reference","previous_headings":"","what":"Method getVariances()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve observation variances","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-15","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getVariances()"},{"path":"/reference/ctsmTMB.html","id":"method-getalgebraics-","dir":"Reference","previous_headings":"","what":"Method getAlgebraics()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve algebraic relations","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-16","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getAlgebraics()"},{"path":"/reference/ctsmTMB.html","id":"method-getinitialstate-","dir":"Reference","previous_headings":"","what":"Method getInitialState()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-17","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getInitialState()"},{"path":"/reference/ctsmTMB.html","id":"method-getparameters-","dir":"Reference","previous_headings":"","what":"Method getParameters()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Get initial (estimated) parameters.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-18","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getParameters(type = \"all\", value = \"all\")"},{"path":"/reference/ctsmTMB.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"type one \"\", free\" \"fixed\" parameters. value one \"\", initial\", \"estimate\", \"lower\" \"upper\"","code":""},{"path":"/reference/ctsmTMB.html","id":"method-getestimate-","dir":"Reference","previous_headings":"","what":"Method getEstimate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-19","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getEstimate()"},{"path":"/reference/ctsmTMB.html","id":"method-getlikelihood-","dir":"Reference","previous_headings":"","what":"Method getLikelihood()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-20","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getLikelihood()"},{"path":"/reference/ctsmTMB.html","id":"method-getprediction-","dir":"Reference","previous_headings":"","what":"Method getPrediction()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-21","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getPrediction()"},{"path":"/reference/ctsmTMB.html","id":"method-getsimulation-","dir":"Reference","previous_headings":"","what":"Method getSimulation()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Retrieve initially set state covariance","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-22","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$getSimulation()"},{"path":"/reference/ctsmTMB.html","id":"method-estimate-","dir":"Reference","previous_headings":"","what":"Method estimate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Estimate fixed effects parameters specified model.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-23","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$estimate(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = 3,   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   control = list(trace = 1, iter.max = 1e+05, eval.max = 1e+05),   use.hessian = FALSE,   laplace.residuals = FALSE,   unconstrained.optim = FALSE,   compile = FALSE,   silent = FALSE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector specifying filtering method used state/likelihood calculations. Must one either \"ekf\", \"ekf_rtmb\", ukf\" \"laplace\". natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residauls natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approxmation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. control list control parameters parsed nlminb control argument. See ?stats::nlminb information use.hessian boolean value. default (TRUE) causes optimization algorithm stats::nlminb use fixed effects hessian (negative log) likelihood performing optimization. feature available kalman filter methods without random effects. laplace.residuals boolean - whether calculate one-step ahead residuls using method oneStepPredict. unconstrained.optim boolean value. TRUE optimization carried unconstrained .e. without parameter bounds specified setParameter. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-likelihood-","dir":"Reference","previous_headings":"","what":"Method likelihood()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Construct extract function handlers negative log likelihood function. handlers TMB's MakeADFun constructed returned. enables user e.g. choose optimization algorithm, just control optimization workflow.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-24","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$likelihood(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   loss = \"quadratic\",   loss_c = 3,   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   compile = FALSE,   silent = FALSE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method character vector - one either \"ekf\", \"ukf\" \"tmb\". Sets estimation method. package three available methods implemented: natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep time-step used filtering schemes. time-step two different uses depending chosen method. Kalman Filters: time-step used numerically solving moment differential equations. Laplace Approximation: time-step used Euler-Maruyama simulation scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. loss character vector. Sets loss function type (implemented kalman filter methods). loss function per default quadratic one-step residauls natural Gaussian (negative log) likelihood evaluated, tails distribution considered small .e. outliers weighted much, one can choose loss functions accounts . three available types available: Quadratic loss (quadratic). Quadratic-Linear (huber) Quadratic-Constant (tukey) cutoff Huber Tukey loss functions determined provided cutoff parameter loss_c. implementations losses approximations (pseudo-huber sigmoid approxmation respectively) smooth derivatives. loss_c cutoff value huber tukey loss functions. Defaults c=3 unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. compile boolean value. default (FALSE) compile C++ objective function assume already compiled corresponds specified model object. user's responsibility ensure correspondence specified model precompiled C++ object. precompiled C++ object found specified directory .e. <cppfile_directory>/<modelname>/(dll/) compile flag set TRUE. user makes changes system equations, observation equations, observation variances, algebraic relations lamperi transformations C++ object recompiled. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-predict-","dir":"Reference","previous_headings":"","what":"Method predict()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-25","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$predict(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   initial.state = self$getInitialState(),   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   silent = FALSE,   pars = NULL,   k.ahead = 1,   return.k.ahead = 0:k.ahead,   return.covariance = TRUE )"},{"path":"/reference/ctsmTMB.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate. ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. initial.state named list two entries 'x0' 'p0' containing initial state covariance state unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate function run, default values found optimum. k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. return.covariance booelan value indicate whether covariance (instead correlation) returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"returns","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-simulate-","dir":"Reference","previous_headings":"","what":"Method simulate()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Perform prediction/filtration obtain state mean covariance estimates. predictions obtained solving moment equations n.ahead steps forward time using current step posterior state estimate initial condition.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-26","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$simulate(   data,   method = \"ekf\",   ode.solver = \"rk4\",   ode.timestep = diff(data$t),   simulation.timestep = diff(data$t),   initial.state = self$getInitialState(),   unscented_hyperpars = list(alpha = 1, beta = 0, kappa = 3 - private$number.of.states),   silent = FALSE,   pars = NULL,   n.sims = 100,   k.ahead = 1,   return.k.ahead = 0:k.ahead )"},{"path":"/reference/ctsmTMB.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data data.frame containing time-vector 't', observations inputs. observations can take NA-values. method natural TMB-style formulation latent states considered random effects integrated using Laplace approximation. method yields gradient (negative log) likelihood function respect fixed effects optimization. method slower although probably precision advantages, allows non-Gaussian observation noise (yet implemented). One-step / K-step residuals yet available package. (Continous-Discrete) Extended Kalman Filter system dynamics linearized handle potential non-linearities. computationally fastest method. (Continous-Discrete) Unscented Kalman Filter. higher order non-linear Kalman Filter improves mean covariance estimates system display high nonlinearity, circumvents necessity compute jacobian drift observation functions. package features currently available kalman filters, TMB limited parameter estimation. particular, straight-forward obtain k-step-ahead predictions methods (use predict S3 method), stochastic simulation also available cases long prediction horizons sought, normality assumption inaccurate ode.solver Sets ODE solver used Kalman Filter methods solving moment differential equations. default \"euler\" Forward Euler method, alternatively classical 4th order Runge Kutta method available via \"rk4\". ode.timestep numeric value. Sets time step-size numerical filtering schemes. defined step-size used calculate number steps observation time-points defined provided data. calculated number steps larger N.01 N integer, time-step reduced exactly N+1 steps taken observations step-size used two following ways depending chosen method: Kalman filters: time-step used step-size numerical Forward-Euler scheme compute prior state mean covariance estimate final time solution first second order moment differential equations. TMB method: time-step used step-size Euler-Maruyama scheme simulating sample path stochastic differential equation, serves link together latent (random effects) states. simulation.timestep timestep used euler-maruyama scheme initial.state named list two entries 'x0' 'p0' containing initial state covariance state unscented_hyperpars three hyper-parameters alpha, beta kappa defining unscented transformation. silent logical value whether suppress printed messages 'Checking Data', 'Building Model', etc. Default behaviour (FALSE) print messages. pars fixed parameter vector parsed objective function prediction/filtration. default parameter values used initial parameters provided setParameter, unless estimate function run, default values found optimum. n.sims number simulations k.ahead integer specifying desired number time-steps (determined provided data time-vector) predictions made (integrating moment ODEs forward time without data updates). return.k.ahead numeric vector integers specifying n.ahead predictions returned. return.covariance booelan value indicate whether covariance (instead correlation) returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"returns-1","dir":"Reference","previous_headings":"","what":"Returns","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"data.frame contains time step posterior state estimate time.step (k = 0), prior state predictions (k = 1,...,n.ahead). return.covariance = TRUE state covariance/correlation matrix returned, otherwise marginal variances returned.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-print-","dir":"Reference","previous_headings":"","what":"Method print()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Function print model object","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-27","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$print()"},{"path":"/reference/ctsmTMB.html","id":"method-summary-","dir":"Reference","previous_headings":"","what":"Method summary()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Summary function fit","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-28","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$summary(correlation = FALSE)"},{"path":"/reference/ctsmTMB.html","id":"arguments-17","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"correlation boolean value. default (FALSE) provide fixed effects parameter correlation matrix.","code":""},{"path":"/reference/ctsmTMB.html","id":"method-plot-","dir":"Reference","previous_headings":"","what":"Method plot()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"Function print model object","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-29","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$plot(plot.obs = 1, ggtheme = getggplot2theme())"},{"path":"/reference/ctsmTMB.html","id":"arguments-18","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"plot.obs vector indicate observations plotted . multiple chosen list plots observation returned. ggtheme ggplot2 theme use creating ggplot. pacf logical indicate whether partial autocorrelations returned. default FALSE case histogram returned instead. extended logical. TRUE additional information printed","code":""},{"path":"/reference/ctsmTMB.html","id":"method-clone-","dir":"Reference","previous_headings":"","what":"Method clone()","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"objects class cloneable method.","code":""},{"path":"/reference/ctsmTMB.html","id":"usage-30","dir":"Reference","previous_headings":"","what":"Usage","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"","code":"ctsmTMB$clone(deep = FALSE)"},{"path":"/reference/ctsmTMB.html","id":"arguments-19","dir":"Reference","previous_headings":"","what":"Arguments","title":"Methods for the 'ctsmTMB' R6 class — ctsmTMB","text":"deep Whether make deep clone.","code":""},{"path":"/reference/ekf_rcpp_likelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Function exported to R that performs (Extended Kalman) filtering — ekf_rcpp_likelihood","title":"Function exported to R that performs (Extended Kalman) filtering — ekf_rcpp_likelihood","text":"Function exported R performs (Extended Kalman) filtering","code":""},{"path":"/reference/ekf_rcpp_likelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function exported to R that performs (Extended Kalman) filtering — ekf_rcpp_likelihood","text":"","code":"ekf_rcpp_likelihood(   f__R,   g__R,   dfdx__R,   h__R,   dhdx__R,   hvar__R,   obsMat,   inputMat,   parVec,   covMat,   stateVec,   ode_timestep_size,   ode_timesteps,   bool_is_not_na_obsMat,   number_of_available_obs,   n,   m,   ode_solver )"},{"path":"/reference/ekf_rcpp_likelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function exported to R that performs (Extended Kalman) filtering — ekf_rcpp_likelihood","text":"f__R user-defined drift-function g__R user-defined diffusion-function dfdx__R jacobian f__R h__R user-defined observation-function dhdx__R jacobian h__R hvar__R user-defined observation-variance-function obsMat matrix observations (column-wise) inputMat matrix inputs (column-wise) parVec parameter vector covMat state covariance matrix stateVec state vector ode_timestep_size vector doubles determining ODE time-step sizes ode_timesteps vector integers determining number ODE timesteps bool_is_not_na_obsMat matrix integers determining observations NA number_of_available_obs vector integers determining number non-NA observations iteration n dimension state vector m dimension observation vector ode_solver integer indicating ODE solver use (Euler vs RK4)","code":""},{"path":"/reference/erf.html","id":null,"dir":"Reference","previous_headings":"","what":"Error Function — erf","title":"Error Function — erf","text":"Error Function","code":""},{"path":"/reference/erf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Error Function — erf","text":"","code":"erf(x)"},{"path":"/reference/erf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Error Function — erf","text":"x Input","code":""},{"path":"/reference/execute_ekf_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Function exported to R that performs (Extended Kalman) filtering — execute_ekf_prediction","title":"Function exported to R that performs (Extended Kalman) filtering — execute_ekf_prediction","text":"Function exported R performs (Extended Kalman) filtering","code":""},{"path":"/reference/execute_ekf_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function exported to R that performs (Extended Kalman) filtering — execute_ekf_prediction","text":"","code":"execute_ekf_prediction(   f__R,   g__R,   dfdx__R,   h__R,   dhdx__R,   hvar__R,   obsMat,   inputMat,   parVec,   covMat,   stateVec,   ode_timestep_size,   ode_timesteps,   bool_is_not_na_obsMat,   number_of_available_obs,   n,   m,   last_pred_id,   k_step_ahead,   ode_solver )"},{"path":"/reference/execute_ekf_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function exported to R that performs (Extended Kalman) filtering — execute_ekf_prediction","text":"f__R user-defined drift-function g__R user-defined diffusion-function dfdx__R jacobian f__R h__R user-defined observation-function dhdx__R jacobian h__R hvar__R user-defined observation-variance-function obsMat matrix observations (column-wise) inputMat matrix inputs (column-wise) parVec parameter vector covMat state covariance matrix stateVec state vector ode_timestep_size vector doubles determining ODE time-step sizes ode_timesteps vector integers determining number ODE timesteps bool_is_not_na_obsMat matrix integers determining observations NA number_of_available_obs vector integers determining number non-NA observations iteration n dimension state vector m dimension observation vector last_pred_id integer determining last index k-ahead prediction possible k_step_ahead number prediction steps perform iteration ode_solver integer indicating ODE solver use (Euler vs RK4)","code":""},{"path":"/reference/execute_ekf_simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Function exported to R that performs stochastic simulations with (Extended Kalman) filtering updates — execute_ekf_simulation","title":"Function exported to R that performs stochastic simulations with (Extended Kalman) filtering updates — execute_ekf_simulation","text":"Function exported R performs stochastic simulations (Extended Kalman) filtering updates","code":""},{"path":"/reference/execute_ekf_simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function exported to R that performs stochastic simulations with (Extended Kalman) filtering updates — execute_ekf_simulation","text":"","code":"execute_ekf_simulation(   f__R,   g__R,   dfdx__R,   h__R,   dhdx__R,   hvar__R,   obsMat,   inputMat,   parVec,   covMat,   stateVec,   ode_timestep_size,   ode_timesteps,   simulation_timestep_size,   simulation_timesteps,   bool_is_not_na_obsMat,   number_of_available_obs,   n,   m,   ng,   last_pred_id,   k_step_ahead,   ode_solver,   nsims )"},{"path":"/reference/execute_ekf_simulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function exported to R that performs stochastic simulations with (Extended Kalman) filtering updates — execute_ekf_simulation","text":"f__R user-defined drift-function g__R user-defined diffusion-function dfdx__R jacobian f__R h__R user-defined observation-function dhdx__R jacobian h__R hvar__R user-defined observation-variance-function obsMat matrix observations (column-wise) inputMat matrix inputs (column-wise) parVec parameter vector covMat state covariance matrix stateVec state vector ode_timestep_size vector doubles determining ODE time-step sizes ode_timesteps vector integers determining number ODE timesteps simulation_timestep_size vector doubles determining simlatuon time-step sizes simulation_timesteps vector integers determining number simulation timesteps bool_is_not_na_obsMat matrix integers determining observations NA number_of_available_obs vector integers determining number non-NA observations iteration n dimension state vector m dimension observation vector ng dimension diffusion process last_pred_id integer determining last index k-ahead prediction possible k_step_ahead number prediction steps perform iteration ode_solver integer indicating ODE solver use (Euler vs RK4) nsims integer indicating number stochastic simulations perform","code":""},{"path":"/reference/get_Deriv_drules.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Deriv::Deriv custom drule — get_Deriv_drules","title":"Create Deriv::Deriv custom drule — get_Deriv_drules","text":"functions returns table derivatives symbolic differentiation Deriv, used ctsmTMB.Deriv function.","code":""},{"path":"/reference/get_Deriv_drules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Deriv::Deriv custom drule — get_Deriv_drules","text":"","code":"get_Deriv_drules()"},{"path":"/reference/get_Deriv_environment.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Deriv::Deriv enviroment — get_Deriv_environment","title":"Create Deriv::Deriv enviroment — get_Deriv_environment","text":"functions returns environment Deriv, used ctsmTMB.Deriv function.","code":""},{"path":"/reference/get_Deriv_environment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Deriv::Deriv enviroment — get_Deriv_environment","text":"","code":"get_Deriv_environment()"},{"path":"/reference/get_Deriv_environment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Deriv::Deriv enviroment — get_Deriv_environment","text":"Deriv requires e.g. \"erf\" function specified, even though need numeric calculations (case) - just symbolics. need specify arbitrary function return (NULL).","code":""},{"path":"/reference/invlogit.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse Logit — invlogit","title":"Inverse Logit — invlogit","text":"Inverse Logit","code":""},{"path":"/reference/invlogit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse Logit — invlogit","text":"","code":"invlogit(x)"},{"path":"/reference/invlogit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse Logit — invlogit","text":"x Input","code":""},{"path":"/reference/invlogit2.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverse Logit with Shift and Scale — invlogit2","title":"Inverse Logit with Shift and Scale — invlogit2","text":"Inverse Logit Shift Scale","code":""},{"path":"/reference/invlogit2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverse Logit with Shift and Scale — invlogit2","text":"","code":"invlogit2(x, a, b)"},{"path":"/reference/invlogit2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverse Logit with Shift and Scale — invlogit2","text":"x Input Scaling b Shifting","code":""},{"path":"/reference/logit.html","id":null,"dir":"Reference","previous_headings":"","what":"Logit — logit","title":"Logit — logit","text":"Logit","code":""},{"path":"/reference/logit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logit — logit","text":"","code":"logit(x)"},{"path":"/reference/logit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logit — logit","text":"x Input","code":""},{"path":"/reference/plot.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"function creates residual plots estimated ctsmTMB object","code":""},{"path":"/reference/plot.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit plot(x, plot.obs = 1, ggtheme = getggplot2theme(), ...)"},{"path":"/reference/plot.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"x R6 ctsmTMB fit object plot.obs vector integers indicate observations plotted. multiple requested list plots, one observation returned instead. ggtheme ggplot2 theme use creating ggplot. ... additional arguments","code":""},{"path":"/reference/plot.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB.fit","text":"(list ) ggplot residual plot(s)","code":""},{"path":"/reference/plot.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","text":"function creates residual plots estimated ctsmTMB object","code":""},{"path":"/reference/plot.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","text":"","code":"# S3 method for ctsmTMB plot(x, plot.obs = 1, ggtheme = getggplot2theme(), ...)"},{"path":"/reference/plot.ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","text":"x R6 ctsmTMB object plot.obs vector integers indicate observations plotted. multiple requested list plots, one observation returned instead. ggtheme ggplot2 theme use creating ggplot. ... additional arguments","code":""},{"path":"/reference/plot.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"This function creates residual plots for an estimated ctsmTMB object — plot.ctsmTMB","text":"(list ) ggplot residual plot(s)","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"Plot k-step predictions ctsmTMB prediction object","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"","code":"# S3 method for ctsmTMB.pred plot(x, n.ahead = 0, state.name = NULL, ...)"},{"path":"/reference/plot.ctsmTMB.pred.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"x prediction data.frame ctsmTMB prediction n.ahead integer indicating n-ahead predictions plot state.name string indicating states plot ... additional arguments","code":""},{"path":"/reference/plot.ctsmTMB.pred.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of k-step predictions from a ctsmTMB prediction object — plot.ctsmTMB.pred","text":"huge amount information","code":""},{"path":"/reference/print.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"Basic print objects ctsmTMB fit objects","code":""},{"path":"/reference/print.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit print(x, ...)"},{"path":"/reference/print.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"x ctsmTMB fit object ... additional arguments","code":""},{"path":"/reference/print.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of objects ctsmTMB fit objects — print.ctsmTMB.fit","text":"Print ctsmTMB fit object","code":""},{"path":"/reference/print.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic print of ctsmTMB objects — print.ctsmTMB","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"Basic print ctsmTMB objects","code":""},{"path":"/reference/print.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"","code":"# S3 method for ctsmTMB print(x, ...)"},{"path":"/reference/print.ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"x R6 ctsmTMB model object ... additional arguments","code":""},{"path":"/reference/print.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic print of ctsmTMB objects — print.ctsmTMB","text":"Print ctsmTMB model object","code":""},{"path":"/reference/profile.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"#' Performs full multi-dimensional profile likelihood calculations","code":""},{"path":"/reference/profile.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit profile(   fit,   parlist,   grid.size = rep(10, length(parlist)),   grid.qnt = rep(3, length(parlist)),   hessian = FALSE,   trace = 0,   control = list(trace = trace, iter.max = 1000, eval.max = 1000) )"},{"path":"/reference/profile.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"fit ctmsTMB fit object parlist named-list parameters profile . user can either supply grid-values list leave empty. one list empty grid-values calculated using estimated parameter mean value standard deviation. grid.size vector length(parlist) indicating number grid-points along parameter direction. used parlist empty. grid.qnt vector length(parlist) determining width grid points mean value multiples standard deviation. hessian boolean indicating whether use hessian profile optimization. trace optimization output flag (see nlminb) given control argument. control list optimization output controls (see nlminb)","code":""},{"path":"/reference/profile.ctsmTMB.fit.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"#' Performs full multi-dimensional profile likelihood calculations — profile.ctsmTMB.fit","text":"implemetation modified https://github.com/kaskr/adcomp/blob/master/TMB/R/tmbprofile.R","code":""},{"path":"/reference/rcpp_ekf_estimate.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate function that calls the underlying Rcpp estimate ekf function — rcpp_ekf_estimate","title":"Estimate function that calls the underlying Rcpp estimate ekf function — rcpp_ekf_estimate","text":"Estimate function calls underlying Rcpp estimate ekf function","code":""},{"path":"/reference/rcpp_ekf_estimate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate function that calls the underlying Rcpp estimate ekf function — rcpp_ekf_estimate","text":"","code":"rcpp_ekf_estimate(self, private)"},{"path":"/reference/rcpp_ekf_estimate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate function that calls the underlying Rcpp estimate ekf function — rcpp_ekf_estimate","text":"self model object private model object private fields","code":""},{"path":"/reference/rcpp_prediction.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction function that calls the underlying Rcpp prediction function — rcpp_prediction","title":"Prediction function that calls the underlying Rcpp prediction function — rcpp_prediction","text":"Prediction function calls underlying Rcpp prediction function","code":""},{"path":"/reference/rcpp_prediction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction function that calls the underlying Rcpp prediction function — rcpp_prediction","text":"","code":"rcpp_prediction(self, private)"},{"path":"/reference/rcpp_prediction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction function that calls the underlying Rcpp prediction function — rcpp_prediction","text":"self R6 ctsmTMB model object private private fields R6 ctsmTMB model object","code":""},{"path":"/reference/rcpp_simulation.html","id":null,"dir":"Reference","previous_headings":"","what":"Stochastic Euler-Maruyama simulation function that calls the underlying Rcpp simulation function — rcpp_simulation","title":"Stochastic Euler-Maruyama simulation function that calls the underlying Rcpp simulation function — rcpp_simulation","text":"Stochastic Euler-Maruyama simulation function calls underlying Rcpp simulation function","code":""},{"path":"/reference/rcpp_simulation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stochastic Euler-Maruyama simulation function that calls the underlying Rcpp simulation function — rcpp_simulation","text":"","code":"rcpp_simulation(self, private, n.sims)"},{"path":"/reference/rcpp_simulation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stochastic Euler-Maruyama simulation function that calls the underlying Rcpp simulation function — rcpp_simulation","text":"self model object private model object private fields n.sims integer giving number stochastic simulations performed","code":""},{"path":"/reference/setAlgebraics.html","id":null,"dir":"Reference","previous_headings":"","what":"Add algebraic relationships to the model object. — setAlgebraics","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"Algebraic relations convenient way transform parameters equations, reduce clutter specying various equations, instance ensure positivity (log-transform).","code":""},{"path":"/reference/setAlgebraics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"","code":"setAlgebraics(form, ...)"},{"path":"/reference/setAlgebraics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"form formula specifying algebraic relation. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":"/reference/setAlgebraics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add algebraic relationships to the model object. — setAlgebraics","text":"left-hand side provided formula specifies parameter overwritten expression right-hand side. also means left-hand side parameter vanish model formulation link{setParameter} therefore specify values new parameters.","code":""},{"path":"/reference/setInitialState.html","id":null,"dir":"Reference","previous_headings":"","what":"Set initial state mean and covariance — setInitialState","title":"Set initial state mean and covariance — setInitialState","text":"Declare initial state values .e. mean covariance system states.","code":""},{"path":"/reference/setInitialState.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set initial state mean and covariance — setInitialState","text":"","code":"setInitialState(initial.state, estimate = FALSE)"},{"path":"/reference/setInitialState.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set initial state mean and covariance — setInitialState","text":"initial.state named list two entries 'x0' 'p0' containing initial state covariance state estimate boolean value indicates whether initial conditions shall estimated fixed effects parameters. provided mean covariance used initial guesses","code":""},{"path":"/reference/setParameter.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify parameters in the model object — setParameter","title":"Specify parameters in the model object — setParameter","text":"Declare variables (fixed effects) parameters specified model, specify initial optimizer values, well lower / upper bounds. Parameters can declared either vectors matrices. first entry initial value, second entry lower bound third entry upper bound. Providing first entry fixes particular parameter value.","code":""},{"path":"/reference/setParameter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify parameters in the model object — setParameter","text":"","code":"setParameter(...)"},{"path":"/reference/setParameter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify parameters in the model object — setParameter","text":"... comma-seperated series vectors/matrix entries","code":""},{"path":"/reference/setParameter.html","id":"example-","dir":"Reference","previous_headings":"","what":"Example 2","title":"Specify parameters in the model object — setParameter","text":"parmat = matrix(rep(c(0,-10,10),times=3),ncol=3,byrow=T) rownames(parmat) = c(\"\",\"b\",\"c\") colnames(parmat) = c(\"initial\",\"lower\",\"upper\") setParameter(parmat)","code":""},{"path":"/reference/setVariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Add observation variances to the model object. — setVariance","title":"Add observation variances to the model object. — setVariance","text":"Specify observation variance existing observation equation.","code":""},{"path":"/reference/setVariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add observation variances to the model object. — setVariance","text":"","code":"setVariance(form, ...)"},{"path":"/reference/setVariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add observation variances to the model object. — setVariance","text":"form formula class specifying obsevation equation added system. ... formulas similar form, used allow specifying multiple formulas comma-seperation rather providing list.","code":""},{"path":"/reference/summary.ctsmTMB.fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"Basic summary ctsmTMB fit object","code":""},{"path":"/reference/summary.ctsmTMB.fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"","code":"# S3 method for ctsmTMB.fit summary(object, correlation = FALSE, ...)"},{"path":"/reference/summary.ctsmTMB.fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"object ctsmTMB fit object correlation boolean indicating whether display parameter correlation structure ... additional arguments","code":""},{"path":"/reference/summary.ctsmTMB.fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of ctsmTMB fit object — summary.ctsmTMB.fit","text":"summary estimated ctsmTMB model fit","code":""},{"path":"/reference/summary.ctsmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"Basic summary objects class 'ctsmTMB'","code":""},{"path":"/reference/summary.ctsmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"","code":"# S3 method for ctsmTMB summary(object, correlation = FALSE, ...)"},{"path":"/reference/summary.ctsmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"object R6 ctsmTMB model object correlation boolean indicate whether return parameter correlations ... additional arguments","code":""},{"path":"/reference/summary.ctsmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic summary of objects of class 'ctsmTMB' — summary.ctsmTMB","text":"summary model object","code":""},{"path":"/news/index.html","id":"ctsmtmb-100","dir":"Changelog","previous_headings":"","what":"ctsmTMB 1.0.0","title":"ctsmTMB 1.0.0","text":"first release package","code":""}]
